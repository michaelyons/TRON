/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/mocha-loader/index.js!./test/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-loader/lib/index.js!./test/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/babel-loader/lib!./test/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/mocha-loader/index.js!./test/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mocha-loader!./test/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/mocha-loader/web.js */ "./node_modules/mocha-loader/web.js");
if(typeof window !== 'undefined' && window.initMochaPhantomJS) { window.initMochaPhantomJS(); }
mocha.setup({"ui":"bdd"});
__webpack_require__(/*! !./node_modules/babel-loader/lib!./test/index.js */ "./node_modules/babel-loader/lib/index.js!./test/index.js")
__webpack_require__(/*! !./node_modules/mocha-loader/start.js */ "./node_modules/mocha-loader/start.js");
if(false) {}

/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css":
/*!******************************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/css-loader!./node_modules/mocha/mocha.css ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../mocha-loader/node_modules/css-loader/lib/css-base.js */ "./node_modules/mocha-loader/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "@charset \"utf-8\";\n\nbody {\n  margin:0;\n}\n\n#mocha {\n  font: 20px/1.5 \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  margin: 60px 50px;\n}\n\n#mocha ul,\n#mocha li {\n  margin: 0;\n  padding: 0;\n}\n\n#mocha ul {\n  list-style: none;\n}\n\n#mocha h1,\n#mocha h2 {\n  margin: 0;\n}\n\n#mocha h1 {\n  margin-top: 15px;\n  font-size: 1em;\n  font-weight: 200;\n}\n\n#mocha h1 a {\n  text-decoration: none;\n  color: inherit;\n}\n\n#mocha h1 a:hover {\n  text-decoration: underline;\n}\n\n#mocha .suite .suite h1 {\n  margin-top: 0;\n  font-size: .8em;\n}\n\n#mocha .hidden {\n  display: none;\n}\n\n#mocha h2 {\n  font-size: 12px;\n  font-weight: normal;\n  cursor: pointer;\n}\n\n#mocha .suite {\n  margin-left: 15px;\n}\n\n#mocha .test {\n  margin-left: 15px;\n  overflow: hidden;\n}\n\n#mocha .test.pending:hover h2::after {\n  content: '(pending)';\n  font-family: arial, sans-serif;\n}\n\n#mocha .test.pass.medium .duration {\n  background: #c09853;\n}\n\n#mocha .test.pass.slow .duration {\n  background: #b94a48;\n}\n\n#mocha .test.pass::before {\n  content: '\\2713';\n  font-size: 12px;\n  display: block;\n  float: left;\n  margin-right: 5px;\n  color: #00d6b2;\n}\n\n#mocha .test.pass .duration {\n  font-size: 9px;\n  margin-left: 5px;\n  padding: 2px 5px;\n  color: #fff;\n  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  -moz-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  -webkit-border-radius: 5px;\n  -moz-border-radius: 5px;\n  -ms-border-radius: 5px;\n  -o-border-radius: 5px;\n  border-radius: 5px;\n}\n\n#mocha .test.pass.fast .duration {\n  display: none;\n}\n\n#mocha .test.pending {\n  color: #0b97c4;\n}\n\n#mocha .test.pending::before {\n  content: '\\25E6';\n  color: #0b97c4;\n}\n\n#mocha .test.fail {\n  color: #c00;\n}\n\n#mocha .test.fail pre {\n  color: black;\n}\n\n#mocha .test.fail::before {\n  content: '\\2716';\n  font-size: 12px;\n  display: block;\n  float: left;\n  margin-right: 5px;\n  color: #c00;\n}\n\n#mocha .test pre.error {\n  color: #c00;\n  max-height: 300px;\n  overflow: auto;\n}\n\n#mocha .test .html-error {\n  overflow: auto;\n  color: black;\n  line-height: 1.5;\n  display: block;\n  float: left;\n  clear: left;\n  font: 12px/1.5 monaco, monospace;\n  margin: 5px;\n  padding: 15px;\n  border: 1px solid #eee;\n  max-width: 85%; /*(1)*/\n  max-width: -webkit-calc(100% - 42px);\n  max-width: -moz-calc(100% - 42px);\n  max-width: calc(100% - 42px); /*(2)*/\n  max-height: 300px;\n  word-wrap: break-word;\n  border-bottom-color: #ddd;\n  -webkit-box-shadow: 0 1px 3px #eee;\n  -moz-box-shadow: 0 1px 3px #eee;\n  box-shadow: 0 1px 3px #eee;\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  border-radius: 3px;\n}\n\n#mocha .test .html-error pre.error {\n  border: none;\n  -webkit-border-radius: 0;\n  -moz-border-radius: 0;\n  border-radius: 0;\n  -webkit-box-shadow: 0;\n  -moz-box-shadow: 0;\n  box-shadow: 0;\n  padding: 0;\n  margin: 0;\n  margin-top: 18px;\n  max-height: none;\n}\n\n/**\n * (1): approximate for browsers not supporting calc\n * (2): 42 = 2*15 + 2*10 + 2*1 (padding + margin + border)\n *      ^^ seriously\n */\n#mocha .test pre {\n  display: block;\n  float: left;\n  clear: left;\n  font: 12px/1.5 monaco, monospace;\n  margin: 5px;\n  padding: 15px;\n  border: 1px solid #eee;\n  max-width: 85%; /*(1)*/\n  max-width: -webkit-calc(100% - 42px);\n  max-width: -moz-calc(100% - 42px);\n  max-width: calc(100% - 42px); /*(2)*/\n  word-wrap: break-word;\n  border-bottom-color: #ddd;\n  -webkit-box-shadow: 0 1px 3px #eee;\n  -moz-box-shadow: 0 1px 3px #eee;\n  box-shadow: 0 1px 3px #eee;\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  border-radius: 3px;\n}\n\n#mocha .test h2 {\n  position: relative;\n}\n\n#mocha .test a.replay {\n  position: absolute;\n  top: 3px;\n  right: 0;\n  text-decoration: none;\n  vertical-align: middle;\n  display: block;\n  width: 15px;\n  height: 15px;\n  line-height: 15px;\n  text-align: center;\n  background: #eee;\n  font-size: 15px;\n  -webkit-border-radius: 15px;\n  -moz-border-radius: 15px;\n  border-radius: 15px;\n  -webkit-transition:opacity 200ms;\n  -moz-transition:opacity 200ms;\n  -o-transition:opacity 200ms;\n  transition: opacity 200ms;\n  opacity: 0.3;\n  color: #888;\n}\n\n#mocha .test:hover a.replay {\n  opacity: 1;\n}\n\n#mocha-report.pass .test.fail {\n  display: none;\n}\n\n#mocha-report.fail .test.pass {\n  display: none;\n}\n\n#mocha-report.pending .test.pass,\n#mocha-report.pending .test.fail {\n  display: none;\n}\n#mocha-report.pending .test.pass.pending {\n  display: block;\n}\n\n#mocha-error {\n  color: #c00;\n  font-size: 1.5em;\n  font-weight: 100;\n  letter-spacing: 1px;\n}\n\n#mocha-stats {\n  position: fixed;\n  top: 15px;\n  right: 10px;\n  font-size: 12px;\n  margin: 0;\n  color: #888;\n  z-index: 1;\n}\n\n#mocha-stats .progress {\n  float: right;\n  padding-top: 0;\n\n  /**\n   * Set safe initial values, so mochas .progress does not inherit these\n   * properties from Bootstrap .progress (which causes .progress height to\n   * equal line height set in Bootstrap).\n   */\n  height: auto;\n  -webkit-box-shadow: none;\n  -moz-box-shadow: none;\n  box-shadow: none;\n  background-color: initial;\n}\n\n#mocha-stats em {\n  color: black;\n}\n\n#mocha-stats a {\n  text-decoration: none;\n  color: inherit;\n}\n\n#mocha-stats a:hover {\n  border-bottom: 1px solid #eee;\n}\n\n#mocha-stats li {\n  display: inline-block;\n  margin: 0 5px;\n  list-style: none;\n  padding-top: 11px;\n}\n\n#mocha-stats canvas {\n  width: 40px;\n  height: 40px;\n}\n\n#mocha code .comment { color: #ddd; }\n#mocha code .init { color: #2f6fad; }\n#mocha code .string { color: #5890ad; }\n#mocha code .keyword { color: #8a6343; }\n#mocha code .number { color: #2f6fad; }\n\n@media screen and (max-device-width: 480px) {\n  #mocha {\n    margin: 60px 0px;\n  }\n\n  #mocha #stats {\n    position: absolute;\n  }\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/css-loader/lib/css-base.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/css-loader/lib/css-base.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/style-loader/index.js!./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/style-loader!./node_modules/mocha-loader/node_modules/css-loader!./node_modules/mocha/mocha.css ***!
  \************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../mocha-loader/node_modules/css-loader!./mocha.css */ "./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(/*! ../mocha-loader/node_modules/style-loader/lib/addStyles.js */ "./node_modules/mocha-loader/node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/style-loader/lib/addStyles.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/style-loader/lib/addStyles.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			var styleTarget = fn.call(this, selector);
			// Special case to return head of iframe instead of iframe itself
			if (styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[selector] = styleTarget;
		}
		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/mocha-loader/node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/style-loader/lib/urls.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/style-loader/lib/urls.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/mocha-loader/start.js":
/*!********************************************!*\
  !*** ./node_modules/mocha-loader/start.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {process.nextTick(function() {
	delete __webpack_require__.c[module.i];
	if(typeof window !== "undefined" && window.mochaPhantomJS)
		mochaPhantomJS.run();
	else
		mocha.run();
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha-loader/web.js":
/*!******************************************!*\
  !*** ./node_modules/mocha-loader/web.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

if (! document.getElementById("mocha")) { document.write("<div id=\"mocha\"></div>"); }

__webpack_require__(/*! style-loader!css-loader!mocha/mocha.css */ "./node_modules/mocha-loader/node_modules/style-loader/index.js!./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css");
__webpack_require__(/*! script-loader!mocha/mocha.js */ "./node_modules/script-loader/index.js!./node_modules/mocha/mocha.js");


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/mocha/mocha.js":
/*!***************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/mocha/mocha.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/* eslint no-unused-vars: off */\n/* eslint-env commonjs */\n\n/**\n * Shim process.stdout.\n */\n\nprocess.stdout = require('browser-stdout')({level: false});\n\nvar Mocha = require('./lib/mocha');\n\n/**\n * Create a Mocha instance.\n *\n * @return {undefined}\n */\n\nvar mocha = new Mocha({reporter: 'html'});\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n\nvar uncaughtExceptionHandlers = [];\n\nvar originalOnerrorHandler = global.onerror;\n\n/**\n * Remove uncaughtException listener.\n * Revert to original onerror handler if previously defined.\n */\n\nprocess.removeListener = function(e, fn) {\n  if (e === 'uncaughtException') {\n    if (originalOnerrorHandler) {\n      global.onerror = originalOnerrorHandler;\n    } else {\n      global.onerror = function() {};\n    }\n    var i = uncaughtExceptionHandlers.indexOf(fn);\n    if (i !== -1) {\n      uncaughtExceptionHandlers.splice(i, 1);\n    }\n  }\n};\n\n/**\n * Implements uncaughtException listener.\n */\n\nprocess.on = function(e, fn) {\n  if (e === 'uncaughtException') {\n    global.onerror = function(err, url, line) {\n      fn(new Error(err + ' (' + url + ':' + line + ')'));\n      return !mocha.allowUncaught;\n    };\n    uncaughtExceptionHandlers.push(fn);\n  }\n};\n\n// The BDD UI is registered by default, but no UI will be functional in the\n// browser without an explicit call to the overridden `mocha.ui` (see below).\n// Ensure that this default UI does not expose its methods to the global scope.\nmocha.suite.removeAllListeners('pre-require');\n\nvar immediateQueue = [];\nvar immediateTimeout;\n\nfunction timeslice() {\n  var immediateStart = new Date().getTime();\n  while (immediateQueue.length && new Date().getTime() - immediateStart < 100) {\n    immediateQueue.shift()();\n  }\n  if (immediateQueue.length) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  } else {\n    immediateTimeout = null;\n  }\n}\n\n/**\n * High-performance override of Runner.immediately.\n */\n\nMocha.Runner.immediately = function(callback) {\n  immediateQueue.push(callback);\n  if (!immediateTimeout) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  }\n};\n\n/**\n * Function to allow assertion libraries to throw errors directly into mocha.\n * This is useful when running tests in a browser because window.onerror will\n * only receive the 'message' attribute of the Error.\n */\nmocha.throwError = function(err) {\n  uncaughtExceptionHandlers.forEach(function(fn) {\n    fn(err);\n  });\n  throw err;\n};\n\n/**\n * Override ui to ensure that the ui functions are initialized.\n * Normally this would happen in Mocha.prototype.loadFiles.\n */\n\nmocha.ui = function(ui) {\n  Mocha.prototype.ui.call(this, ui);\n  this.suite.emit('pre-require', global, null, this);\n  return this;\n};\n\n/**\n * Setup mocha with the given setting options.\n */\n\nmocha.setup = function(opts) {\n  if (typeof opts === 'string') {\n    opts = {ui: opts};\n  }\n  for (var opt in opts) {\n    if (opts.hasOwnProperty(opt)) {\n      this[opt](opts[opt]);\n    }\n  }\n  return this;\n};\n\n/**\n * Run mocha, returning the Runner.\n */\n\nmocha.run = function(fn) {\n  var options = mocha.options;\n  mocha.globals('location');\n\n  var query = Mocha.utils.parseQuery(global.location.search || '');\n  if (query.grep) {\n    mocha.grep(query.grep);\n  }\n  if (query.fgrep) {\n    mocha.fgrep(query.fgrep);\n  }\n  if (query.invert) {\n    mocha.invert();\n  }\n\n  return Mocha.prototype.run.call(mocha, function(err) {\n    // The DOM Document is not available in Web Workers.\n    var document = global.document;\n    if (\n      document &&\n      document.getElementById('mocha') &&\n      options.noHighlighting !== true\n    ) {\n      Mocha.utils.highlightTags('code');\n    }\n    if (fn) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * Expose the process shim.\n * https://github.com/mochajs/mocha/pull/916\n */\n\nMocha.process = process;\n\n/**\n * Expose mocha.\n */\n\nglobal.Mocha = Mocha;\nglobal.mocha = mocha;\n\n// this allows test/acceptance/required-tokens.js to pass; thus,\n// you can now do `const describe = require('mocha').describe` in a\n// browser context (assuming browserification).  should fix #880\nmodule.exports = global;\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./lib/mocha\":13,\"_process\":56,\"browser-stdout\":39}],2:[function(require,module,exports){\n'use strict';\n\n// just stub out growl\n\nmodule.exports = require('../utils').noop;\n\n},{\"../utils\":36}],3:[function(require,module,exports){\n'use strict';\n\n/**\n * Expose `Progress`.\n */\n\nmodule.exports = Progress;\n\n/**\n * Initialize a new `Progress` indicator.\n */\nfunction Progress() {\n  this.percent = 0;\n  this.size(0);\n  this.fontSize(11);\n  this.font('helvetica, arial, sans-serif');\n}\n\n/**\n * Set progress size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.size = function(size) {\n  this._size = size;\n  return this;\n};\n\n/**\n * Set text to `text`.\n *\n * @api public\n * @param {string} text\n * @return {Progress} Progress instance.\n */\nProgress.prototype.text = function(text) {\n  this._text = text;\n  return this;\n};\n\n/**\n * Set font size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.fontSize = function(size) {\n  this._fontSize = size;\n  return this;\n};\n\n/**\n * Set font to `family`.\n *\n * @param {string} family\n * @return {Progress} Progress instance.\n */\nProgress.prototype.font = function(family) {\n  this._font = family;\n  return this;\n};\n\n/**\n * Update percentage to `n`.\n *\n * @param {number} n\n * @return {Progress} Progress instance.\n */\nProgress.prototype.update = function(n) {\n  this.percent = n;\n  return this;\n};\n\n/**\n * Draw on `ctx`.\n *\n * @param {CanvasRenderingContext2d} ctx\n * @return {Progress} Progress instance.\n */\nProgress.prototype.draw = function(ctx) {\n  try {\n    var percent = Math.min(this.percent, 100);\n    var size = this._size;\n    var half = size / 2;\n    var x = half;\n    var y = half;\n    var rad = half - 1;\n    var fontSize = this._fontSize;\n\n    ctx.font = fontSize + 'px ' + this._font;\n\n    var angle = Math.PI * 2 * (percent / 100);\n    ctx.clearRect(0, 0, size, size);\n\n    // outer circle\n    ctx.strokeStyle = '#9f9f9f';\n    ctx.beginPath();\n    ctx.arc(x, y, rad, 0, angle, false);\n    ctx.stroke();\n\n    // inner circle\n    ctx.strokeStyle = '#eee';\n    ctx.beginPath();\n    ctx.arc(x, y, rad - 1, 0, angle, true);\n    ctx.stroke();\n\n    // text\n    var text = this._text || (percent | 0) + '%';\n    var w = ctx.measureText(text).width;\n\n    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);\n  } catch (ignore) {\n    // don't fail if we can't render progress\n  }\n  return this;\n};\n\n},{}],4:[function(require,module,exports){\n(function (global){\n'use strict';\n\nexports.isatty = function isatty() {\n  return true;\n};\n\nexports.getWindowSize = function getWindowSize() {\n  if ('innerHeight' in global) {\n    return [global.innerHeight, global.innerWidth];\n  }\n  // In a Web Worker, the DOM Window is not available.\n  return [640, 480];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],5:[function(require,module,exports){\n'use strict';\n/**\n * @module Context\n */\n/**\n * Expose `Context`.\n */\n\nmodule.exports = Context;\n\n/**\n * Initialize a new `Context`.\n *\n * @api private\n */\nfunction Context() {}\n\n/**\n * Set or get the context `Runnable` to `runnable`.\n *\n * @api private\n * @param {Runnable} runnable\n * @return {Context} context\n */\nContext.prototype.runnable = function(runnable) {\n  if (!arguments.length) {\n    return this._runnable;\n  }\n  this.test = this._runnable = runnable;\n  return this;\n};\n\n/**\n * Set or get test timeout `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.timeout = function(ms) {\n  if (!arguments.length) {\n    return this.runnable().timeout();\n  }\n  this.runnable().timeout(ms);\n  return this;\n};\n\n/**\n * Set test timeout `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Context} self\n */\nContext.prototype.enableTimeouts = function(enabled) {\n  if (!arguments.length) {\n    return this.runnable().enableTimeouts();\n  }\n  this.runnable().enableTimeouts(enabled);\n  return this;\n};\n\n/**\n * Set or get test slowness threshold `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.slow = function(ms) {\n  if (!arguments.length) {\n    return this.runnable().slow();\n  }\n  this.runnable().slow(ms);\n  return this;\n};\n\n/**\n * Mark a test as skipped.\n *\n * @api private\n * @throws Pending\n */\nContext.prototype.skip = function() {\n  this.runnable().skip();\n};\n\n/**\n * Set or get a number of allowed retries on failed tests\n *\n * @api private\n * @param {number} n\n * @return {Context} self\n */\nContext.prototype.retries = function(n) {\n  if (!arguments.length) {\n    return this.runnable().retries();\n  }\n  this.runnable().retries(n);\n  return this;\n};\n\n},{}],6:[function(require,module,exports){\n'use strict';\n\nvar Runnable = require('./runnable');\nvar inherits = require('./utils').inherits;\n\n/**\n * Expose `Hook`.\n */\n\nmodule.exports = Hook;\n\n/**\n * Initialize a new `Hook` with the given `title` and callback `fn`\n *\n * @class\n * @extends Runnable\n * @param {String} title\n * @param {Function} fn\n */\nfunction Hook(title, fn) {\n  Runnable.call(this, title, fn);\n  this.type = 'hook';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\ninherits(Hook, Runnable);\n\n/**\n * Get or set the test `err`.\n *\n * @memberof Hook\n * @public\n * @param {Error} err\n * @return {Error}\n */\nHook.prototype.error = function(err) {\n  if (!arguments.length) {\n    err = this._error;\n    this._error = null;\n    return err;\n  }\n\n  this._error = err;\n};\n\n},{\"./runnable\":32,\"./utils\":36}],7:[function(require,module,exports){\n'use strict';\n\nvar Test = require('../test');\n\n/**\n * BDD-style interface:\n *\n *      describe('Array', function() {\n *        describe('#indexOf()', function() {\n *          it('should return -1 when not present', function() {\n *            // ...\n *          });\n *\n *          it('should return the index when present', function() {\n *            // ...\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function bddInterface(suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function(context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`\n     * and callback `fn` containing nested suites\n     * and/or tests.\n     */\n\n    context.describe = context.context = function(title, fn) {\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Pending describe.\n     */\n\n    context.xdescribe = context.xcontext = context.describe.skip = function(\n      title,\n      fn\n    ) {\n      return common.suite.skip({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Exclusive suite.\n     */\n\n    context.describe.only = function(title, fn) {\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.it = context.specify = function(title, fn) {\n      var suite = suites[0];\n      if (suite.isPending()) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.it.only = function(title, fn) {\n      return common.test.only(mocha, context.it(title, fn));\n    };\n\n    /**\n     * Pending test case.\n     */\n\n    context.xit = context.xspecify = context.it.skip = function(title) {\n      return context.it(title);\n    };\n\n    /**\n     * Number of attempts to retry.\n     */\n    context.it.retries = function(n) {\n      context.retries(n);\n    };\n  });\n};\n\n},{\"../test\":35,\"./common\":8}],8:[function(require,module,exports){\n'use strict';\n\nvar Suite = require('../suite');\n\n/**\n * Functions common to more than one interface.\n *\n * @param {Suite[]} suites\n * @param {Context} context\n * @param {Mocha} mocha\n * @return {Object} An object containing common functions.\n */\nmodule.exports = function(suites, context, mocha) {\n  return {\n    /**\n     * This is only present if flag --delay is passed into Mocha. It triggers\n     * root suite execution.\n     *\n     * @param {Suite} suite The root suite.\n     * @return {Function} A function which runs the root suite\n     */\n    runWithSuite: function runWithSuite(suite) {\n      return function run() {\n        suite.run();\n      };\n    },\n\n    /**\n     * Execute before running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    before: function(name, fn) {\n      suites[0].beforeAll(name, fn);\n    },\n\n    /**\n     * Execute after running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    after: function(name, fn) {\n      suites[0].afterAll(name, fn);\n    },\n\n    /**\n     * Execute before each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    beforeEach: function(name, fn) {\n      suites[0].beforeEach(name, fn);\n    },\n\n    /**\n     * Execute after each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    afterEach: function(name, fn) {\n      suites[0].afterEach(name, fn);\n    },\n\n    suite: {\n      /**\n       * Create an exclusive Suite; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      only: function only(opts) {\n        opts.isOnly = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Create a Suite, but skip it; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      skip: function skip(opts) {\n        opts.pending = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Creates a suite.\n       * @param {Object} opts Options\n       * @param {string} opts.title Title of Suite\n       * @param {Function} [opts.fn] Suite Function (not always applicable)\n       * @param {boolean} [opts.pending] Is Suite pending?\n       * @param {string} [opts.file] Filepath where this Suite resides\n       * @param {boolean} [opts.isOnly] Is Suite exclusive?\n       * @returns {Suite}\n       */\n      create: function create(opts) {\n        var suite = Suite.create(suites[0], opts.title);\n        suite.pending = Boolean(opts.pending);\n        suite.file = opts.file;\n        suites.unshift(suite);\n        if (opts.isOnly) {\n          suite.parent._onlySuites = suite.parent._onlySuites.concat(suite);\n        }\n        if (typeof opts.fn === 'function') {\n          opts.fn.call(suite);\n          suites.shift();\n        } else if (typeof opts.fn === 'undefined' && !suite.pending) {\n          throw new Error(\n            'Suite \"' +\n              suite.fullTitle() +\n              '\" was defined but no callback was supplied. Supply a callback or explicitly skip the suite.'\n          );\n        } else if (!opts.fn && suite.pending) {\n          suites.shift();\n        }\n\n        return suite;\n      }\n    },\n\n    test: {\n      /**\n       * Exclusive test-case.\n       *\n       * @param {Object} mocha\n       * @param {Function} test\n       * @returns {*}\n       */\n      only: function(mocha, test) {\n        test.parent._onlyTests = test.parent._onlyTests.concat(test);\n        return test;\n      },\n\n      /**\n       * Pending test case.\n       *\n       * @param {string} title\n       */\n      skip: function(title) {\n        context.test(title);\n      },\n\n      /**\n       * Number of retry attempts\n       *\n       * @param {number} n\n       */\n      retries: function(n) {\n        context.retries(n);\n      }\n    }\n  };\n};\n\n},{\"../suite\":34}],9:[function(require,module,exports){\n'use strict';\nvar Suite = require('../suite');\nvar Test = require('../test');\n\n/**\n * Exports-style (as Node.js module) interface:\n *\n *     exports.Array = {\n *       '#indexOf()': {\n *         'should return -1 when the value is not present': function() {\n *\n *         },\n *\n *         'should return the correct index when the value is present': function() {\n *\n *         }\n *       }\n *     };\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function(suite) {\n  var suites = [suite];\n\n  suite.on('require', visit);\n\n  function visit(obj, file) {\n    var suite;\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        var fn = obj[key];\n        switch (key) {\n          case 'before':\n            suites[0].beforeAll(fn);\n            break;\n          case 'after':\n            suites[0].afterAll(fn);\n            break;\n          case 'beforeEach':\n            suites[0].beforeEach(fn);\n            break;\n          case 'afterEach':\n            suites[0].afterEach(fn);\n            break;\n          default:\n            var test = new Test(key, fn);\n            test.file = file;\n            suites[0].addTest(test);\n        }\n      } else {\n        suite = Suite.create(suites[0], key);\n        suites.unshift(suite);\n        visit(obj[key], file);\n        suites.shift();\n      }\n    }\n  }\n};\n\n},{\"../suite\":34,\"../test\":35}],10:[function(require,module,exports){\n'use strict';\n\nexports.bdd = require('./bdd');\nexports.tdd = require('./tdd');\nexports.qunit = require('./qunit');\nexports.exports = require('./exports');\n\n},{\"./bdd\":7,\"./exports\":9,\"./qunit\":11,\"./tdd\":12}],11:[function(require,module,exports){\n'use strict';\n\nvar Test = require('../test');\n\n/**\n * QUnit-style interface:\n *\n *     suite('Array');\n *\n *     test('#length', function() {\n *       var arr = [1,2,3];\n *       ok(arr.length == 3);\n *     });\n *\n *     test('#indexOf()', function() {\n *       var arr = [1,2,3];\n *       ok(arr.indexOf(1) == 0);\n *       ok(arr.indexOf(2) == 1);\n *       ok(arr.indexOf(3) == 2);\n *     });\n *\n *     suite('String');\n *\n *     test('#length', function() {\n *       ok('foo'.length == 3);\n *     });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function qUnitInterface(suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function(context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`.\n     */\n\n    context.suite = function(title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: false\n      });\n    };\n\n    /**\n     * Exclusive Suite.\n     */\n\n    context.suite.only = function(title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: false\n      });\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.test = function(title, fn) {\n      var test = new Test(title, fn);\n      test.file = file;\n      suites[0].addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function(title, fn) {\n      return common.test.only(mocha, context.test(title, fn));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../test\":35,\"./common\":8}],12:[function(require,module,exports){\n'use strict';\n\nvar Test = require('../test');\n\n/**\n * TDD-style interface:\n *\n *      suite('Array', function() {\n *        suite('#indexOf()', function() {\n *          suiteSetup(function() {\n *\n *          });\n *\n *          test('should return -1 when not present', function() {\n *\n *          });\n *\n *          test('should return the index when present', function() {\n *\n *          });\n *\n *          suiteTeardown(function() {\n *\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function(suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function(context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.setup = common.beforeEach;\n    context.teardown = common.afterEach;\n    context.suiteSetup = common.before;\n    context.suiteTeardown = common.after;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n\n    /**\n     * Describe a \"suite\" with the given `title` and callback `fn` containing\n     * nested suites and/or tests.\n     */\n    context.suite = function(title, fn) {\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Pending suite.\n     */\n    context.suite.skip = function(title, fn) {\n      return common.suite.skip({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n    context.suite.only = function(title, fn) {\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Describe a specification or test-case with the given `title` and\n     * callback `fn` acting as a thunk.\n     */\n    context.test = function(title, fn) {\n      var suite = suites[0];\n      if (suite.isPending()) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function(title, fn) {\n      return common.test.only(mocha, context.test(title, fn));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../test\":35,\"./common\":8}],13:[function(require,module,exports){\n(function (process,global,__dirname){\n'use strict';\n\n/*!\n * mocha\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nvar escapeRe = require('escape-string-regexp');\nvar path = require('path');\nvar reporters = require('./reporters');\nvar utils = require('./utils');\n\nexports = module.exports = Mocha;\n\n/**\n * To require local UIs and reporters when running in node.\n */\n\nif (!process.browser) {\n  var cwd = process.cwd();\n  module.paths.push(cwd, path.join(cwd, 'node_modules'));\n}\n\n/**\n * Expose internals.\n */\n\n/**\n * @public\n * @class utils\n * @memberof Mocha\n */\nexports.utils = utils;\nexports.interfaces = require('./interfaces');\n/**\n *\n * @memberof Mocha\n * @public\n */\nexports.reporters = reporters;\nexports.Runnable = require('./runnable');\nexports.Context = require('./context');\n/**\n *\n * @memberof Mocha\n */\nexports.Runner = require('./runner');\nexports.Suite = require('./suite');\nexports.Hook = require('./hook');\nexports.Test = require('./test');\n\n/**\n * Return image `name` path.\n *\n * @private\n * @param {string} name\n * @return {string}\n */\nfunction image(name) {\n  return path.join(__dirname, '..', 'assets', 'growl', name + '.png');\n}\n\n/**\n * Set up mocha with `options`.\n *\n * Options:\n *\n *   - `ui` name \"bdd\", \"tdd\", \"exports\" etc\n *   - `reporter` reporter instance, defaults to `mocha.reporters.spec`\n *   - `globals` array of accepted globals\n *   - `timeout` timeout in milliseconds\n *   - `retries` number of times to retry failed tests\n *   - `bail` bail on the first test failure\n *   - `slow` milliseconds to wait before considering a test slow\n *   - `ignoreLeaks` ignore global leaks\n *   - `fullTrace` display the full stack-trace on failing\n *   - `grep` string or regexp to filter tests with\n *\n * @class Mocha\n * @param {Object} options\n */\nfunction Mocha(options) {\n  options = options || {};\n  this.files = [];\n  this.options = options;\n  if (options.grep) {\n    this.grep(new RegExp(options.grep));\n  }\n  if (options.fgrep) {\n    this.fgrep(options.fgrep);\n  }\n  this.suite = new exports.Suite('', new exports.Context());\n  this.ui(options.ui);\n  this.bail(options.bail);\n  this.reporter(options.reporter, options.reporterOptions);\n  if (typeof options.timeout !== 'undefined' && options.timeout !== null) {\n    this.timeout(options.timeout);\n  }\n  if (typeof options.retries !== 'undefined' && options.retries !== null) {\n    this.retries(options.retries);\n  }\n  this.useColors(options.useColors);\n  if (options.enableTimeouts !== null) {\n    this.enableTimeouts(options.enableTimeouts);\n  }\n  if (options.slow) {\n    this.slow(options.slow);\n  }\n}\n\n/**\n * Enable or disable bailing on the first failure.\n *\n * @public\n * @api public\n * @param {boolean} [bail]\n */\nMocha.prototype.bail = function(bail) {\n  if (!arguments.length) {\n    bail = true;\n  }\n  this.suite.bail(bail);\n  return this;\n};\n\n/**\n * Add test `file`.\n *\n * @public\n * @api public\n * @param {string} file\n */\nMocha.prototype.addFile = function(file) {\n  this.files.push(file);\n  return this;\n};\n\n/**\n * Set reporter to `reporter`, defaults to \"spec\".\n *\n * @public\n * @param {String|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n * @api public\n * @param {string|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n */\nMocha.prototype.reporter = function(reporter, reporterOptions) {\n  if (typeof reporter === 'function') {\n    this._reporter = reporter;\n  } else {\n    reporter = reporter || 'spec';\n    var _reporter;\n    // Try to load a built-in reporter.\n    if (reporters[reporter]) {\n      _reporter = reporters[reporter];\n    }\n    // Try to load reporters from process.cwd() and node_modules\n    if (!_reporter) {\n      try {\n        _reporter = require(reporter);\n      } catch (err) {\n        if (err.message.indexOf('Cannot find module') !== -1) {\n          // Try to load reporters from a path (absolute or relative)\n          try {\n            _reporter = require(path.resolve(process.cwd(), reporter));\n          } catch (_err) {\n            err.message.indexOf('Cannot find module') !== -1\n              ? console.warn('\"' + reporter + '\" reporter not found')\n              : console.warn(\n                  '\"' +\n                    reporter +\n                    '\" reporter blew up with error:\\n' +\n                    err.stack\n                );\n          }\n        } else {\n          console.warn(\n            '\"' + reporter + '\" reporter blew up with error:\\n' + err.stack\n          );\n        }\n      }\n    }\n    if (!_reporter && reporter === 'teamcity') {\n      console.warn(\n        'The Teamcity reporter was moved to a package named ' +\n          'mocha-teamcity-reporter ' +\n          '(https://npmjs.org/package/mocha-teamcity-reporter).'\n      );\n    }\n    if (!_reporter) {\n      throw new Error('invalid reporter \"' + reporter + '\"');\n    }\n    this._reporter = _reporter;\n  }\n  this.options.reporterOptions = reporterOptions;\n  return this;\n};\n\n/**\n * Set test UI `name`, defaults to \"bdd\".\n * @public\n * @api public\n * @param {string} bdd\n */\nMocha.prototype.ui = function(name) {\n  name = name || 'bdd';\n  this._ui = exports.interfaces[name];\n  if (!this._ui) {\n    try {\n      this._ui = require(name);\n    } catch (err) {\n      throw new Error('invalid interface \"' + name + '\"');\n    }\n  }\n  this._ui = this._ui(this.suite);\n\n  this.suite.on('pre-require', function(context) {\n    exports.afterEach = context.afterEach || context.teardown;\n    exports.after = context.after || context.suiteTeardown;\n    exports.beforeEach = context.beforeEach || context.setup;\n    exports.before = context.before || context.suiteSetup;\n    exports.describe = context.describe || context.suite;\n    exports.it = context.it || context.test;\n    exports.xit = context.xit || context.test.skip;\n    exports.setup = context.setup || context.beforeEach;\n    exports.suiteSetup = context.suiteSetup || context.before;\n    exports.suiteTeardown = context.suiteTeardown || context.after;\n    exports.suite = context.suite || context.describe;\n    exports.teardown = context.teardown || context.afterEach;\n    exports.test = context.test || context.it;\n    exports.run = context.run;\n  });\n\n  return this;\n};\n\n/**\n * Load registered files.\n *\n * @api private\n */\nMocha.prototype.loadFiles = function(fn) {\n  var self = this;\n  var suite = this.suite;\n  this.files.forEach(function(file) {\n    file = path.resolve(file);\n    suite.emit('pre-require', global, file, self);\n    suite.emit('require', require(file), file, self);\n    suite.emit('post-require', global, file, self);\n  });\n  fn && fn();\n};\n\n/**\n * Enable growl support.\n *\n * @api private\n */\nMocha.prototype._growl = function(runner, reporter) {\n  var notify = require('growl');\n\n  runner.on('end', function() {\n    var stats = reporter.stats;\n    if (stats.failures) {\n      var msg = stats.failures + ' of ' + runner.total + ' tests failed';\n      notify(msg, {name: 'mocha', title: 'Failed', image: image('error')});\n    } else {\n      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {\n        name: 'mocha',\n        title: 'Passed',\n        image: image('ok')\n      });\n    }\n  });\n};\n\n/**\n * Escape string and add it to grep as a regexp.\n *\n * @public\n * @api public\n * @param str\n * @returns {Mocha}\n */\nMocha.prototype.fgrep = function(str) {\n  return this.grep(new RegExp(escapeRe(str)));\n};\n\n/**\n * Add regexp to grep, if `re` is a string it is escaped.\n *\n * @public\n * @param {RegExp|String} re\n * @return {Mocha}\n * @api public\n * @param {RegExp|string} re\n * @return {Mocha}\n */\nMocha.prototype.grep = function(re) {\n  if (utils.isString(re)) {\n    // extract args if it's regex-like, i.e: [string, pattern, flag]\n    var arg = re.match(/^\\/(.*)\\/(g|i|)$|.*/);\n    this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);\n  } else {\n    this.options.grep = re;\n  }\n  return this;\n};\n/**\n * Invert `.grep()` matches.\n *\n * @public\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.invert = function() {\n  this.options.invert = true;\n  return this;\n};\n\n/**\n * Ignore global leaks.\n *\n * @public\n * @param {Boolean} ignore\n * @return {Mocha}\n * @api public\n * @param {boolean} ignore\n * @return {Mocha}\n */\nMocha.prototype.ignoreLeaks = function(ignore) {\n  this.options.ignoreLeaks = Boolean(ignore);\n  return this;\n};\n\n/**\n * Enable global leak checking.\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.checkLeaks = function() {\n  this.options.ignoreLeaks = false;\n  return this;\n};\n\n/**\n * Display long stack-trace on failing\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.fullTrace = function() {\n  this.options.fullStackTrace = true;\n  return this;\n};\n\n/**\n * Enable growl support.\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.growl = function() {\n  this.options.growl = true;\n  return this;\n};\n\n/**\n * Ignore `globals` array or string.\n *\n * @param {Array|String} globals\n * @return {Mocha}\n * @api public\n * @public\n * @param {Array|string} globals\n * @return {Mocha}\n */\nMocha.prototype.globals = function(globals) {\n  this.options.globals = (this.options.globals || []).concat(globals);\n  return this;\n};\n\n/**\n * Emit color output.\n *\n * @param {Boolean} colors\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} colors\n * @return {Mocha}\n */\nMocha.prototype.useColors = function(colors) {\n  if (colors !== undefined) {\n    this.options.useColors = colors;\n  }\n  return this;\n};\n\n/**\n * Use inline diffs rather than +/-.\n *\n * @param {Boolean} inlineDiffs\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} inlineDiffs\n * @return {Mocha}\n */\nMocha.prototype.useInlineDiffs = function(inlineDiffs) {\n  this.options.useInlineDiffs = inlineDiffs !== undefined && inlineDiffs;\n  return this;\n};\n\n/**\n * Do not show diffs at all.\n *\n * @param {Boolean} hideDiff\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} hideDiff\n * @return {Mocha}\n */\nMocha.prototype.hideDiff = function(hideDiff) {\n  this.options.hideDiff = hideDiff !== undefined && hideDiff;\n  return this;\n};\n\n/**\n * Set the timeout in milliseconds.\n *\n * @param {Number} timeout\n * @return {Mocha}\n * @api public\n * @public\n * @param {number} timeout\n * @return {Mocha}\n */\nMocha.prototype.timeout = function(timeout) {\n  this.suite.timeout(timeout);\n  return this;\n};\n\n/**\n * Set the number of times to retry failed tests.\n *\n * @param {Number} retry times\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.retries = function(n) {\n  this.suite.retries(n);\n  return this;\n};\n\n/**\n * Set slowness threshold in milliseconds.\n *\n * @param {Number} slow\n * @return {Mocha}\n * @api public\n * @public\n * @param {number} slow\n * @return {Mocha}\n */\nMocha.prototype.slow = function(slow) {\n  this.suite.slow(slow);\n  return this;\n};\n\n/**\n * Enable timeouts.\n *\n * @param {Boolean} enabled\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} enabled\n * @return {Mocha}\n */\nMocha.prototype.enableTimeouts = function(enabled) {\n  this.suite.enableTimeouts(\n    arguments.length && enabled !== undefined ? enabled : true\n  );\n  return this;\n};\n\n/**\n * Makes all tests async (accepting a callback)\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.asyncOnly = function() {\n  this.options.asyncOnly = true;\n  return this;\n};\n\n/**\n * Disable syntax highlighting (in browser).\n *\n * @api public\n * @public\n */\nMocha.prototype.noHighlighting = function() {\n  this.options.noHighlighting = true;\n  return this;\n};\n\n/**\n * Enable uncaught errors to propagate (in browser).\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.allowUncaught = function() {\n  this.options.allowUncaught = true;\n  return this;\n};\n\n/**\n * Delay root suite execution.\n * @returns {Mocha}\n */\nMocha.prototype.delay = function delay() {\n  this.options.delay = true;\n  return this;\n};\n\n/**\n * Tests marked only fail the suite\n * @returns {Mocha}\n */\nMocha.prototype.forbidOnly = function() {\n  this.options.forbidOnly = true;\n  return this;\n};\n\n/**\n * Pending tests and tests marked skip fail the suite\n * @returns {Mocha}\n */\nMocha.prototype.forbidPending = function() {\n  this.options.forbidPending = true;\n  return this;\n};\n\n/**\n * Run tests and invoke `fn()` when complete.\n *\n * Note that `loadFiles` relies on Node's `require` to execute\n * the test interface functions and will be subject to the\n * cache - if the files are already in the `require` cache,\n * they will effectively be skipped. Therefore, to run tests\n * multiple times or to run tests in files that are already\n * in the `require` cache, make sure to clear them from the\n * cache first in whichever manner best suits your needs.\n *\n * @api public\n * @public\n * @param {Function} fn\n * @return {Runner}\n */\nMocha.prototype.run = function(fn) {\n  if (this.files.length) {\n    this.loadFiles();\n  }\n  var suite = this.suite;\n  var options = this.options;\n  options.files = this.files;\n  var runner = new exports.Runner(suite, options.delay);\n  var reporter = new this._reporter(runner, options);\n  runner.ignoreLeaks = options.ignoreLeaks !== false;\n  runner.fullStackTrace = options.fullStackTrace;\n  runner.asyncOnly = options.asyncOnly;\n  runner.allowUncaught = options.allowUncaught;\n  runner.forbidOnly = options.forbidOnly;\n  runner.forbidPending = options.forbidPending;\n  if (options.grep) {\n    runner.grep(options.grep, options.invert);\n  }\n  if (options.globals) {\n    runner.globals(options.globals);\n  }\n  if (options.growl) {\n    this._growl(runner, reporter);\n  }\n  if (options.useColors !== undefined) {\n    exports.reporters.Base.useColors = options.useColors;\n  }\n  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;\n  exports.reporters.Base.hideDiff = options.hideDiff;\n\n  function done(failures) {\n    if (reporter.done) {\n      reporter.done(failures, fn);\n    } else {\n      fn && fn(failures);\n    }\n  }\n\n  return runner.run(done);\n};\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},\"/lib\")\n},{\"./context\":5,\"./hook\":6,\"./interfaces\":10,\"./reporters\":20,\"./runnable\":32,\"./runner\":33,\"./suite\":34,\"./test\":35,\"./utils\":36,\"_process\":56,\"escape-string-regexp\":46,\"growl\":2,\"path\":40}],14:[function(require,module,exports){\n'use strict';\n/**\n * @module milliseconds\n */\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * @memberof Mocha\n * @public\n * @api public\n * @param {string|number} val\n * @return {string|number}\n */\nmodule.exports = function(val) {\n  if (typeof val === 'string') {\n    return parse(val);\n  }\n  return format(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @api private\n * @param {string} str\n * @return {number}\n */\nfunction parse(str) {\n  var match = /^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n    default:\n    // No default case\n  }\n}\n\n/**\n * Format for `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {string}\n */\nfunction format(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n},{}],15:[function(require,module,exports){\n'use strict';\n\nmodule.exports = Pending;\n\n/**\n * Initialize a new `Pending` error with the given message.\n *\n * @param {string} message\n */\nfunction Pending(message) {\n  this.message = message;\n}\n\n},{}],16:[function(require,module,exports){\n(function (process,global){\n'use strict';\n/**\n * @module Base\n */\n/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar diff = require('diff');\nvar ms = require('../ms');\nvar utils = require('../utils');\nvar supportsColor = process.browser ? null : require('supports-color');\n\n/**\n * Expose `Base`.\n */\n\nexports = module.exports = Base;\n\n/**\n * Save timer references to avoid Sinon interfering.\n * See: https://github.com/mochajs/mocha/issues/237\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Check if both stdio streams are associated with a tty.\n */\n\nvar isatty = tty.isatty(1) && tty.isatty(2);\n\n/**\n * Enable coloring by default, except in the browser interface.\n */\n\nexports.useColors =\n  !process.browser &&\n  (supportsColor.stdout || process.env.MOCHA_COLORS !== undefined);\n\n/**\n * Inline diffs instead of +/-\n */\n\nexports.inlineDiffs = false;\n\n/**\n * Default color map.\n */\n\nexports.colors = {\n  pass: 90,\n  fail: 31,\n  'bright pass': 92,\n  'bright fail': 91,\n  'bright yellow': 93,\n  pending: 36,\n  suite: 0,\n  'error title': 0,\n  'error message': 31,\n  'error stack': 90,\n  checkmark: 32,\n  fast: 90,\n  medium: 33,\n  slow: 31,\n  green: 32,\n  light: 90,\n  'diff gutter': 90,\n  'diff added': 32,\n  'diff removed': 31\n};\n\n/**\n * Default symbol map.\n */\n\nexports.symbols = {\n  ok: '✓',\n  err: '✖',\n  dot: '․',\n  comma: ',',\n  bang: '!'\n};\n\n// With node.js on Windows: use symbols available in terminal default fonts\nif (process.platform === 'win32') {\n  exports.symbols.ok = '\\u221A';\n  exports.symbols.err = '\\u00D7';\n  exports.symbols.dot = '.';\n}\n\n/**\n * Color `str` with the given `type`,\n * allowing colors to be disabled,\n * as well as user-defined color\n * schemes.\n *\n * @param {string} type\n * @param {string} str\n * @return {string}\n * @api private\n */\nvar color = (exports.color = function(type, str) {\n  if (!exports.useColors) {\n    return String(str);\n  }\n  return '\\u001b[' + exports.colors[type] + 'm' + str + '\\u001b[0m';\n});\n\n/**\n * Expose term window size, with some defaults for when stderr is not a tty.\n */\n\nexports.window = {\n  width: 75\n};\n\nif (isatty) {\n  exports.window.width = process.stdout.getWindowSize\n    ? process.stdout.getWindowSize(1)[0]\n    : tty.getWindowSize()[1];\n}\n\n/**\n * Expose some basic cursor interactions that are common among reporters.\n */\n\nexports.cursor = {\n  hide: function() {\n    isatty && process.stdout.write('\\u001b[?25l');\n  },\n\n  show: function() {\n    isatty && process.stdout.write('\\u001b[?25h');\n  },\n\n  deleteLine: function() {\n    isatty && process.stdout.write('\\u001b[2K');\n  },\n\n  beginningOfLine: function() {\n    isatty && process.stdout.write('\\u001b[0G');\n  },\n\n  CR: function() {\n    if (isatty) {\n      exports.cursor.deleteLine();\n      exports.cursor.beginningOfLine();\n    } else {\n      process.stdout.write('\\r');\n    }\n  }\n};\n\nfunction showDiff(err) {\n  return (\n    err &&\n    err.showDiff !== false &&\n    sameType(err.actual, err.expected) &&\n    err.expected !== undefined\n  );\n}\n\nfunction stringifyDiffObjs(err) {\n  if (!utils.isString(err.actual) || !utils.isString(err.expected)) {\n    err.actual = utils.stringify(err.actual);\n    err.expected = utils.stringify(err.expected);\n  }\n}\n\n/**\n * Returns a diff between 2 strings with coloured ANSI output.\n *\n * The diff will be either inline or unified dependant on the value\n * of `Base.inlineDiff`.\n *\n * @param {string} actual\n * @param {string} expected\n * @return {string} Diff\n */\nvar generateDiff = (exports.generateDiff = function(actual, expected) {\n  return exports.inlineDiffs\n    ? inlineDiff(actual, expected)\n    : unifiedDiff(actual, expected);\n});\n\n/**\n * Output the given `failures` as a list.\n *\n * @public\n * @memberof Mocha.reporters.Base\n * @variation 1\n * @param {Array} failures\n * @api public\n */\n\nexports.list = function(failures) {\n  console.log();\n  failures.forEach(function(test, i) {\n    // format\n    var fmt =\n      color('error title', '  %s) %s:\\n') +\n      color('error message', '     %s') +\n      color('error stack', '\\n%s\\n');\n\n    // msg\n    var msg;\n    var err = test.err;\n    var message;\n    if (err.message && typeof err.message.toString === 'function') {\n      message = err.message + '';\n    } else if (typeof err.inspect === 'function') {\n      message = err.inspect() + '';\n    } else {\n      message = '';\n    }\n    var stack = err.stack || message;\n    var index = message ? stack.indexOf(message) : -1;\n\n    if (index === -1) {\n      msg = message;\n    } else {\n      index += message.length;\n      msg = stack.slice(0, index);\n      // remove msg from stack\n      stack = stack.slice(index + 1);\n    }\n\n    // uncaught\n    if (err.uncaught) {\n      msg = 'Uncaught ' + msg;\n    }\n    // explicitly show diff\n    if (!exports.hideDiff && showDiff(err)) {\n      stringifyDiffObjs(err);\n      fmt =\n        color('error title', '  %s) %s:\\n%s') + color('error stack', '\\n%s\\n');\n      var match = message.match(/^([^:]+): expected/);\n      msg = '\\n      ' + color('error message', match ? match[1] : msg);\n\n      msg += generateDiff(err.actual, err.expected);\n    }\n\n    // indent stack trace\n    stack = stack.replace(/^/gm, '  ');\n\n    // indented test title\n    var testTitle = '';\n    test.titlePath().forEach(function(str, index) {\n      if (index !== 0) {\n        testTitle += '\\n     ';\n      }\n      for (var i = 0; i < index; i++) {\n        testTitle += '  ';\n      }\n      testTitle += str;\n    });\n\n    console.log(fmt, i + 1, testTitle, msg, stack);\n  });\n};\n\n/**\n * Initialize a new `Base` reporter.\n *\n * All other reporters generally\n * inherit from this reporter, providing\n * stats such as test duration, number\n * of tests passed / failed etc.\n *\n * @memberof Mocha.reporters\n * @public\n * @class\n * @param {Runner} runner\n * @api public\n */\n\nfunction Base(runner) {\n  var stats = (this.stats = {\n    suites: 0,\n    tests: 0,\n    passes: 0,\n    pending: 0,\n    failures: 0\n  });\n  var failures = (this.failures = []);\n\n  if (!runner) {\n    return;\n  }\n  this.runner = runner;\n\n  runner.stats = stats;\n\n  runner.on('start', function() {\n    stats.start = new Date();\n  });\n\n  runner.on('suite', function(suite) {\n    stats.suites = stats.suites || 0;\n    suite.root || stats.suites++;\n  });\n\n  runner.on('test end', function() {\n    stats.tests = stats.tests || 0;\n    stats.tests++;\n  });\n\n  runner.on('pass', function(test) {\n    stats.passes = stats.passes || 0;\n\n    if (test.duration > test.slow()) {\n      test.speed = 'slow';\n    } else if (test.duration > test.slow() / 2) {\n      test.speed = 'medium';\n    } else {\n      test.speed = 'fast';\n    }\n\n    stats.passes++;\n  });\n\n  runner.on('fail', function(test, err) {\n    stats.failures = stats.failures || 0;\n    stats.failures++;\n    if (showDiff(err)) {\n      stringifyDiffObjs(err);\n    }\n    test.err = err;\n    failures.push(test);\n  });\n\n  runner.once('end', function() {\n    stats.end = new Date();\n    stats.duration = stats.end - stats.start;\n  });\n\n  runner.on('pending', function() {\n    stats.pending++;\n  });\n}\n\n/**\n * Output common epilogue used by many of\n * the bundled reporters.\n *\n * @memberof Mocha.reporters.Base\n * @public\n * @api public\n */\nBase.prototype.epilogue = function() {\n  var stats = this.stats;\n  var fmt;\n\n  console.log();\n\n  // passes\n  fmt =\n    color('bright pass', ' ') +\n    color('green', ' %d passing') +\n    color('light', ' (%s)');\n\n  console.log(fmt, stats.passes || 0, ms(stats.duration));\n\n  // pending\n  if (stats.pending) {\n    fmt = color('pending', ' ') + color('pending', ' %d pending');\n\n    console.log(fmt, stats.pending);\n  }\n\n  // failures\n  if (stats.failures) {\n    fmt = color('fail', '  %d failing');\n\n    console.log(fmt, stats.failures);\n\n    Base.list(this.failures);\n    console.log();\n  }\n\n  console.log();\n};\n\n/**\n * Pad the given `str` to `len`.\n *\n * @api private\n * @param {string} str\n * @param {string} len\n * @return {string}\n */\nfunction pad(str, len) {\n  str = String(str);\n  return Array(len - str.length + 1).join(' ') + str;\n}\n\n/**\n * Returns an inline diff between 2 strings with coloured ANSI output.\n *\n * @api private\n * @param {String} actual\n * @param {String} expected\n * @return {string} Diff\n */\nfunction inlineDiff(actual, expected) {\n  var msg = errorDiff(actual, expected);\n\n  // linenos\n  var lines = msg.split('\\n');\n  if (lines.length > 4) {\n    var width = String(lines.length).length;\n    msg = lines\n      .map(function(str, i) {\n        return pad(++i, width) + ' |' + ' ' + str;\n      })\n      .join('\\n');\n  }\n\n  // legend\n  msg =\n    '\\n' +\n    color('diff removed', 'actual') +\n    ' ' +\n    color('diff added', 'expected') +\n    '\\n\\n' +\n    msg +\n    '\\n';\n\n  // indent\n  msg = msg.replace(/^/gm, '      ');\n  return msg;\n}\n\n/**\n * Returns a unified diff between two strings with coloured ANSI output.\n *\n * @api private\n * @param {String} actual\n * @param {String} expected\n * @return {string} The diff.\n */\nfunction unifiedDiff(actual, expected) {\n  var indent = '      ';\n  function cleanUp(line) {\n    if (line[0] === '+') {\n      return indent + colorLines('diff added', line);\n    }\n    if (line[0] === '-') {\n      return indent + colorLines('diff removed', line);\n    }\n    if (line.match(/@@/)) {\n      return '--';\n    }\n    if (line.match(/\\\\ No newline/)) {\n      return null;\n    }\n    return indent + line;\n  }\n  function notBlank(line) {\n    return typeof line !== 'undefined' && line !== null;\n  }\n  var msg = diff.createPatch('string', actual, expected);\n  var lines = msg.split('\\n').splice(5);\n  return (\n    '\\n      ' +\n    colorLines('diff added', '+ expected') +\n    ' ' +\n    colorLines('diff removed', '- actual') +\n    '\\n\\n' +\n    lines\n      .map(cleanUp)\n      .filter(notBlank)\n      .join('\\n')\n  );\n}\n\n/**\n * Return a character diff for `err`.\n *\n * @api private\n * @param {String} actual\n * @param {String} expected\n * @return {string} the diff\n */\nfunction errorDiff(actual, expected) {\n  return diff\n    .diffWordsWithSpace(actual, expected)\n    .map(function(str) {\n      if (str.added) {\n        return colorLines('diff added', str.value);\n      }\n      if (str.removed) {\n        return colorLines('diff removed', str.value);\n      }\n      return str.value;\n    })\n    .join('');\n}\n\n/**\n * Color lines for `str`, using the color `name`.\n *\n * @api private\n * @param {string} name\n * @param {string} str\n * @return {string}\n */\nfunction colorLines(name, str) {\n  return str\n    .split('\\n')\n    .map(function(str) {\n      return color(name, str);\n    })\n    .join('\\n');\n}\n\n/**\n * Object#toString reference.\n */\nvar objToString = Object.prototype.toString;\n\n/**\n * Check that a / b have the same type.\n *\n * @api private\n * @param {Object} a\n * @param {Object} b\n * @return {boolean}\n */\nfunction sameType(a, b) {\n  return objToString.call(a) === objToString.call(b);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../ms\":14,\"../utils\":36,\"_process\":56,\"diff\":45,\"supports-color\":40,\"tty\":4}],17:[function(require,module,exports){\n'use strict';\n/**\n * @module Doc\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Expose `Doc`.\n */\n\nexports = module.exports = Doc;\n\n/**\n * Initialize a new `Doc` reporter.\n *\n * @class\n * @memberof Mocha.reporters\n * @extends {Base}\n * @public\n * @param {Runner} runner\n * @api public\n */\nfunction Doc(runner) {\n  Base.call(this, runner);\n\n  var indents = 2;\n\n  function indent() {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('suite', function(suite) {\n    if (suite.root) {\n      return;\n    }\n    ++indents;\n    console.log('%s<section class=\"suite\">', indent());\n    ++indents;\n    console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\n    console.log('%s<dl>', indent());\n  });\n\n  runner.on('suite end', function(suite) {\n    if (suite.root) {\n      return;\n    }\n    console.log('%s</dl>', indent());\n    --indents;\n    console.log('%s</section>', indent());\n    --indents;\n  });\n\n  runner.on('pass', function(test) {\n    console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.body));\n    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\n  });\n\n  runner.on('fail', function(test, err) {\n    console.log(\n      '%s  <dt class=\"error\">%s</dt>',\n      indent(),\n      utils.escape(test.title)\n    );\n    var code = utils.escape(utils.clean(test.body));\n    console.log(\n      '%s  <dd class=\"error\"><pre><code>%s</code></pre></dd>',\n      indent(),\n      code\n    );\n    console.log('%s  <dd class=\"error\">%s</dd>', indent(), utils.escape(err));\n  });\n}\n\n},{\"../utils\":36,\"./base\":16}],18:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Dot\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = Dot;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @public\n * @api public\n * @param {Runner} runner\n */\nfunction Dot(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = (Base.window.width * 0.75) | 0;\n  var n = -1;\n\n  runner.on('start', function() {\n    process.stdout.write('\\n');\n  });\n\n  runner.on('pending', function() {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('pending', Base.symbols.comma));\n  });\n\n  runner.on('pass', function(test) {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    if (test.speed === 'slow') {\n      process.stdout.write(color('bright yellow', Base.symbols.dot));\n    } else {\n      process.stdout.write(color(test.speed, Base.symbols.dot));\n    }\n  });\n\n  runner.on('fail', function() {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('fail', Base.symbols.bang));\n  });\n\n  runner.once('end', function() {\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Dot, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],19:[function(require,module,exports){\n(function (global){\n'use strict';\n\n/* eslint-env browser */\n/**\n * @module HTML\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar Progress = require('../browser/progress');\nvar escapeRe = require('escape-string-regexp');\nvar escape = utils.escape;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `HTML`.\n */\n\nexports = module.exports = HTML;\n\n/**\n * Stats template.\n */\n\nvar statsTemplate =\n  '<ul id=\"mocha-stats\">' +\n  '<li class=\"progress\"><canvas width=\"40\" height=\"40\"></canvas></li>' +\n  '<li class=\"passes\"><a href=\"javascript:void(0);\">passes:</a> <em>0</em></li>' +\n  '<li class=\"failures\"><a href=\"javascript:void(0);\">failures:</a> <em>0</em></li>' +\n  '<li class=\"duration\">duration: <em>0</em>s</li>' +\n  '</ul>';\n\nvar playIcon = '&#x2023;';\n\n/**\n * Initialize a new `HTML` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction HTML(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var stats = this.stats;\n  var stat = fragment(statsTemplate);\n  var items = stat.getElementsByTagName('li');\n  var passes = items[1].getElementsByTagName('em')[0];\n  var passesLink = items[1].getElementsByTagName('a')[0];\n  var failures = items[2].getElementsByTagName('em')[0];\n  var failuresLink = items[2].getElementsByTagName('a')[0];\n  var duration = items[3].getElementsByTagName('em')[0];\n  var canvas = stat.getElementsByTagName('canvas')[0];\n  var report = fragment('<ul id=\"mocha-report\"></ul>');\n  var stack = [report];\n  var progress;\n  var ctx;\n  var root = document.getElementById('mocha');\n\n  if (canvas.getContext) {\n    var ratio = window.devicePixelRatio || 1;\n    canvas.style.width = canvas.width;\n    canvas.style.height = canvas.height;\n    canvas.width *= ratio;\n    canvas.height *= ratio;\n    ctx = canvas.getContext('2d');\n    ctx.scale(ratio, ratio);\n    progress = new Progress();\n  }\n\n  if (!root) {\n    return error('#mocha div missing, add it to your document');\n  }\n\n  // pass toggle\n  on(passesLink, 'click', function(evt) {\n    evt.preventDefault();\n    unhide();\n    var name = /pass/.test(report.className) ? '' : ' pass';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test pass');\n    }\n  });\n\n  // failure toggle\n  on(failuresLink, 'click', function(evt) {\n    evt.preventDefault();\n    unhide();\n    var name = /fail/.test(report.className) ? '' : ' fail';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test fail');\n    }\n  });\n\n  root.appendChild(stat);\n  root.appendChild(report);\n\n  if (progress) {\n    progress.size(40);\n  }\n\n  runner.on('suite', function(suite) {\n    if (suite.root) {\n      return;\n    }\n\n    // suite\n    var url = self.suiteURL(suite);\n    var el = fragment(\n      '<li class=\"suite\"><h1><a href=\"%s\">%s</a></h1></li>',\n      url,\n      escape(suite.title)\n    );\n\n    // container\n    stack[0].appendChild(el);\n    stack.unshift(document.createElement('ul'));\n    el.appendChild(stack[0]);\n  });\n\n  runner.on('suite end', function(suite) {\n    if (suite.root) {\n      updateStats();\n      return;\n    }\n    stack.shift();\n  });\n\n  runner.on('pass', function(test) {\n    var url = self.testURL(test);\n    var markup =\n      '<li class=\"test pass %e\"><h2>%e<span class=\"duration\">%ems</span> ' +\n      '<a href=\"%s\" class=\"replay\">' +\n      playIcon +\n      '</a></h2></li>';\n    var el = fragment(markup, test.speed, test.title, test.duration, url);\n    self.addCodeToggle(el, test.body);\n    appendToStack(el);\n    updateStats();\n  });\n\n  runner.on('fail', function(test) {\n    var el = fragment(\n      '<li class=\"test fail\"><h2>%e <a href=\"%e\" class=\"replay\">' +\n        playIcon +\n        '</a></h2></li>',\n      test.title,\n      self.testURL(test)\n    );\n    var stackString; // Note: Includes leading newline\n    var message = test.err.toString();\n\n    // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\n    // check for the result of the stringifying.\n    if (message === '[object Error]') {\n      message = test.err.message;\n    }\n\n    if (test.err.stack) {\n      var indexOfMessage = test.err.stack.indexOf(test.err.message);\n      if (indexOfMessage === -1) {\n        stackString = test.err.stack;\n      } else {\n        stackString = test.err.stack.substr(\n          test.err.message.length + indexOfMessage\n        );\n      }\n    } else if (test.err.sourceURL && test.err.line !== undefined) {\n      // Safari doesn't give you a stack. Let's at least provide a source line.\n      stackString = '\\n(' + test.err.sourceURL + ':' + test.err.line + ')';\n    }\n\n    stackString = stackString || '';\n\n    if (test.err.htmlMessage && stackString) {\n      el.appendChild(\n        fragment(\n          '<div class=\"html-error\">%s\\n<pre class=\"error\">%e</pre></div>',\n          test.err.htmlMessage,\n          stackString\n        )\n      );\n    } else if (test.err.htmlMessage) {\n      el.appendChild(\n        fragment('<div class=\"html-error\">%s</div>', test.err.htmlMessage)\n      );\n    } else {\n      el.appendChild(\n        fragment('<pre class=\"error\">%e%e</pre>', message, stackString)\n      );\n    }\n\n    self.addCodeToggle(el, test.body);\n    appendToStack(el);\n    updateStats();\n  });\n\n  runner.on('pending', function(test) {\n    var el = fragment(\n      '<li class=\"test pass pending\"><h2>%e</h2></li>',\n      test.title\n    );\n    appendToStack(el);\n    updateStats();\n  });\n\n  function appendToStack(el) {\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\n    if (stack[0]) {\n      stack[0].appendChild(el);\n    }\n  }\n\n  function updateStats() {\n    // TODO: add to stats\n    var percent = (stats.tests / runner.total * 100) | 0;\n    if (progress) {\n      progress.update(percent).draw(ctx);\n    }\n\n    // update stats\n    var ms = new Date() - stats.start;\n    text(passes, stats.passes);\n    text(failures, stats.failures);\n    text(duration, (ms / 1000).toFixed(2));\n  }\n}\n\n/**\n * Makes a URL, preserving querystring (\"search\") parameters.\n *\n * @param {string} s\n * @return {string} A new URL.\n */\nfunction makeUrl(s) {\n  var search = window.location.search;\n\n  // Remove previous grep query parameter if present\n  if (search) {\n    search = search.replace(/[?&]grep=[^&\\s]*/g, '').replace(/^&/, '?');\n  }\n\n  return (\n    window.location.pathname +\n    (search ? search + '&' : '?') +\n    'grep=' +\n    encodeURIComponent(escapeRe(s))\n  );\n}\n\n/**\n * Provide suite URL.\n *\n * @param {Object} [suite]\n */\nHTML.prototype.suiteURL = function(suite) {\n  return makeUrl(suite.fullTitle());\n};\n\n/**\n * Provide test URL.\n *\n * @param {Object} [test]\n */\nHTML.prototype.testURL = function(test) {\n  return makeUrl(test.fullTitle());\n};\n\n/**\n * Adds code toggle functionality for the provided test's list element.\n *\n * @param {HTMLLIElement} el\n * @param {string} contents\n */\nHTML.prototype.addCodeToggle = function(el, contents) {\n  var h2 = el.getElementsByTagName('h2')[0];\n\n  on(h2, 'click', function() {\n    pre.style.display = pre.style.display === 'none' ? 'block' : 'none';\n  });\n\n  var pre = fragment('<pre><code>%e</code></pre>', utils.clean(contents));\n  el.appendChild(pre);\n  pre.style.display = 'none';\n};\n\n/**\n * Display error `msg`.\n *\n * @param {string} msg\n */\nfunction error(msg) {\n  document.body.appendChild(fragment('<div id=\"mocha-error\">%s</div>', msg));\n}\n\n/**\n * Return a DOM fragment from `html`.\n *\n * @param {string} html\n */\nfunction fragment(html) {\n  var args = arguments;\n  var div = document.createElement('div');\n  var i = 1;\n\n  div.innerHTML = html.replace(/%([se])/g, function(_, type) {\n    switch (type) {\n      case 's':\n        return String(args[i++]);\n      case 'e':\n        return escape(args[i++]);\n      // no default\n    }\n  });\n\n  return div.firstChild;\n}\n\n/**\n * Check for suites that do not have elements\n * with `classname`, and hide them.\n *\n * @param {text} classname\n */\nfunction hideSuitesWithout(classname) {\n  var suites = document.getElementsByClassName('suite');\n  for (var i = 0; i < suites.length; i++) {\n    var els = suites[i].getElementsByClassName(classname);\n    if (!els.length) {\n      suites[i].className += ' hidden';\n    }\n  }\n}\n\n/**\n * Unhide .hidden suites.\n */\nfunction unhide() {\n  var els = document.getElementsByClassName('suite hidden');\n  for (var i = 0; i < els.length; ++i) {\n    els[i].className = els[i].className.replace('suite hidden', 'suite');\n  }\n}\n\n/**\n * Set an element's text contents.\n *\n * @param {HTMLElement} el\n * @param {string} contents\n */\nfunction text(el, contents) {\n  if (el.textContent) {\n    el.textContent = contents;\n  } else {\n    el.innerText = contents;\n  }\n}\n\n/**\n * Listen on `event` with callback `fn`.\n */\nfunction on(el, event, fn) {\n  if (el.addEventListener) {\n    el.addEventListener(event, fn, false);\n  } else {\n    el.attachEvent('on' + event, fn);\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../browser/progress\":3,\"../utils\":36,\"./base\":16,\"escape-string-regexp\":46}],20:[function(require,module,exports){\n'use strict';\n\n// Alias exports to a their normalized format Mocha#reporter to prevent a need\n// for dynamic (try/catch) requires, which Browserify doesn't handle.\nexports.Base = exports.base = require('./base');\nexports.Dot = exports.dot = require('./dot');\nexports.Doc = exports.doc = require('./doc');\nexports.TAP = exports.tap = require('./tap');\nexports.JSON = exports.json = require('./json');\nexports.HTML = exports.html = require('./html');\nexports.List = exports.list = require('./list');\nexports.Min = exports.min = require('./min');\nexports.Spec = exports.spec = require('./spec');\nexports.Nyan = exports.nyan = require('./nyan');\nexports.XUnit = exports.xunit = require('./xunit');\nexports.Markdown = exports.markdown = require('./markdown');\nexports.Progress = exports.progress = require('./progress');\nexports.Landing = exports.landing = require('./landing');\nexports.JSONStream = exports['json-stream'] = require('./json-stream');\n\n},{\"./base\":16,\"./doc\":17,\"./dot\":18,\"./html\":19,\"./json\":22,\"./json-stream\":21,\"./landing\":23,\"./list\":24,\"./markdown\":25,\"./min\":26,\"./nyan\":27,\"./progress\":28,\"./spec\":29,\"./tap\":30,\"./xunit\":31}],21:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module JSONStream\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `JSONStream` test reporter.\n *\n * @public\n * @name JSONStream\n * @class JSONStream\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction List(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var total = runner.total;\n\n  runner.on('start', function() {\n    console.log(JSON.stringify(['start', {total: total}]));\n  });\n\n  runner.on('pass', function(test) {\n    console.log(JSON.stringify(['pass', clean(test)]));\n  });\n\n  runner.on('fail', function(test, err) {\n    test = clean(test);\n    test.err = err.message;\n    test.stack = err.stack || null;\n    console.log(JSON.stringify(['fail', test]));\n  });\n\n  runner.once('end', function() {\n    process.stdout.write(JSON.stringify(['end', self.stats]));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean(test) {\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry()\n  };\n}\n\n}).call(this,require('_process'))\n},{\"./base\":16,\"_process\":56}],22:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module JSON\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `JSON`.\n */\n\nexports = module.exports = JSONReporter;\n\n/**\n * Initialize a new `JSON` reporter.\n *\n * @public\n * @class JSON\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction JSONReporter(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var tests = [];\n  var pending = [];\n  var failures = [];\n  var passes = [];\n\n  runner.on('test end', function(test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test) {\n    passes.push(test);\n  });\n\n  runner.on('fail', function(test) {\n    failures.push(test);\n  });\n\n  runner.on('pending', function(test) {\n    pending.push(test);\n  });\n\n  runner.once('end', function() {\n    var obj = {\n      stats: self.stats,\n      tests: tests.map(clean),\n      pending: pending.map(clean),\n      failures: failures.map(clean),\n      passes: passes.map(clean)\n    };\n\n    runner.testResults = obj;\n\n    process.stdout.write(JSON.stringify(obj, null, 2));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean(test) {\n  var err = test.err || {};\n  if (err instanceof Error) {\n    err = errorJSON(err);\n  }\n\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry(),\n    err: cleanCycles(err)\n  };\n}\n\n/**\n * Replaces any circular references inside `obj` with '[object Object]'\n *\n * @api private\n * @param {Object} obj\n * @return {Object}\n */\nfunction cleanCycles(obj) {\n  var cache = [];\n  return JSON.parse(\n    JSON.stringify(obj, function(key, value) {\n      if (typeof value === 'object' && value !== null) {\n        if (cache.indexOf(value) !== -1) {\n          // Instead of going in a circle, we'll print [object Object]\n          return '' + value;\n        }\n        cache.push(value);\n      }\n\n      return value;\n    })\n  );\n}\n\n/**\n * Transform an Error object into a JSON object.\n *\n * @api private\n * @param {Error} err\n * @return {Object}\n */\nfunction errorJSON(err) {\n  var res = {};\n  Object.getOwnPropertyNames(err).forEach(function(key) {\n    res[key] = err[key];\n  }, err);\n  return res;\n}\n\n}).call(this,require('_process'))\n},{\"./base\":16,\"_process\":56}],23:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Landing\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar cursor = Base.cursor;\nvar color = Base.color;\n\n/**\n * Expose `Landing`.\n */\n\nexports = module.exports = Landing;\n\n/**\n * Airplane color.\n */\n\nBase.colors.plane = 0;\n\n/**\n * Airplane crash color.\n */\n\nBase.colors['plane crash'] = 31;\n\n/**\n * Runway color.\n */\n\nBase.colors.runway = 90;\n\n/**\n * Initialize a new `Landing` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Landing(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = (Base.window.width * 0.75) | 0;\n  var total = runner.total;\n  var stream = process.stdout;\n  var plane = color('plane', '✈');\n  var crashed = -1;\n  var n = 0;\n\n  function runway() {\n    var buf = Array(width).join('-');\n    return '  ' + color('runway', buf);\n  }\n\n  runner.on('start', function() {\n    stream.write('\\n\\n\\n  ');\n    cursor.hide();\n  });\n\n  runner.on('test end', function(test) {\n    // check if the plane crashed\n    var col = crashed === -1 ? (width * ++n / total) | 0 : crashed;\n\n    // show the crash\n    if (test.state === 'failed') {\n      plane = color('plane crash', '✈');\n      crashed = col;\n    }\n\n    // render landing strip\n    stream.write('\\u001b[' + (width + 1) + 'D\\u001b[2A');\n    stream.write(runway());\n    stream.write('\\n  ');\n    stream.write(color('runway', Array(col).join('⋅')));\n    stream.write(plane);\n    stream.write(color('runway', Array(width - col).join('⋅') + '\\n'));\n    stream.write(runway());\n    stream.write('\\u001b[0m');\n  });\n\n  runner.once('end', function() {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Landing, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],24:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module List\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction List(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var n = 0;\n\n  runner.on('start', function() {\n    console.log();\n  });\n\n  runner.on('test', function(test) {\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\n  });\n\n  runner.on('pending', function(test) {\n    var fmt = color('checkmark', '  -') + color('pending', ' %s');\n    console.log(fmt, test.fullTitle());\n  });\n\n  runner.on('pass', function(test) {\n    var fmt =\n      color('checkmark', '  ' + Base.symbols.ok) +\n      color('pass', ' %s: ') +\n      color(test.speed, '%dms');\n    cursor.CR();\n    console.log(fmt, test.fullTitle(), test.duration);\n  });\n\n  runner.on('fail', function(test) {\n    cursor.CR();\n    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());\n  });\n\n  runner.once('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(List, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],25:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Markdown\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Constants\n */\n\nvar SUITE_PREFIX = '$';\n\n/**\n * Expose `Markdown`.\n */\n\nexports = module.exports = Markdown;\n\n/**\n * Initialize a new `Markdown` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Markdown(runner) {\n  Base.call(this, runner);\n\n  var level = 0;\n  var buf = '';\n\n  function title(str) {\n    return Array(level).join('#') + ' ' + str;\n  }\n\n  function mapTOC(suite, obj) {\n    var ret = obj;\n    var key = SUITE_PREFIX + suite.title;\n\n    obj = obj[key] = obj[key] || {suite: suite};\n    suite.suites.forEach(function(suite) {\n      mapTOC(suite, obj);\n    });\n\n    return ret;\n  }\n\n  function stringifyTOC(obj, level) {\n    ++level;\n    var buf = '';\n    var link;\n    for (var key in obj) {\n      if (key === 'suite') {\n        continue;\n      }\n      if (key !== SUITE_PREFIX) {\n        link = ' - [' + key.substring(1) + ']';\n        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\\n';\n        buf += Array(level).join('  ') + link;\n      }\n      buf += stringifyTOC(obj[key], level);\n    }\n    return buf;\n  }\n\n  function generateTOC(suite) {\n    var obj = mapTOC(suite, {});\n    return stringifyTOC(obj, 0);\n  }\n\n  generateTOC(runner.suite);\n\n  runner.on('suite', function(suite) {\n    ++level;\n    var slug = utils.slug(suite.fullTitle());\n    buf += '<a name=\"' + slug + '\"></a>' + '\\n';\n    buf += title(suite.title) + '\\n';\n  });\n\n  runner.on('suite end', function() {\n    --level;\n  });\n\n  runner.on('pass', function(test) {\n    var code = utils.clean(test.body);\n    buf += test.title + '.\\n';\n    buf += '\\n```js\\n';\n    buf += code + '\\n';\n    buf += '```\\n\\n';\n  });\n\n  runner.once('end', function() {\n    process.stdout.write('# TOC\\n');\n    process.stdout.write(generateTOC(runner.suite));\n    process.stdout.write(buf);\n  });\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],26:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Min\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Min`.\n */\n\nexports = module.exports = Min;\n\n/**\n * Initialize a new `Min` minimal test reporter (best used with --watch).\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Min(runner) {\n  Base.call(this, runner);\n\n  runner.on('start', function() {\n    // clear screen\n    process.stdout.write('\\u001b[2J');\n    // set cursor position\n    process.stdout.write('\\u001b[1;3H');\n  });\n\n  runner.once('end', this.epilogue.bind(this));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Min, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],27:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Nyan\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = NyanCat;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @param {Runner} runner\n * @api public\n * @public\n * @class Nyan\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n */\n\nfunction NyanCat(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = (Base.window.width * 0.75) | 0;\n  var nyanCatWidth = (this.nyanCatWidth = 11);\n\n  this.colorIndex = 0;\n  this.numberOfLines = 4;\n  this.rainbowColors = self.generateColors();\n  this.scoreboardWidth = 5;\n  this.tick = 0;\n  this.trajectories = [[], [], [], []];\n  this.trajectoryWidthMax = width - nyanCatWidth;\n\n  runner.on('start', function() {\n    Base.cursor.hide();\n    self.draw();\n  });\n\n  runner.on('pending', function() {\n    self.draw();\n  });\n\n  runner.on('pass', function() {\n    self.draw();\n  });\n\n  runner.on('fail', function() {\n    self.draw();\n  });\n\n  runner.once('end', function() {\n    Base.cursor.show();\n    for (var i = 0; i < self.numberOfLines; i++) {\n      write('\\n');\n    }\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(NyanCat, Base);\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\n\nNyanCat.prototype.draw = function() {\n  this.appendRainbow();\n  this.drawScoreboard();\n  this.drawRainbow();\n  this.drawNyanCat();\n  this.tick = !this.tick;\n};\n\n/**\n * Draw the \"scoreboard\" showing the number\n * of passes, failures and pending tests.\n *\n * @api private\n */\n\nNyanCat.prototype.drawScoreboard = function() {\n  var stats = this.stats;\n\n  function draw(type, n) {\n    write(' ');\n    write(Base.color(type, n));\n    write('\\n');\n  }\n\n  draw('green', stats.passes);\n  draw('fail', stats.failures);\n  draw('pending', stats.pending);\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Append the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.appendRainbow = function() {\n  var segment = this.tick ? '_' : '-';\n  var rainbowified = this.rainbowify(segment);\n\n  for (var index = 0; index < this.numberOfLines; index++) {\n    var trajectory = this.trajectories[index];\n    if (trajectory.length >= this.trajectoryWidthMax) {\n      trajectory.shift();\n    }\n    trajectory.push(rainbowified);\n  }\n};\n\n/**\n * Draw the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.drawRainbow = function() {\n  var self = this;\n\n  this.trajectories.forEach(function(line) {\n    write('\\u001b[' + self.scoreboardWidth + 'C');\n    write(line.join(''));\n    write('\\n');\n  });\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\nNyanCat.prototype.drawNyanCat = function() {\n  var self = this;\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\n  var dist = '\\u001b[' + startWidth + 'C';\n  var padding = '';\n\n  write(dist);\n  write('_,------,');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '  ' : '   ';\n  write('_|' + padding + '/\\\\_/\\\\ ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '_' : '__';\n  var tail = self.tick ? '~' : '^';\n  write(tail + '|' + padding + this.face() + ' ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? ' ' : '  ';\n  write(padding + '\"\"  \"\" ');\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw nyan cat face.\n *\n * @api private\n * @return {string}\n */\n\nNyanCat.prototype.face = function() {\n  var stats = this.stats;\n  if (stats.failures) {\n    return '( x .x)';\n  } else if (stats.pending) {\n    return '( o .o)';\n  } else if (stats.passes) {\n    return '( ^ .^)';\n  }\n  return '( - .-)';\n};\n\n/**\n * Move cursor up `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorUp = function(n) {\n  write('\\u001b[' + n + 'A');\n};\n\n/**\n * Move cursor down `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorDown = function(n) {\n  write('\\u001b[' + n + 'B');\n};\n\n/**\n * Generate rainbow colors.\n *\n * @api private\n * @return {Array}\n */\nNyanCat.prototype.generateColors = function() {\n  var colors = [];\n\n  for (var i = 0; i < 6 * 7; i++) {\n    var pi3 = Math.floor(Math.PI / 3);\n    var n = i * (1.0 / 6);\n    var r = Math.floor(3 * Math.sin(n) + 3);\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\n    colors.push(36 * r + 6 * g + b + 16);\n  }\n\n  return colors;\n};\n\n/**\n * Apply rainbow to the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nNyanCat.prototype.rainbowify = function(str) {\n  if (!Base.useColors) {\n    return str;\n  }\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\n  this.colorIndex += 1;\n  return '\\u001b[38;5;' + color + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Stdout helper.\n *\n * @param {string} string A message to write to stdout.\n */\nfunction write(string) {\n  process.stdout.write(string);\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],28:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Progress\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `Progress`.\n */\n\nexports = module.exports = Progress;\n\n/**\n * General progress bar color.\n */\n\nBase.colors.progress = 90;\n\n/**\n * Initialize a new `Progress` bar test reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n * @param {Object} options\n */\nfunction Progress(runner, options) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = (Base.window.width * 0.5) | 0;\n  var total = runner.total;\n  var complete = 0;\n  var lastN = -1;\n\n  // default chars\n  options = options || {};\n  var reporterOptions = options.reporterOptions || {};\n\n  options.open = reporterOptions.open || '[';\n  options.complete = reporterOptions.complete || '▬';\n  options.incomplete = reporterOptions.incomplete || Base.symbols.dot;\n  options.close = reporterOptions.close || ']';\n  options.verbose = reporterOptions.verbose || false;\n\n  // tests started\n  runner.on('start', function() {\n    console.log();\n    cursor.hide();\n  });\n\n  // tests complete\n  runner.on('test end', function() {\n    complete++;\n\n    var percent = complete / total;\n    var n = (width * percent) | 0;\n    var i = width - n;\n\n    if (n === lastN && !options.verbose) {\n      // Don't re-render the line if it hasn't changed\n      return;\n    }\n    lastN = n;\n\n    cursor.CR();\n    process.stdout.write('\\u001b[J');\n    process.stdout.write(color('progress', '  ' + options.open));\n    process.stdout.write(Array(n).join(options.complete));\n    process.stdout.write(Array(i).join(options.incomplete));\n    process.stdout.write(color('progress', options.close));\n    if (options.verbose) {\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\n    }\n  });\n\n  // tests are complete, output some stats\n  // and the failures if any\n  runner.once('end', function() {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Progress, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],29:[function(require,module,exports){\n'use strict';\n/**\n * @module Spec\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\n\n/**\n * Expose `Spec`.\n */\n\nexports = module.exports = Spec;\n\n/**\n * Initialize a new `Spec` test reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Spec(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var indents = 0;\n  var n = 0;\n\n  function indent() {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('start', function() {\n    console.log();\n  });\n\n  runner.on('suite', function(suite) {\n    ++indents;\n    console.log(color('suite', '%s%s'), indent(), suite.title);\n  });\n\n  runner.on('suite end', function() {\n    --indents;\n    if (indents === 1) {\n      console.log();\n    }\n  });\n\n  runner.on('pending', function(test) {\n    var fmt = indent() + color('pending', '  - %s');\n    console.log(fmt, test.title);\n  });\n\n  runner.on('pass', function(test) {\n    var fmt;\n    if (test.speed === 'fast') {\n      fmt =\n        indent() +\n        color('checkmark', '  ' + Base.symbols.ok) +\n        color('pass', ' %s');\n      console.log(fmt, test.title);\n    } else {\n      fmt =\n        indent() +\n        color('checkmark', '  ' + Base.symbols.ok) +\n        color('pass', ' %s') +\n        color(test.speed, ' (%dms)');\n      console.log(fmt, test.title, test.duration);\n    }\n  });\n\n  runner.on('fail', function(test) {\n    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);\n  });\n\n  runner.once('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Spec, Base);\n\n},{\"../utils\":36,\"./base\":16}],30:[function(require,module,exports){\n'use strict';\n/**\n * @module TAP\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `TAP`.\n */\n\nexports = module.exports = TAP;\n\n/**\n * Initialize a new `TAP` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction TAP(runner) {\n  Base.call(this, runner);\n\n  var n = 1;\n  var passes = 0;\n  var failures = 0;\n\n  runner.on('start', function() {\n    var total = runner.grepTotal(runner.suite);\n    console.log('%d..%d', 1, total);\n  });\n\n  runner.on('test end', function() {\n    ++n;\n  });\n\n  runner.on('pending', function(test) {\n    console.log('ok %d %s # SKIP -', n, title(test));\n  });\n\n  runner.on('pass', function(test) {\n    passes++;\n    console.log('ok %d %s', n, title(test));\n  });\n\n  runner.on('fail', function(test, err) {\n    failures++;\n    console.log('not ok %d %s', n, title(test));\n    if (err.stack) {\n      console.log(err.stack.replace(/^/gm, '  '));\n    }\n  });\n\n  runner.once('end', function() {\n    console.log('# tests ' + (passes + failures));\n    console.log('# pass ' + passes);\n    console.log('# fail ' + failures);\n  });\n}\n\n/**\n * Return a TAP-safe title of `test`\n *\n * @api private\n * @param {Object} test\n * @return {String}\n */\nfunction title(test) {\n  return test.fullTitle().replace(/#/g, '');\n}\n\n},{\"./base\":16}],31:[function(require,module,exports){\n(function (process,global){\n'use strict';\n/**\n * @module XUnit\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar inherits = utils.inherits;\nvar fs = require('fs');\nvar escape = utils.escape;\nvar mkdirp = require('mkdirp');\nvar path = require('path');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `XUnit`.\n */\n\nexports = module.exports = XUnit;\n\n/**\n * Initialize a new `XUnit` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction XUnit(runner, options) {\n  Base.call(this, runner);\n\n  var stats = this.stats;\n  var tests = [];\n  var self = this;\n\n  // the name of the test suite, as it will appear in the resulting XML file\n  var suiteName;\n\n  // the default name of the test suite if none is provided\n  var DEFAULT_SUITE_NAME = 'Mocha Tests';\n\n  if (options && options.reporterOptions) {\n    if (options.reporterOptions.output) {\n      if (!fs.createWriteStream) {\n        throw new Error('file output not supported in browser');\n      }\n\n      mkdirp.sync(path.dirname(options.reporterOptions.output));\n      self.fileStream = fs.createWriteStream(options.reporterOptions.output);\n    }\n\n    // get the suite name from the reporter options (if provided)\n    suiteName = options.reporterOptions.suiteName;\n  }\n\n  // fall back to the default suite name\n  suiteName = suiteName || DEFAULT_SUITE_NAME;\n\n  runner.on('pending', function(test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test) {\n    tests.push(test);\n  });\n\n  runner.on('fail', function(test) {\n    tests.push(test);\n  });\n\n  runner.once('end', function() {\n    self.write(\n      tag(\n        'testsuite',\n        {\n          name: suiteName,\n          tests: stats.tests,\n          failures: stats.failures,\n          errors: stats.failures,\n          skipped: stats.tests - stats.failures - stats.passes,\n          timestamp: new Date().toUTCString(),\n          time: stats.duration / 1000 || 0\n        },\n        false\n      )\n    );\n\n    tests.forEach(function(t) {\n      self.test(t);\n    });\n\n    self.write('</testsuite>');\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(XUnit, Base);\n\n/**\n * Override done to close the stream (if it's a file).\n *\n * @param failures\n * @param {Function} fn\n */\nXUnit.prototype.done = function(failures, fn) {\n  if (this.fileStream) {\n    this.fileStream.end(function() {\n      fn(failures);\n    });\n  } else {\n    fn(failures);\n  }\n};\n\n/**\n * Write out the given line.\n *\n * @param {string} line\n */\nXUnit.prototype.write = function(line) {\n  if (this.fileStream) {\n    this.fileStream.write(line + '\\n');\n  } else if (typeof process === 'object' && process.stdout) {\n    process.stdout.write(line + '\\n');\n  } else {\n    console.log(line);\n  }\n};\n\n/**\n * Output tag for the given `test.`\n *\n * @param {Test} test\n */\nXUnit.prototype.test = function(test) {\n  var attrs = {\n    classname: test.parent.fullTitle(),\n    name: test.title,\n    time: test.duration / 1000 || 0\n  };\n\n  if (test.state === 'failed') {\n    var err = test.err;\n    this.write(\n      tag(\n        'testcase',\n        attrs,\n        false,\n        tag(\n          'failure',\n          {},\n          false,\n          escape(err.message) + '\\n' + escape(err.stack)\n        )\n      )\n    );\n  } else if (test.isPending()) {\n    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));\n  } else {\n    this.write(tag('testcase', attrs, true));\n  }\n};\n\n/**\n * HTML tag helper.\n *\n * @param name\n * @param attrs\n * @param close\n * @param content\n * @return {string}\n */\nfunction tag(name, attrs, close, content) {\n  var end = close ? '/>' : '>';\n  var pairs = [];\n  var tag;\n\n  for (var key in attrs) {\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) {\n      pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\n    }\n  }\n\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\n  if (content) {\n    tag += content + '</' + name + end;\n  }\n  return tag;\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../utils\":36,\"./base\":16,\"_process\":56,\"fs\":40,\"mkdirp\":53,\"path\":40}],32:[function(require,module,exports){\n(function (global){\n'use strict';\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar debug = require('debug')('mocha:runnable');\nvar milliseconds = require('./ms');\nvar utils = require('./utils');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\nvar toString = Object.prototype.toString;\n\nmodule.exports = Runnable;\n\n/**\n * Initialize a new `Runnable` with the given `title` and callback `fn`.  Derived from [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)\n *\n * @class\n * @extends EventEmitter\n * @param {String} title\n * @param {Function} fn\n */\nfunction Runnable(title, fn) {\n  this.title = title;\n  this.fn = fn;\n  this.body = (fn || '').toString();\n  this.async = fn && fn.length;\n  this.sync = !this.async;\n  this._timeout = 2000;\n  this._slow = 75;\n  this._enableTimeouts = true;\n  this.timedOut = false;\n  this._retries = -1;\n  this._currentRetry = 0;\n  this.pending = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\nutils.inherits(Runnable, EventEmitter);\n\n/**\n * Set & get timeout `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.timeout = function(ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  // see #1652 for reasoning\n  if (ms === 0 || ms > Math.pow(2, 31)) {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = ms;\n  if (this.timer) {\n    this.resetTimeout();\n  }\n  return this;\n};\n\n/**\n * Set or get slow `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.slow = function(ms) {\n  if (!arguments.length || typeof ms === 'undefined') {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set and get whether timeout is `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Runnable|boolean} enabled or Runnable instance.\n */\nRunnable.prototype.enableTimeouts = function(enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Halt and mark as pending.\n *\n * @memberof Mocha.Runnable\n * @public\n * @api public\n */\nRunnable.prototype.skip = function() {\n  throw new Pending('sync skip');\n};\n\n/**\n * Check if this runnable or its parent suite is marked as pending.\n *\n * @api private\n */\nRunnable.prototype.isPending = function() {\n  return this.pending || (this.parent && this.parent.isPending());\n};\n\n/**\n * Return `true` if this Runnable has failed.\n * @return {boolean}\n * @private\n */\nRunnable.prototype.isFailed = function() {\n  return !this.isPending() && this.state === 'failed';\n};\n\n/**\n * Return `true` if this Runnable has passed.\n * @return {boolean}\n * @private\n */\nRunnable.prototype.isPassed = function() {\n  return !this.isPending() && this.state === 'passed';\n};\n\n/**\n * Set or get number of retries.\n *\n * @api private\n */\nRunnable.prototype.retries = function(n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  this._retries = n;\n};\n\n/**\n * Set or get current retry\n *\n * @api private\n */\nRunnable.prototype.currentRetry = function(n) {\n  if (!arguments.length) {\n    return this._currentRetry;\n  }\n  this._currentRetry = n;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @memberof Mocha.Runnable\n * @public\n * @api public\n * @return {string}\n */\nRunnable.prototype.fullTitle = function() {\n  return this.titlePath().join(' ');\n};\n\n/**\n * Return the title path generated by concatenating the parent's title path with the title.\n *\n * @memberof Mocha.Runnable\n * @public\n * @api public\n * @return {string}\n */\nRunnable.prototype.titlePath = function() {\n  return this.parent.titlePath().concat([this.title]);\n};\n\n/**\n * Clear the timeout.\n *\n * @api private\n */\nRunnable.prototype.clearTimeout = function() {\n  clearTimeout(this.timer);\n};\n\n/**\n * Inspect the runnable void of private properties.\n *\n * @api private\n * @return {string}\n */\nRunnable.prototype.inspect = function() {\n  return JSON.stringify(\n    this,\n    function(key, val) {\n      if (key[0] === '_') {\n        return;\n      }\n      if (key === 'parent') {\n        return '#<Suite>';\n      }\n      if (key === 'ctx') {\n        return '#<Context>';\n      }\n      return val;\n    },\n    2\n  );\n};\n\n/**\n * Reset the timeout.\n *\n * @api private\n */\nRunnable.prototype.resetTimeout = function() {\n  var self = this;\n  var ms = this.timeout() || 1e9;\n\n  if (!this._enableTimeouts) {\n    return;\n  }\n  this.clearTimeout();\n  this.timer = setTimeout(function() {\n    if (!self._enableTimeouts) {\n      return;\n    }\n    self.callback(self._timeoutError(ms));\n    self.timedOut = true;\n  }, ms);\n};\n\n/**\n * Set or get a list of whitelisted globals for this test run.\n *\n * @api private\n * @param {string[]} globals\n */\nRunnable.prototype.globals = function(globals) {\n  if (!arguments.length) {\n    return this._allowedGlobals;\n  }\n  this._allowedGlobals = globals;\n};\n\n/**\n * Run the test and invoke `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunnable.prototype.run = function(fn) {\n  var self = this;\n  var start = new Date();\n  var ctx = this.ctx;\n  var finished;\n  var emitted;\n\n  // Sometimes the ctx exists, but it is not runnable\n  if (ctx && ctx.runnable) {\n    ctx.runnable(this);\n  }\n\n  // called multiple times\n  function multiple(err) {\n    if (emitted) {\n      return;\n    }\n    emitted = true;\n    var msg = 'done() called multiple times';\n    if (err && err.message) {\n      err.message += \" (and Mocha's \" + msg + ')';\n      self.emit('error', err);\n    } else {\n      self.emit('error', new Error(msg));\n    }\n  }\n\n  // finished\n  function done(err) {\n    var ms = self.timeout();\n    if (self.timedOut) {\n      return;\n    }\n\n    if (finished) {\n      return multiple(err);\n    }\n\n    self.clearTimeout();\n    self.duration = new Date() - start;\n    finished = true;\n    if (!err && self.duration > ms && self._enableTimeouts) {\n      err = self._timeoutError(ms);\n    }\n    fn(err);\n  }\n\n  // for .resetTimeout()\n  this.callback = done;\n\n  // explicit async with `done` argument\n  if (this.async) {\n    this.resetTimeout();\n\n    // allows skip() to be used in an explicit async context\n    this.skip = function asyncSkip() {\n      done(new Pending('async skip call'));\n      // halt execution.  the Runnable will be marked pending\n      // by the previous call, and the uncaught handler will ignore\n      // the failure.\n      throw new Pending('async skip; aborting execution');\n    };\n\n    if (this.allowUncaught) {\n      return callFnAsync(this.fn);\n    }\n    try {\n      callFnAsync(this.fn);\n    } catch (err) {\n      emitted = true;\n      done(utils.getError(err));\n    }\n    return;\n  }\n\n  if (this.allowUncaught) {\n    if (this.isPending()) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n    return;\n  }\n\n  // sync or promise-returning\n  try {\n    if (this.isPending()) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n  } catch (err) {\n    emitted = true;\n    done(utils.getError(err));\n  }\n\n  function callFn(fn) {\n    var result = fn.call(ctx);\n    if (result && typeof result.then === 'function') {\n      self.resetTimeout();\n      result.then(\n        function() {\n          done();\n          // Return null so libraries like bluebird do not warn about\n          // subsequently constructed Promises.\n          return null;\n        },\n        function(reason) {\n          done(reason || new Error('Promise rejected with no or falsy reason'));\n        }\n      );\n    } else {\n      if (self.asyncOnly) {\n        return done(\n          new Error(\n            '--async-only option in use without declaring `done()` or returning a promise'\n          )\n        );\n      }\n\n      done();\n    }\n  }\n\n  function callFnAsync(fn) {\n    var result = fn.call(ctx, function(err) {\n      if (err instanceof Error || toString.call(err) === '[object Error]') {\n        return done(err);\n      }\n      if (err) {\n        if (Object.prototype.toString.call(err) === '[object Object]') {\n          return done(\n            new Error('done() invoked with non-Error: ' + JSON.stringify(err))\n          );\n        }\n        return done(new Error('done() invoked with non-Error: ' + err));\n      }\n      if (result && utils.isPromise(result)) {\n        return done(\n          new Error(\n            'Resolution method is overspecified. Specify a callback *or* return a Promise; not both.'\n          )\n        );\n      }\n\n      done();\n    });\n  }\n};\n\n/**\n * Instantiates a \"timeout\" error\n *\n * @param {number} ms - Timeout (in milliseconds)\n * @returns {Error} a \"timeout\" error\n * @private\n */\nRunnable.prototype._timeoutError = function(ms) {\n  var msg =\n    'Timeout of ' +\n    ms +\n    'ms exceeded. For async tests and hooks, ensure \"done()\" is called; if returning a Promise, ensure it resolves.';\n  if (this.file) {\n    msg += ' (' + this.file + ')';\n  }\n  return new Error(msg);\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./ms\":14,\"./pending\":15,\"./utils\":36,\"debug\":43,\"events\":47}],33:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/**\n * @module Runner\n */\n/**\n * Module dependencies.\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:runner');\nvar Runnable = require('./runnable');\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\nvar type = utils.type;\nvar undefinedError = utils.undefinedError;\n\n/**\n * Non-enumerable globals.\n */\n\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\n/**\n * Expose `Runner`.\n */\n\nmodule.exports = Runner;\n\n/**\n * Initialize a `Runner` for the given `suite`. Derived from [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)\n *\n * Events:\n *\n *   - `start`  execution started\n *   - `end`  execution complete\n *   - `suite`  (suite) test suite execution started\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\n *   - `test`  (test) test execution started\n *   - `test end`  (test) test completed\n *   - `hook`  (hook) hook execution started\n *   - `hook end`  (hook) hook complete\n *   - `pass`  (test) test passed\n *   - `fail`  (test, err) test failed\n *   - `pending`  (test) test pending\n *\n * @memberof Mocha\n * @public\n * @class\n * @api public\n * @param {Suite} [suite] Root suite\n * @param {boolean} [delay] Whether or not to delay execution of root suite\n * until ready.\n */\nfunction Runner(suite, delay) {\n  var self = this;\n  this._globals = [];\n  this._abort = false;\n  this._delay = delay;\n  this.suite = suite;\n  this.started = false;\n  this.total = suite.total();\n  this.failures = 0;\n  this.on('test end', function(test) {\n    self.checkGlobals(test);\n  });\n  this.on('hook end', function(hook) {\n    self.checkGlobals(hook);\n  });\n  this._defaultGrep = /.*/;\n  this.grep(this._defaultGrep);\n  this.globals(this.globalProps().concat(extraGlobals()));\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Runner, EventEmitter);\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @api public\n * @public\n * @memberof Mocha.Runner\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\nRunner.prototype.grep = function(re, invert) {\n  debug('grep %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @memberof Mocha.Runner\n * @api public\n * @public\n * @param {Suite} suite\n * @return {number}\n */\nRunner.prototype.grepTotal = function(suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function(test) {\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (match) {\n      total++;\n    }\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.globalProps = function() {\n  var props = Object.keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~props.indexOf(globals[i])) {\n      continue;\n    }\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @api public\n * @public\n * @memberof Mocha.Runner\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\nRunner.prototype.globals = function(arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n  debug('globals %j', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @api private\n */\nRunner.prototype.checkGlobals = function(test) {\n  if (this.ignoreLeaks) {\n    return;\n  }\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length > 1) {\n    this.fail(\n      test,\n      new Error('global leaks detected: ' + leaks.join(', ') + '')\n    );\n  } else if (leaks.length) {\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * @api private\n * @param {Test} test\n * @param {Error} err\n */\nRunner.prototype.fail = function(test, err) {\n  if (test.isPending()) {\n    return;\n  }\n\n  ++this.failures;\n  test.state = 'failed';\n\n  if (!(err instanceof Error || (err && typeof err.message === 'string'))) {\n    err = new Error(\n      'the ' +\n        type(err) +\n        ' ' +\n        stringify(err) +\n        ' was thrown, throw an Error :)'\n    );\n  }\n\n  try {\n    err.stack =\n      this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);\n  } catch (ignore) {\n    // some environments do not take kindly to monkeying with the stack\n  }\n\n  this.emit('fail', test, err);\n  if (this.suite.bail()) {\n    this.emit('end');\n  }\n};\n\n/**\n * Fail the given `hook` with `err`.\n *\n * Hook failures work in the following pattern:\n * - If bail, then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter\n *   execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @api private\n * @param {Hook} hook\n * @param {Error} err\n */\nRunner.prototype.failHook = function(hook, err) {\n  if (hook.ctx && hook.ctx.currentTest) {\n    hook.originalTitle = hook.originalTitle || hook.title;\n    hook.title =\n      hook.originalTitle + ' for \"' + hook.ctx.currentTest.title + '\"';\n  }\n\n  this.fail(hook, err);\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @api private\n * @param {string} name\n * @param {Function} fn\n */\n\nRunner.prototype.hook = function(name, fn) {\n  var suite = this.suite;\n  var hooks = suite['_' + name];\n  var self = this;\n\n  function next(i) {\n    var hook = hooks[i];\n    if (!hook) {\n      return fn();\n    }\n    self.currentRunnable = hook;\n\n    hook.ctx.currentTest = self.test;\n\n    self.emit('hook', hook);\n\n    if (!hook.listeners('error').length) {\n      hook.on('error', function(err) {\n        self.failHook(hook, err);\n      });\n    }\n\n    hook.run(function(err) {\n      var testError = hook.error();\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n      if (err) {\n        if (err instanceof Pending) {\n          if (name === 'beforeEach' || name === 'afterEach') {\n            self.test.pending = true;\n          } else {\n            suite.tests.forEach(function(test) {\n              test.pending = true;\n            });\n            // a pending hook won't be executed twice.\n            hook.pending = true;\n          }\n        } else {\n          self.failHook(hook, err);\n\n          // stop executing hooks, notify callee of hook err\n          return fn(err);\n        }\n      }\n      self.emit('hook end', hook);\n      delete hook.ctx.currentTest;\n      next(++i);\n    });\n  }\n\n  Runner.immediately(function() {\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @api private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\nRunner.prototype.hooks = function(name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next(suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function(err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run hooks from the top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookUp = function(name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run hooks from the bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookDown = function(name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.parents = function() {\n  var suite = this.suite;\n  var suites = [];\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.runTest = function(fn) {\n  var self = this;\n  var test = this.test;\n\n  if (!test) {\n    return;\n  }\n  if (this.forbidOnly && hasOnly(this.parents().reverse()[0] || this.suite)) {\n    fn(new Error('`.only` forbidden'));\n    return;\n  }\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n  test.on('error', function(err) {\n    self.fail(test, err);\n  });\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n  try {\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runTests = function(suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr(_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      // call hookUp afterEach\n      self.hookUp('afterEach', function(err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        }\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      return fn();\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    }\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) {\n      return fn();\n    }\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep — It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n      return;\n    }\n\n    if (test.isPending()) {\n      if (self.forbidPending) {\n        test.isPending = alwaysFalse;\n        self.fail(test, new Error('Pending test forbidden'));\n        delete test.isPending;\n      } else {\n        self.emit('pending', test);\n      }\n      self.emit('test end', test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit('test', (self.test = test));\n    self.hookDown('beforeEach', function(err, errSuite) {\n      if (test.isPending()) {\n        if (self.forbidPending) {\n          test.isPending = alwaysFalse;\n          self.fail(test, new Error('Pending test forbidden'));\n          delete test.isPending;\n        } else {\n          self.emit('pending', test);\n        }\n        self.emit('test end', test);\n        return next();\n      }\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n      self.currentRunnable = self.test;\n      self.runTest(function(err) {\n        test = self.test;\n        if (err) {\n          var retry = test.currentRetry();\n          if (err instanceof Pending && self.forbidPending) {\n            self.fail(test, new Error('Pending test forbidden'));\n          } else if (err instanceof Pending) {\n            test.pending = true;\n            self.emit('pending', test);\n          } else if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n\n            // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n            return self.hookUp('afterEach', next);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit('test end', test);\n\n          if (err instanceof Pending) {\n            return next();\n          }\n\n          return self.hookUp('afterEach', next);\n        }\n\n        test.state = 'passed';\n        self.emit('pass', test);\n        self.emit('test end', test);\n        self.hookUp('afterEach', next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\nfunction alwaysFalse() {\n  return false;\n}\n\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runSuite = function(suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n  var afterAllHookCalled = false;\n\n  debug('run suite %s', suite.fullTitle());\n\n  if (!total || (self.failures && suite._bail)) {\n    return fn();\n  }\n\n  this.emit('suite', (this.suite = suite));\n\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      }\n      // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n    if (!curr) {\n      return done();\n    }\n\n    // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function() {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done(errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    if (afterAllHookCalled) {\n      fn(errSuite);\n    } else {\n      // mark that the afterAll block has been called once\n      // and so can be skipped if there is an error in it.\n      afterAllHookCalled = true;\n\n      // remove reference to test\n      delete self.test;\n\n      self.hook('afterAll', function() {\n        self.emit('suite end', suite);\n        fn(errSuite);\n      });\n    }\n  }\n\n  this.nextSuite = next;\n\n  this.hook('beforeAll', function(err) {\n    if (err) {\n      return done();\n    }\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions.\n *\n * @param {Error} err\n * @api private\n */\nRunner.prototype.uncaught = function(err) {\n  if (err) {\n    debug(\n      'uncaught exception %s',\n      err ===\n      function() {\n        return this;\n      }.call(err)\n        ? err.message || err\n        : err\n    );\n  } else {\n    debug('uncaught undefined exception');\n    err = undefinedError();\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    runnable.parent = this.suite;\n\n    if (this.started) {\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      this.emit('start');\n      this.fail(runnable, err);\n      this.emit('end');\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  // Ignore errors if already failed or pending\n  // See #3226\n  if (runnable.isFailed() || runnable.isPending()) {\n    return;\n  }\n  // we cannot recover gracefully if a Runnable has already passed\n  // then fails asynchronously\n  var alreadyPassed = runnable.isPassed();\n  // this will change the state to \"failed\" regardless of the current value\n  this.fail(runnable, err);\n  if (!alreadyPassed) {\n    // recover from test\n    if (runnable.type === 'test') {\n      this.emit('test end', runnable);\n      this.hookUp('afterEach', this.next);\n      return;\n    }\n\n    // recover from hooks\n    var errSuite = this.suite;\n    // if hook failure is in afterEach block\n    if (runnable.fullTitle().indexOf('after each') > -1) {\n      return this.hookErr(err, errSuite, true);\n    }\n    // if hook failure is in beforeEach block\n    if (runnable.fullTitle().indexOf('before each') > -1) {\n      return this.hookErr(err, errSuite, false);\n    }\n    // if hook failure is in after or before blocks\n    return this.nextSuite(errSuite);\n  }\n\n  // bail\n  this.emit('end');\n};\n\n/**\n * Cleans up the references to all the deferred functions\n * (before/after/beforeEach/afterEach) and tests of a Suite.\n * These must be deleted otherwise a memory leak can happen,\n * as those functions may reference variables from closures,\n * thus those variables can never be garbage collected as long\n * as the deferred functions exist.\n *\n * @param {Suite} suite\n */\nfunction cleanSuiteReferences(suite) {\n  function cleanArrReferences(arr) {\n    for (var i = 0; i < arr.length; i++) {\n      delete arr[i].fn;\n    }\n  }\n\n  if (Array.isArray(suite._beforeAll)) {\n    cleanArrReferences(suite._beforeAll);\n  }\n\n  if (Array.isArray(suite._beforeEach)) {\n    cleanArrReferences(suite._beforeEach);\n  }\n\n  if (Array.isArray(suite._afterAll)) {\n    cleanArrReferences(suite._afterAll);\n  }\n\n  if (Array.isArray(suite._afterEach)) {\n    cleanArrReferences(suite._afterEach);\n  }\n\n  for (var i = 0; i < suite.tests.length; i++) {\n    delete suite.tests[i].fn;\n  }\n}\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @api public\n * @public\n * @memberof Mocha.Runner\n * @param {Function} fn\n * @return {Runner} Runner instance.\n */\nRunner.prototype.run = function(fn) {\n  var self = this;\n  var rootSuite = this.suite;\n\n  fn = fn || function() {};\n\n  function uncaught(err) {\n    self.uncaught(err);\n  }\n\n  function start() {\n    // If there is an `only` filter\n    if (hasOnly(rootSuite)) {\n      filterOnly(rootSuite);\n    }\n    self.started = true;\n    self.emit('start');\n    self.runSuite(rootSuite, function() {\n      debug('finished running');\n      self.emit('end');\n    });\n  }\n\n  debug('start');\n\n  // references cleanup to avoid memory leaks\n  this.on('suite end', cleanSuiteReferences);\n\n  // callback\n  this.on('end', function() {\n    debug('end');\n    process.removeListener('uncaughtException', uncaught);\n    fn(self.failures);\n  });\n\n  // uncaught exception\n  process.on('uncaughtException', uncaught);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit('waiting', rootSuite);\n    rootSuite.once('run', start);\n  } else {\n    start();\n  }\n\n  return this;\n};\n\n/**\n * Cleanly abort execution.\n *\n * @memberof Mocha.Runner\n * @public\n * @api public\n * @return {Runner} Runner instance.\n */\nRunner.prototype.abort = function() {\n  debug('aborting');\n  this._abort = true;\n\n  return this;\n};\n\n/**\n * Filter suites based on `isOnly` logic.\n *\n * @param {Array} suite\n * @returns {Boolean}\n * @api private\n */\nfunction filterOnly(suite) {\n  if (suite._onlyTests.length) {\n    // If the suite contains `only` tests, run those and ignore any nested suites.\n    suite.tests = suite._onlyTests;\n    suite.suites = [];\n  } else {\n    // Otherwise, do not run any of the tests in this suite.\n    suite.tests = [];\n    suite._onlySuites.forEach(function(onlySuite) {\n      // If there are other `only` tests/suites nested in the current `only` suite, then filter that `only` suite.\n      // Otherwise, all of the tests on this `only` suite should be run, so don't filter it.\n      if (hasOnly(onlySuite)) {\n        filterOnly(onlySuite);\n      }\n    });\n    // Run the `only` suites, as well as any other suites that have `only` tests/suites as descendants.\n    suite.suites = suite.suites.filter(function(childSuite) {\n      return (\n        suite._onlySuites.indexOf(childSuite) !== -1 || filterOnly(childSuite)\n      );\n    });\n  }\n  // Keep the suite only if there is something to run\n  return suite.tests.length || suite.suites.length;\n}\n\n/**\n * Determines whether a suite has an `only` test or suite as a descendant.\n *\n * @param {Array} suite\n * @returns {Boolean}\n * @api private\n */\nfunction hasOnly(suite) {\n  return (\n    suite._onlyTests.length ||\n    suite._onlySuites.length ||\n    suite.suites.some(hasOnly)\n  );\n}\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @api private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\nfunction filterLeaks(ok, globals) {\n  return globals.filter(function(key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^\\d+/.test(key)) {\n      return false;\n    }\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method\n    // not init at first it is assigned in some seconds\n    if (global.navigator && /^getInterface/.test(key)) {\n      return false;\n    }\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && /^\\d+/.test(key)) {\n      return false;\n    }\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = ok.filter(function(ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n\n/**\n * Array of globals dependent on the environment.\n *\n * @return {Array}\n * @api private\n */\nfunction extraGlobals() {\n  if (typeof process === 'object' && typeof process.version === 'string') {\n    var parts = process.version.split('.');\n    var nodeVersion = parts.reduce(function(a, v) {\n      return (a << 8) | v;\n    });\n\n    // 'errno' was renamed to process._errno in v0.9.11.\n\n    if (nodeVersion < 0x00090b) {\n      return ['errno'];\n    }\n  }\n\n  return [];\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./pending\":15,\"./runnable\":32,\"./utils\":36,\"_process\":56,\"debug\":43,\"events\":47}],34:[function(require,module,exports){\n'use strict';\n/**\n * @module Suite\n */\n\n/**\n * Module dependencies.\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Hook = require('./hook');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:suite');\nvar milliseconds = require('./ms');\n\n/**\n * Expose `Suite`.\n */\n\nexports = module.exports = Suite;\n\n/**\n * Create a new `Suite` with the given `title` and parent `Suite`. When a suite\n * with the same title is already present, that suite is returned to provide\n * nicer reporter and more flexible meta-testing.\n *\n * @memberof Mocha\n * @public\n * @api public\n * @param {Suite} parent\n * @param {string} title\n * @return {Suite}\n */\nexports.create = function(parent, title) {\n  var suite = new Suite(title, parent.ctx);\n  suite.parent = parent;\n  title = suite.fullTitle();\n  parent.addSuite(suite);\n  return suite;\n};\n\n/**\n * Initialize a new `Suite` with the given `title` and `ctx`. Derived from [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)\n *\n * @memberof Mocha\n * @public\n * @class\n * @param {string} title\n * @param {Context} parentContext\n */\nfunction Suite(title, parentContext) {\n  if (!utils.isString(title)) {\n    throw new Error(\n      'Suite `title` should be a \"string\" but \"' +\n        typeof title +\n        '\" was given instead.'\n    );\n  }\n  this.title = title;\n  function Context() {}\n  Context.prototype = parentContext;\n  this.ctx = new Context();\n  this.suites = [];\n  this.tests = [];\n  this.pending = false;\n  this._beforeEach = [];\n  this._beforeAll = [];\n  this._afterEach = [];\n  this._afterAll = [];\n  this.root = !title;\n  this._timeout = 2000;\n  this._enableTimeouts = true;\n  this._slow = 75;\n  this._bail = false;\n  this._retries = -1;\n  this._onlyTests = [];\n  this._onlySuites = [];\n  this.delayed = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Suite, EventEmitter);\n\n/**\n * Return a clone of this `Suite`.\n *\n * @api private\n * @return {Suite}\n */\nSuite.prototype.clone = function() {\n  var suite = new Suite(this.title);\n  debug('clone');\n  suite.ctx = this.ctx;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  return suite;\n};\n\n/**\n * Set or get timeout `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.timeout = function(ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  if (ms.toString() === '0') {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = parseInt(ms, 10);\n  return this;\n};\n\n/**\n * Set or get number of times to retry a failed test.\n *\n * @api private\n * @param {number|string} n\n * @return {Suite|number} for chaining\n */\nSuite.prototype.retries = function(n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  debug('retries %d', n);\n  this._retries = parseInt(n, 10) || 0;\n  return this;\n};\n\n/**\n * Set or get timeout to `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Suite|boolean} self or enabled\n */\nSuite.prototype.enableTimeouts = function(enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Set or get slow `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.slow = function(ms) {\n  if (!arguments.length) {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set or get whether to bail after first error.\n *\n * @api private\n * @param {boolean} bail\n * @return {Suite|number} for chaining\n */\nSuite.prototype.bail = function(bail) {\n  if (!arguments.length) {\n    return this._bail;\n  }\n  debug('bail %s', bail);\n  this._bail = bail;\n  return this;\n};\n\n/**\n * Check if this suite or its parent suite is marked as pending.\n *\n * @api private\n */\nSuite.prototype.isPending = function() {\n  return this.pending || (this.parent && this.parent.isPending());\n};\n\n/**\n * Generic hook-creator.\n * @private\n * @param {string} title - Title of hook\n * @param {Function} fn - Hook callback\n * @returns {Hook} A new hook\n */\nSuite.prototype._createHook = function(title, fn) {\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  hook.file = this.file;\n  return hook;\n};\n\n/**\n * Run `fn(test[, done])` before running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeAll = function(title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before all\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._beforeAll.push(hook);\n  this.emit('beforeAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterAll = function(title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after all\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._afterAll.push(hook);\n  this.emit('afterAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` before each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeEach = function(title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before each\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._beforeEach.push(hook);\n  this.emit('beforeEach', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterEach = function(title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after each\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._afterEach.push(hook);\n  this.emit('afterEach', hook);\n  return this;\n};\n\n/**\n * Add a test `suite`.\n *\n * @api private\n * @param {Suite} suite\n * @return {Suite} for chaining\n */\nSuite.prototype.addSuite = function(suite) {\n  suite.parent = this;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  this.suites.push(suite);\n  this.emit('suite', suite);\n  return this;\n};\n\n/**\n * Add a `test` to this suite.\n *\n * @api private\n * @param {Test} test\n * @return {Suite} for chaining\n */\nSuite.prototype.addTest = function(test) {\n  test.parent = this;\n  test.timeout(this.timeout());\n  test.retries(this.retries());\n  test.enableTimeouts(this.enableTimeouts());\n  test.slow(this.slow());\n  test.ctx = this.ctx;\n  this.tests.push(test);\n  this.emit('test', test);\n  return this;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @memberof Mocha.Suite\n * @public\n * @api public\n * @return {string}\n */\nSuite.prototype.fullTitle = function() {\n  return this.titlePath().join(' ');\n};\n\n/**\n * Return the title path generated by recursively concatenating the parent's\n * title path.\n *\n * @memberof Mocha.Suite\n * @public\n * @api public\n * @return {string}\n */\nSuite.prototype.titlePath = function() {\n  var result = [];\n  if (this.parent) {\n    result = result.concat(this.parent.titlePath());\n  }\n  if (!this.root) {\n    result.push(this.title);\n  }\n  return result;\n};\n\n/**\n * Return the total number of tests.\n *\n * @memberof Mocha.Suite\n * @public\n * @api public\n * @return {number}\n */\nSuite.prototype.total = function() {\n  return (\n    this.suites.reduce(function(sum, suite) {\n      return sum + suite.total();\n    }, 0) + this.tests.length\n  );\n};\n\n/**\n * Iterates through each suite recursively to find all tests. Applies a\n * function in the format `fn(test)`.\n *\n * @api private\n * @param {Function} fn\n * @return {Suite}\n */\nSuite.prototype.eachTest = function(fn) {\n  this.tests.forEach(fn);\n  this.suites.forEach(function(suite) {\n    suite.eachTest(fn);\n  });\n  return this;\n};\n\n/**\n * This will run the root suite if we happen to be running in delayed mode.\n */\nSuite.prototype.run = function run() {\n  if (this.root) {\n    this.emit('run');\n  }\n};\n\n},{\"./hook\":6,\"./ms\":14,\"./utils\":36,\"debug\":43,\"events\":47}],35:[function(require,module,exports){\n'use strict';\nvar Runnable = require('./runnable');\nvar utils = require('./utils');\nvar isString = utils.isString;\n\nmodule.exports = Test;\n\n/**\n * Initialize a new `Test` with the given `title` and callback `fn`.\n *\n * @class\n * @extends Runnable\n * @param {String} title\n * @param {Function} fn\n */\nfunction Test(title, fn) {\n  if (!isString(title)) {\n    throw new Error(\n      'Test `title` should be a \"string\" but \"' +\n        typeof title +\n        '\" was given instead.'\n    );\n  }\n  Runnable.call(this, title, fn);\n  this.pending = !fn;\n  this.type = 'test';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\nutils.inherits(Test, Runnable);\n\nTest.prototype.clone = function() {\n  var test = new Test(this.title, this.fn);\n  test.timeout(this.timeout());\n  test.slow(this.slow());\n  test.enableTimeouts(this.enableTimeouts());\n  test.retries(this.retries());\n  test.currentRetry(this.currentRetry());\n  test.globals(this.globals());\n  test.parent = this.parent;\n  test.file = this.file;\n  test.ctx = this.ctx;\n  return test;\n};\n\n},{\"./runnable\":32,\"./utils\":36}],36:[function(require,module,exports){\n(function (process,Buffer){\n'use strict';\n\n/**\n * @module\n */\n\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('mocha:watch');\nvar fs = require('fs');\nvar glob = require('glob');\nvar path = require('path');\nvar join = path.join;\nvar he = require('he');\n\n/**\n * Ignored directories.\n */\n\nvar ignore = ['node_modules', '.git'];\n\nexports.inherits = require('util').inherits;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @api private\n * @param  {string} html\n * @return {string}\n */\nexports.escape = function(html) {\n  return he.encode(String(html), {useNamedReferences: false});\n};\n\n/**\n * Test if the given obj is type of string.\n *\n * @api private\n * @param {Object} obj\n * @return {boolean}\n */\nexports.isString = function(obj) {\n  return typeof obj === 'string';\n};\n\n/**\n * Watch the given `files` for changes\n * and invoke `fn(file)` on modification.\n *\n * @api private\n * @param {Array} files\n * @param {Function} fn\n */\nexports.watch = function(files, fn) {\n  var options = {interval: 100};\n  files.forEach(function(file) {\n    debug('file %s', file);\n    fs.watchFile(file, options, function(curr, prev) {\n      if (prev.mtime < curr.mtime) {\n        fn(file);\n      }\n    });\n  });\n};\n\n/**\n * Ignored files.\n *\n * @api private\n * @param {string} path\n * @return {boolean}\n */\nfunction ignored(path) {\n  return !~ignore.indexOf(path);\n}\n\n/**\n * Lookup files in the given `dir`.\n *\n * @api private\n * @param {string} dir\n * @param {string[]} [ext=['.js']]\n * @param {Array} [ret=[]]\n * @return {Array}\n */\nexports.files = function(dir, ext, ret) {\n  ret = ret || [];\n  ext = ext || ['js'];\n\n  var re = new RegExp('\\\\.(' + ext.join('|') + ')$');\n\n  fs\n    .readdirSync(dir)\n    .filter(ignored)\n    .forEach(function(path) {\n      path = join(dir, path);\n      if (fs.lstatSync(path).isDirectory()) {\n        exports.files(path, ext, ret);\n      } else if (path.match(re)) {\n        ret.push(path);\n      }\n    });\n\n  return ret;\n};\n\n/**\n * Compute a slug from the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nexports.slug = function(str) {\n  return str\n    .toLowerCase()\n    .replace(/ +/g, '-')\n    .replace(/[^-\\w]/g, '');\n};\n\n/**\n * Strip the function definition from `str`, and re-indent for pre whitespace.\n *\n * @param {string} str\n * @return {string}\n */\nexports.clean = function(str) {\n  str = str\n    .replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, '\\n')\n    .replace(/^\\uFEFF/, '')\n    // (traditional)->  space/name     parameters    body     (lambda)-> parameters       body   multi-statement/single          keep body content\n    .replace(\n      /^function(?:\\s*|\\s+[^(]*)\\([^)]*\\)\\s*\\{((?:.|\\n)*?)\\s*\\}$|^\\([^)]*\\)\\s*=>\\s*(?:\\{((?:.|\\n)*?)\\s*\\}|((?:.|\\n)*))$/,\n      '$1$2$3'\n    );\n\n  var spaces = str.match(/^\\n?( *)/)[1].length;\n  var tabs = str.match(/^\\n?(\\t*)/)[1].length;\n  var re = new RegExp(\n    '^\\n?' + (tabs ? '\\t' : ' ') + '{' + (tabs || spaces) + '}',\n    'gm'\n  );\n\n  str = str.replace(re, '');\n\n  return str.trim();\n};\n\n/**\n * Parse the given `qs`.\n *\n * @api private\n * @param {string} qs\n * @return {Object}\n */\nexports.parseQuery = function(qs) {\n  return qs\n    .replace('?', '')\n    .split('&')\n    .reduce(function(obj, pair) {\n      var i = pair.indexOf('=');\n      var key = pair.slice(0, i);\n      var val = pair.slice(++i);\n\n      // Due to how the URLSearchParams API treats spaces\n      obj[key] = decodeURIComponent(val.replace(/\\+/g, '%20'));\n\n      return obj;\n    }, {});\n};\n\n/**\n * Highlight the given string of `js`.\n *\n * @api private\n * @param {string} js\n * @return {string}\n */\nfunction highlight(js) {\n  return js\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\\/\\/(.*)/gm, '<span class=\"comment\">//$1</span>')\n    .replace(/('.*?')/gm, '<span class=\"string\">$1</span>')\n    .replace(/(\\d+\\.\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/(\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(\n      /\\bnew[ \\t]+(\\w+)/gm,\n      '<span class=\"keyword\">new</span> <span class=\"init\">$1</span>'\n    )\n    .replace(\n      /\\b(function|new|throw|return|var|if|else)\\b/gm,\n      '<span class=\"keyword\">$1</span>'\n    );\n}\n\n/**\n * Highlight the contents of tag `name`.\n *\n * @api private\n * @param {string} name\n */\nexports.highlightTags = function(name) {\n  var code = document.getElementById('mocha').getElementsByTagName(name);\n  for (var i = 0, len = code.length; i < len; ++i) {\n    code[i].innerHTML = highlight(code[i].innerHTML);\n  }\n};\n\n/**\n * If a value could have properties, and has none, this function is called,\n * which returns a string representation of the empty value.\n *\n * Functions w/ no properties return `'[Function]'`\n * Arrays w/ length === 0 return `'[]'`\n * Objects w/ no properties return `'{}'`\n * All else: return result of `value.toString()`\n *\n * @api private\n * @param {*} value The value to inspect.\n * @param {string} typeHint The type of the value\n * @returns {string}\n */\nfunction emptyRepresentation(value, typeHint) {\n  switch (typeHint) {\n    case 'function':\n      return '[Function]';\n    case 'object':\n      return '{}';\n    case 'array':\n      return '[]';\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Takes some variable and asks `Object.prototype.toString()` what it thinks it\n * is.\n *\n * @api private\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n * @param {*} value The value to test.\n * @returns {string} Computed type\n * @example\n * type({}) // 'object'\n * type([]) // 'array'\n * type(1) // 'number'\n * type(false) // 'boolean'\n * type(Infinity) // 'number'\n * type(null) // 'null'\n * type(new Date()) // 'date'\n * type(/foo/) // 'regexp'\n * type('type') // 'string'\n * type(global) // 'global'\n * type(new String('foo') // 'object'\n */\nvar type = (exports.type = function type(value) {\n  if (value === undefined) {\n    return 'undefined';\n  } else if (value === null) {\n    return 'null';\n  } else if (Buffer.isBuffer(value)) {\n    return 'buffer';\n  }\n  return Object.prototype.toString\n    .call(value)\n    .replace(/^\\[.+\\s(.+?)]$/, '$1')\n    .toLowerCase();\n});\n\n/**\n * Stringify `value`. Different behavior depending on type of value:\n *\n * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.\n * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.\n * - If `value` is an *empty* object, function, or array, return result of function\n *   {@link emptyRepresentation}.\n * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of\n *   JSON.stringify().\n *\n * @api private\n * @see exports.type\n * @param {*} value\n * @return {string}\n */\nexports.stringify = function(value) {\n  var typeHint = type(value);\n\n  if (!~['object', 'array', 'function'].indexOf(typeHint)) {\n    if (typeHint === 'buffer') {\n      var json = Buffer.prototype.toJSON.call(value);\n      // Based on the toJSON result\n      return jsonStringify(\n        json.data && json.type ? json.data : json,\n        2\n      ).replace(/,(\\n|$)/g, '$1');\n    }\n\n    // IE7/IE8 has a bizarre String constructor; needs to be coerced\n    // into an array and back to obj.\n    if (typeHint === 'string' && typeof value === 'object') {\n      value = value.split('').reduce(function(acc, char, idx) {\n        acc[idx] = char;\n        return acc;\n      }, {});\n      typeHint = 'object';\n    } else {\n      return jsonStringify(value);\n    }\n  }\n\n  for (var prop in value) {\n    if (Object.prototype.hasOwnProperty.call(value, prop)) {\n      return jsonStringify(\n        exports.canonicalize(value, null, typeHint),\n        2\n      ).replace(/,(\\n|$)/g, '$1');\n    }\n  }\n\n  return emptyRepresentation(value, typeHint);\n};\n\n/**\n * like JSON.stringify but more sense.\n *\n * @api private\n * @param {Object}  object\n * @param {number=} spaces\n * @param {number=} depth\n * @returns {*}\n */\nfunction jsonStringify(object, spaces, depth) {\n  if (typeof spaces === 'undefined') {\n    // primitive types\n    return _stringify(object);\n  }\n\n  depth = depth || 1;\n  var space = spaces * depth;\n  var str = Array.isArray(object) ? '[' : '{';\n  var end = Array.isArray(object) ? ']' : '}';\n  var length =\n    typeof object.length === 'number'\n      ? object.length\n      : Object.keys(object).length;\n  // `.repeat()` polyfill\n  function repeat(s, n) {\n    return new Array(n).join(s);\n  }\n\n  function _stringify(val) {\n    switch (type(val)) {\n      case 'null':\n      case 'undefined':\n        val = '[' + val + ']';\n        break;\n      case 'array':\n      case 'object':\n        val = jsonStringify(val, spaces, depth + 1);\n        break;\n      case 'boolean':\n      case 'regexp':\n      case 'symbol':\n      case 'number':\n        val =\n          val === 0 && 1 / val === -Infinity // `-0`\n            ? '-0'\n            : val.toString();\n        break;\n      case 'date':\n        var sDate = isNaN(val.getTime()) ? val.toString() : val.toISOString();\n        val = '[Date: ' + sDate + ']';\n        break;\n      case 'buffer':\n        var json = val.toJSON();\n        // Based on the toJSON result\n        json = json.data && json.type ? json.data : json;\n        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';\n        break;\n      default:\n        val =\n          val === '[Function]' || val === '[Circular]'\n            ? val\n            : JSON.stringify(val); // string\n    }\n    return val;\n  }\n\n  for (var i in object) {\n    if (!Object.prototype.hasOwnProperty.call(object, i)) {\n      continue; // not my business\n    }\n    --length;\n    str +=\n      '\\n ' +\n      repeat(' ', space) +\n      (Array.isArray(object) ? '' : '\"' + i + '\": ') + // key\n      _stringify(object[i]) + // value\n      (length ? ',' : ''); // comma\n  }\n\n  return (\n    str +\n    // [], {}\n    (str.length !== 1 ? '\\n' + repeat(' ', --space) + end : end)\n  );\n}\n\n/**\n * Return a new Thing that has the keys in sorted order. Recursive.\n *\n * If the Thing...\n * - has already been seen, return string `'[Circular]'`\n * - is `undefined`, return string `'[undefined]'`\n * - is `null`, return value `null`\n * - is some other primitive, return the value\n * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method\n * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.\n * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`\n *\n * @api private\n * @see {@link exports.stringify}\n * @param {*} value Thing to inspect.  May or may not have properties.\n * @param {Array} [stack=[]] Stack of seen values\n * @param {string} [typeHint] Type hint\n * @return {(Object|Array|Function|string|undefined)}\n */\nexports.canonicalize = function canonicalize(value, stack, typeHint) {\n  var canonicalizedObj;\n  /* eslint-disable no-unused-vars */\n  var prop;\n  /* eslint-enable no-unused-vars */\n  typeHint = typeHint || type(value);\n  function withStack(value, fn) {\n    stack.push(value);\n    fn();\n    stack.pop();\n  }\n\n  stack = stack || [];\n\n  if (stack.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  switch (typeHint) {\n    case 'undefined':\n    case 'buffer':\n    case 'null':\n      canonicalizedObj = value;\n      break;\n    case 'array':\n      withStack(value, function() {\n        canonicalizedObj = value.map(function(item) {\n          return exports.canonicalize(item, stack);\n        });\n      });\n      break;\n    case 'function':\n      /* eslint-disable guard-for-in */\n      for (prop in value) {\n        canonicalizedObj = {};\n        break;\n      }\n      /* eslint-enable guard-for-in */\n      if (!canonicalizedObj) {\n        canonicalizedObj = emptyRepresentation(value, typeHint);\n        break;\n      }\n    /* falls through */\n    case 'object':\n      canonicalizedObj = canonicalizedObj || {};\n      withStack(value, function() {\n        Object.keys(value)\n          .sort()\n          .forEach(function(key) {\n            canonicalizedObj[key] = exports.canonicalize(value[key], stack);\n          });\n      });\n      break;\n    case 'date':\n    case 'number':\n    case 'regexp':\n    case 'boolean':\n    case 'symbol':\n      canonicalizedObj = value;\n      break;\n    default:\n      canonicalizedObj = value + '';\n  }\n\n  return canonicalizedObj;\n};\n\n/**\n * Lookup file names at the given `path`.\n *\n * @memberof Mocha.utils\n * @public\n * @api public\n * @param {string} filepath Base path to start searching from.\n * @param {string[]} extensions File extensions to look for.\n * @param {boolean} recursive Whether or not to recurse into subdirectories.\n * @return {string[]} An array of paths.\n */\nexports.lookupFiles = function lookupFiles(filepath, extensions, recursive) {\n  var files = [];\n\n  if (!fs.existsSync(filepath)) {\n    if (fs.existsSync(filepath + '.js')) {\n      filepath += '.js';\n    } else {\n      files = glob.sync(filepath);\n      if (!files.length) {\n        throw new Error(\"cannot resolve path (or pattern) '\" + filepath + \"'\");\n      }\n      return files;\n    }\n  }\n\n  try {\n    var stat = fs.statSync(filepath);\n    if (stat.isFile()) {\n      return filepath;\n    }\n  } catch (err) {\n    // ignore error\n    return;\n  }\n\n  fs.readdirSync(filepath).forEach(function(file) {\n    file = path.join(filepath, file);\n    try {\n      var stat = fs.statSync(file);\n      if (stat.isDirectory()) {\n        if (recursive) {\n          files = files.concat(lookupFiles(file, extensions, recursive));\n        }\n        return;\n      }\n    } catch (err) {\n      // ignore error\n      return;\n    }\n    if (!extensions) {\n      throw new Error(\n        'extensions parameter required when filepath is a directory'\n      );\n    }\n    var re = new RegExp('\\\\.(?:' + extensions.join('|') + ')$');\n    if (!stat.isFile() || !re.test(file) || path.basename(file)[0] === '.') {\n      return;\n    }\n    files.push(file);\n  });\n\n  return files;\n};\n\n/**\n * Generate an undefined error with a message warning the user.\n *\n * @return {Error}\n */\n\nexports.undefinedError = function() {\n  return new Error(\n    'Caught undefined error, did you throw without specifying what?'\n  );\n};\n\n/**\n * Generate an undefined error if `err` is not defined.\n *\n * @param {Error} err\n * @return {Error}\n */\n\nexports.getError = function(err) {\n  return err || exports.undefinedError();\n};\n\n/**\n * @summary\n * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)\n * @description\n * When invoking this function you get a filter function that get the Error.stack as an input,\n * and return a prettify output.\n * (i.e: strip Mocha and internal node functions from stack trace).\n * @returns {Function}\n */\nexports.stackTraceFilter = function() {\n  // TODO: Replace with `process.browser`\n  var is = typeof document === 'undefined' ? {node: true} : {browser: true};\n  var slash = path.sep;\n  var cwd;\n  if (is.node) {\n    cwd = process.cwd() + slash;\n  } else {\n    cwd = (typeof location === 'undefined'\n      ? window.location\n      : location\n    ).href.replace(/\\/[^/]*$/, '/');\n    slash = '/';\n  }\n\n  function isMochaInternal(line) {\n    return (\n      ~line.indexOf('node_modules' + slash + 'mocha' + slash) ||\n      ~line.indexOf('node_modules' + slash + 'mocha.js') ||\n      ~line.indexOf('bower_components' + slash + 'mocha.js') ||\n      ~line.indexOf(slash + 'mocha.js')\n    );\n  }\n\n  function isNodeInternal(line) {\n    return (\n      ~line.indexOf('(timers.js:') ||\n      ~line.indexOf('(events.js:') ||\n      ~line.indexOf('(node.js:') ||\n      ~line.indexOf('(module.js:') ||\n      ~line.indexOf('GeneratorFunctionPrototype.next (native)') ||\n      false\n    );\n  }\n\n  return function(stack) {\n    stack = stack.split('\\n');\n\n    stack = stack.reduce(function(list, line) {\n      if (isMochaInternal(line)) {\n        return list;\n      }\n\n      if (is.node && isNodeInternal(line)) {\n        return list;\n      }\n\n      // Clean up cwd(absolute)\n      if (/\\(?.+:\\d+:\\d+\\)?$/.test(line)) {\n        line = line.replace('(' + cwd, '(');\n      }\n\n      list.push(line);\n      return list;\n    }, []);\n\n    return stack.join('\\n');\n  };\n};\n\n/**\n * Crude, but effective.\n * @api\n * @param {*} value\n * @returns {boolean} Whether or not `value` is a Promise\n */\nexports.isPromise = function isPromise(value) {\n  return typeof value === 'object' && typeof value.then === 'function';\n};\n\n/**\n * It's a noop.\n * @api\n */\nexports.noop = function() {};\n\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"_process\":56,\"buffer\":41,\"debug\":43,\"fs\":40,\"glob\":40,\"he\":48,\"path\":40,\"util\":76}],37:[function(require,module,exports){\n'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n},{}],38:[function(require,module,exports){\n\n},{}],39:[function(require,module,exports){\n(function (process){\nvar WritableStream = require('stream').Writable\nvar inherits = require('util').inherits\n\nmodule.exports = BrowserStdout\n\n\ninherits(BrowserStdout, WritableStream)\n\nfunction BrowserStdout(opts) {\n  if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)\n\n  opts = opts || {}\n  WritableStream.call(this, opts)\n  this.label = (opts.label !== undefined) ? opts.label : 'stdout'\n}\n\nBrowserStdout.prototype._write = function(chunks, encoding, cb) {\n  var output = chunks.toString ? chunks.toString() : chunks\n  if (this.label === false) {\n    console.log(output)\n  } else {\n    console.log(this.label+':', output)\n  }\n  process.nextTick(cb)\n}\n\n}).call(this,require('_process'))\n},{\"_process\":56,\"stream\":71,\"util\":76}],40:[function(require,module,exports){\narguments[4][38][0].apply(exports,arguments)\n},{\"dup\":38}],41:[function(require,module,exports){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  get: function () {\n    if (!(this instanceof Buffer)) {\n      return undefined\n    }\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  get: function () {\n    if (!(this instanceof Buffer)) {\n      return undefined\n    }\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('Invalid typed array length')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  return fromObject(value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj) {\n    if (ArrayBuffer.isView(obj) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n        return createBuffer(0)\n      }\n      return fromArrayLike(obj)\n    }\n\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n      return fromArrayLike(obj.data)\n    }\n  }\n\n  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (ArrayBuffer.isView(buf)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : new Buffer(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check\n// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166\nfunction isArrayBuffer (obj) {\n  return obj instanceof ArrayBuffer ||\n    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&\n      typeof obj.byteLength === 'number')\n}\n\nfunction numberIsNaN (obj) {\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n},{\"base64-js\":37,\"ieee754\":49}],42:[function(require,module,exports){\n(function (Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n}).call(this,{\"isBuffer\":require(\"../../is-buffer/index.js\")})\n},{\"../../is-buffer/index.js\":51}],43:[function(require,module,exports){\n(function (process){\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n}).call(this,require('_process'))\n},{\"./debug\":44,\"_process\":56}],44:[function(require,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n},{\"ms\":54}],45:[function(require,module,exports){\n/*!\n\n diff v3.5.0\n\nSoftware License Agreement (BSD License)\n\nCopyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of Kevin Decker nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\nIN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n@license\n*/\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(false)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JsDiff\"] = factory();\n\telse\n\t\troot[\"JsDiff\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.merge = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffArrays = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined;\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_character = __webpack_require__(2) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_word = __webpack_require__(3) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_sentence = __webpack_require__(6) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_css = __webpack_require__(7) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_json = __webpack_require__(8) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_array = __webpack_require__(9) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_apply = __webpack_require__(10) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_merge = __webpack_require__(13) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_create = __webpack_require__(14) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_dmp = __webpack_require__(16) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_xml = __webpack_require__(17) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/* See LICENSE file for terms of use */\n\n\t/*\n\t * Text diff implementation.\n\t *\n\t * This library supports the following APIS:\n\t * JsDiff.diffChars: Character by character diff\n\t * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n\t * JsDiff.diffLines: Line based diff\n\t *\n\t * JsDiff.diffCss: Diff targeted at CSS content\n\t *\n\t * These methods are based on the implementation proposed in\n\t * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n\t * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n\t */\n\texports. /*istanbul ignore end*/Diff = _base2['default'];\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffChars = _character.diffChars;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWords = _word.diffWords;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = _word.diffWordsWithSpace;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffLines = _line.diffLines;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = _line.diffTrimmedLines;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffSentences = _sentence.diffSentences;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffCss = _css.diffCss;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffJson = _json.diffJson;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffArrays = _array.diffArrays;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/structuredPatch = _create.structuredPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = _create.createTwoFilesPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = _create.createPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatch = _apply.applyPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = _apply.applyPatches;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/parsePatch = _parse.parsePatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/merge = _merge.merge;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToDMP = _dmp.convertChangesToDMP;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToXML = _xml.convertChangesToXML;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = _json.canonicalize;\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports['default'] = /*istanbul ignore end*/Diff;\n\tfunction Diff() {}\n\n\tDiff.prototype = {\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/diff: function diff(oldString, newString) {\n\t    /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\t    var callback = options.callback;\n\t    if (typeof options === 'function') {\n\t      callback = options;\n\t      options = {};\n\t    }\n\t    this.options = options;\n\n\t    var self = this;\n\n\t    function done(value) {\n\t      if (callback) {\n\t        setTimeout(function () {\n\t          callback(undefined, value);\n\t        }, 0);\n\t        return true;\n\t      } else {\n\t        return value;\n\t      }\n\t    }\n\n\t    // Allow subclasses to massage the input prior to running\n\t    oldString = this.castInput(oldString);\n\t    newString = this.castInput(newString);\n\n\t    oldString = this.removeEmpty(this.tokenize(oldString));\n\t    newString = this.removeEmpty(this.tokenize(newString));\n\n\t    var newLen = newString.length,\n\t        oldLen = oldString.length;\n\t    var editLength = 1;\n\t    var maxEditLength = newLen + oldLen;\n\t    var bestPath = [{ newPos: -1, components: [] }];\n\n\t    // Seed editLength = 0, i.e. the content starts with the same values\n\t    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\t    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n\t      // Identity per the equality and tokenizer\n\t      return done([{ value: this.join(newString), count: newString.length }]);\n\t    }\n\n\t    // Main worker method. checks all permutations of a given edit length for acceptance.\n\t    function execEditLength() {\n\t      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n\t        var basePath = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\t        var addPath = bestPath[diagonalPath - 1],\n\t            removePath = bestPath[diagonalPath + 1],\n\t            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\t        if (addPath) {\n\t          // No one else is going to attempt to use this value, clear it\n\t          bestPath[diagonalPath - 1] = undefined;\n\t        }\n\n\t        var canAdd = addPath && addPath.newPos + 1 < newLen,\n\t            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\t        if (!canAdd && !canRemove) {\n\t          // If this path is a terminal then prune\n\t          bestPath[diagonalPath] = undefined;\n\t          continue;\n\t        }\n\n\t        // Select the diagonal that we want to branch from. We select the prior\n\t        // path whose position in the new string is the farthest from the origin\n\t        // and does not pass the bounds of the diff graph\n\t        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n\t          basePath = clonePath(removePath);\n\t          self.pushComponent(basePath.components, undefined, true);\n\t        } else {\n\t          basePath = addPath; // No need to clone, we've pulled it from the list\n\t          basePath.newPos++;\n\t          self.pushComponent(basePath.components, true, undefined);\n\t        }\n\n\t        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n\t        // If we have hit the end of both strings, then we are done\n\t        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n\t          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n\t        } else {\n\t          // Otherwise track this path as a potential candidate and continue.\n\t          bestPath[diagonalPath] = basePath;\n\t        }\n\t      }\n\n\t      editLength++;\n\t    }\n\n\t    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n\t    // sync and async mode which is never fun. Loops over execEditLength until a value\n\t    // is produced.\n\t    if (callback) {\n\t      (function exec() {\n\t        setTimeout(function () {\n\t          // This should not happen, but we want to be safe.\n\t          /* istanbul ignore next */\n\t          if (editLength > maxEditLength) {\n\t            return callback();\n\t          }\n\n\t          if (!execEditLength()) {\n\t            exec();\n\t          }\n\t        }, 0);\n\t      })();\n\t    } else {\n\t      while (editLength <= maxEditLength) {\n\t        var ret = execEditLength();\n\t        if (ret) {\n\t          return ret;\n\t        }\n\t      }\n\t    }\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/pushComponent: function pushComponent(components, added, removed) {\n\t    var last = components[components.length - 1];\n\t    if (last && last.added === added && last.removed === removed) {\n\t      // We need to clone here as the component clone operation is just\n\t      // as shallow array clone\n\t      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed };\n\t    } else {\n\t      components.push({ count: 1, added: added, removed: removed });\n\t    }\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n\t    var newLen = newString.length,\n\t        oldLen = oldString.length,\n\t        newPos = basePath.newPos,\n\t        oldPos = newPos - diagonalPath,\n\t        commonCount = 0;\n\t    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n\t      newPos++;\n\t      oldPos++;\n\t      commonCount++;\n\t    }\n\n\t    if (commonCount) {\n\t      basePath.components.push({ count: commonCount });\n\t    }\n\n\t    basePath.newPos = newPos;\n\t    return oldPos;\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/equals: function equals(left, right) {\n\t    if (this.options.comparator) {\n\t      return this.options.comparator(left, right);\n\t    } else {\n\t      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n\t    }\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/removeEmpty: function removeEmpty(array) {\n\t    var ret = [];\n\t    for (var i = 0; i < array.length; i++) {\n\t      if (array[i]) {\n\t        ret.push(array[i]);\n\t      }\n\t    }\n\t    return ret;\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/castInput: function castInput(value) {\n\t    return value;\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/tokenize: function tokenize(value) {\n\t    return value.split('');\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/join: function join(chars) {\n\t    return chars.join('');\n\t  }\n\t};\n\n\tfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n\t  var componentPos = 0,\n\t      componentLen = components.length,\n\t      newPos = 0,\n\t      oldPos = 0;\n\n\t  for (; componentPos < componentLen; componentPos++) {\n\t    var component = components[componentPos];\n\t    if (!component.removed) {\n\t      if (!component.added && useLongestToken) {\n\t        var value = newString.slice(newPos, newPos + component.count);\n\t        value = value.map(function (value, i) {\n\t          var oldValue = oldString[oldPos + i];\n\t          return oldValue.length > value.length ? oldValue : value;\n\t        });\n\n\t        component.value = diff.join(value);\n\t      } else {\n\t        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n\t      }\n\t      newPos += component.count;\n\n\t      // Common case\n\t      if (!component.added) {\n\t        oldPos += component.count;\n\t      }\n\t    } else {\n\t      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n\t      oldPos += component.count;\n\n\t      // Reverse add and remove so removes are output first to match common convention\n\t      // The diffing algorithm is tied to add then remove output and this is the simplest\n\t      // route to get the desired output with minimal overhead.\n\t      if (componentPos && components[componentPos - 1].added) {\n\t        var tmp = components[componentPos - 1];\n\t        components[componentPos - 1] = components[componentPos];\n\t        components[componentPos] = tmp;\n\t      }\n\t    }\n\t  }\n\n\t  // Special case handle for when one terminal is ignored (i.e. whitespace).\n\t  // For this case we merge the terminal into the prior string and drop the change.\n\t  // This is only available for string mode.\n\t  var lastComponent = components[componentLen - 1];\n\t  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n\t    components[componentLen - 2].value += lastComponent.value;\n\t    components.pop();\n\t  }\n\n\t  return components;\n\t}\n\n\tfunction clonePath(path) {\n\t  return { newPos: path.newPos, components: path.components.slice(0) };\n\t}\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.characterDiff = undefined;\n\texports. /*istanbul ignore end*/diffChars = diffChars;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var characterDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/characterDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tfunction diffChars(oldStr, newStr, options) {\n\t  return characterDiff.diff(oldStr, newStr, options);\n\t}\n\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.wordDiff = undefined;\n\texports. /*istanbul ignore end*/diffWords = diffWords;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = diffWordsWithSpace;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/ // Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n\t//\n\t// Ranges and exceptions:\n\t// Latin-1 Supplement, 0080–00FF\n\t//  - U+00D7  × Multiplication sign\n\t//  - U+00F7  ÷ Division sign\n\t// Latin Extended-A, 0100–017F\n\t// Latin Extended-B, 0180–024F\n\t// IPA Extensions, 0250–02AF\n\t// Spacing Modifier Letters, 02B0–02FF\n\t//  - U+02C7  ˇ &#711;  Caron\n\t//  - U+02D8  ˘ &#728;  Breve\n\t//  - U+02D9  ˙ &#729;  Dot Above\n\t//  - U+02DA  ˚ &#730;  Ring Above\n\t//  - U+02DB  ˛ &#731;  Ogonek\n\t//  - U+02DC  ˜ &#732;  Small Tilde\n\t//  - U+02DD  ˝ &#733;  Double Acute Accent\n\t// Latin Extended Additional, 1E00–1EFF\n\tvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\n\n\tvar reWhitespace = /\\S/;\n\n\tvar wordDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/wordDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\twordDiff.equals = function (left, right) {\n\t  if (this.options.ignoreCase) {\n\t    left = left.toLowerCase();\n\t    right = right.toLowerCase();\n\t  }\n\t  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n\t};\n\twordDiff.tokenize = function (value) {\n\t  var tokens = value.split(/(\\s+|\\b)/);\n\n\t  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\t  for (var i = 0; i < tokens.length - 1; i++) {\n\t    // If we have an empty string in the next field and we have only word chars before and after, merge\n\t    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n\t      tokens[i] += tokens[i + 2];\n\t      tokens.splice(i + 1, 2);\n\t      i--;\n\t    }\n\t  }\n\n\t  return tokens;\n\t};\n\n\tfunction diffWords(oldStr, newStr, options) {\n\t  options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(options, { ignoreWhitespace: true });\n\t  return wordDiff.diff(oldStr, newStr, options);\n\t}\n\n\tfunction diffWordsWithSpace(oldStr, newStr, options) {\n\t  return wordDiff.diff(oldStr, newStr, options);\n\t}\n\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/generateOptions = generateOptions;\n\tfunction generateOptions(options, defaults) {\n\t  if (typeof options === 'function') {\n\t    defaults.callback = options;\n\t  } else if (options) {\n\t    for (var name in options) {\n\t      /* istanbul ignore else */\n\t      if (options.hasOwnProperty(name)) {\n\t        defaults[name] = options[name];\n\t      }\n\t    }\n\t  }\n\t  return defaults;\n\t}\n\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.lineDiff = undefined;\n\texports. /*istanbul ignore end*/diffLines = diffLines;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = diffTrimmedLines;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var lineDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/lineDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tlineDiff.tokenize = function (value) {\n\t  var retLines = [],\n\t      linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n\t  // Ignore the final empty token that occurs if the string ends with a new line\n\t  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n\t    linesAndNewlines.pop();\n\t  }\n\n\t  // Merge the content and line separators into single tokens\n\t  for (var i = 0; i < linesAndNewlines.length; i++) {\n\t    var line = linesAndNewlines[i];\n\n\t    if (i % 2 && !this.options.newlineIsToken) {\n\t      retLines[retLines.length - 1] += line;\n\t    } else {\n\t      if (this.options.ignoreWhitespace) {\n\t        line = line.trim();\n\t      }\n\t      retLines.push(line);\n\t    }\n\t  }\n\n\t  return retLines;\n\t};\n\n\tfunction diffLines(oldStr, newStr, callback) {\n\t  return lineDiff.diff(oldStr, newStr, callback);\n\t}\n\tfunction diffTrimmedLines(oldStr, newStr, callback) {\n\t  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });\n\t  return lineDiff.diff(oldStr, newStr, options);\n\t}\n\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.sentenceDiff = undefined;\n\texports. /*istanbul ignore end*/diffSentences = diffSentences;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var sentenceDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/sentenceDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tsentenceDiff.tokenize = function (value) {\n\t  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n\t};\n\n\tfunction diffSentences(oldStr, newStr, callback) {\n\t  return sentenceDiff.diff(oldStr, newStr, callback);\n\t}\n\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.cssDiff = undefined;\n\texports. /*istanbul ignore end*/diffCss = diffCss;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var cssDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/cssDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tcssDiff.tokenize = function (value) {\n\t  return value.split(/([{}:;,]|\\s+)/);\n\t};\n\n\tfunction diffCss(oldStr, newStr, callback) {\n\t  return cssDiff.diff(oldStr, newStr, callback);\n\t}\n\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.jsonDiff = undefined;\n\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\texports. /*istanbul ignore end*/diffJson = diffJson;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = canonicalize;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var objectPrototypeToString = Object.prototype.toString;\n\n\tvar jsonDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/jsonDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\t// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n\t// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\tjsonDiff.useLongestToken = true;\n\n\tjsonDiff.tokenize = /*istanbul ignore start*/_line.lineDiff /*istanbul ignore end*/.tokenize;\n\tjsonDiff.castInput = function (value) {\n\t  /*istanbul ignore start*/var _options = /*istanbul ignore end*/this.options,\n\t      undefinedReplacement = _options.undefinedReplacement,\n\t      _options$stringifyRep = _options.stringifyReplacer,\n\t      stringifyReplacer = _options$stringifyRep === undefined ? function (k, v) /*istanbul ignore start*/{\n\t    return (/*istanbul ignore end*/typeof v === 'undefined' ? undefinedReplacement : v\n\t    );\n\t  } : _options$stringifyRep;\n\n\n\t  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n\t};\n\tjsonDiff.equals = function (left, right) {\n\t  return (/*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'))\n\t  );\n\t};\n\n\tfunction diffJson(oldObj, newObj, options) {\n\t  return jsonDiff.diff(oldObj, newObj, options);\n\t}\n\n\t// This function handles the presence of circular references by bailing out when encountering an\n\t// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\tfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n\t  stack = stack || [];\n\t  replacementStack = replacementStack || [];\n\n\t  if (replacer) {\n\t    obj = replacer(key, obj);\n\t  }\n\n\t  var i = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n\t  for (i = 0; i < stack.length; i += 1) {\n\t    if (stack[i] === obj) {\n\t      return replacementStack[i];\n\t    }\n\t  }\n\n\t  var canonicalizedObj = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n\t  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n\t    stack.push(obj);\n\t    canonicalizedObj = new Array(obj.length);\n\t    replacementStack.push(canonicalizedObj);\n\t    for (i = 0; i < obj.length; i += 1) {\n\t      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n\t    }\n\t    stack.pop();\n\t    replacementStack.pop();\n\t    return canonicalizedObj;\n\t  }\n\n\t  if (obj && obj.toJSON) {\n\t    obj = obj.toJSON();\n\t  }\n\n\t  if ( /*istanbul ignore start*/(typeof /*istanbul ignore end*/obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {\n\t    stack.push(obj);\n\t    canonicalizedObj = {};\n\t    replacementStack.push(canonicalizedObj);\n\t    var sortedKeys = [],\n\t        _key = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\t    for (_key in obj) {\n\t      /* istanbul ignore else */\n\t      if (obj.hasOwnProperty(_key)) {\n\t        sortedKeys.push(_key);\n\t      }\n\t    }\n\t    sortedKeys.sort();\n\t    for (i = 0; i < sortedKeys.length; i += 1) {\n\t      _key = sortedKeys[i];\n\t      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n\t    }\n\t    stack.pop();\n\t    replacementStack.pop();\n\t  } else {\n\t    canonicalizedObj = obj;\n\t  }\n\t  return canonicalizedObj;\n\t}\n\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.arrayDiff = undefined;\n\texports. /*istanbul ignore end*/diffArrays = diffArrays;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var arrayDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/arrayDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tarrayDiff.tokenize = function (value) {\n\t  return value.slice();\n\t};\n\tarrayDiff.join = arrayDiff.removeEmpty = function (value) {\n\t  return value;\n\t};\n\n\tfunction diffArrays(oldArr, newArr, callback) {\n\t  return arrayDiff.diff(oldArr, newArr, callback);\n\t}\n\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/applyPatch = applyPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = applyPatches;\n\n\tvar /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_distanceIterator = __webpack_require__(12) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _distanceIterator2 = _interopRequireDefault(_distanceIterator);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/function applyPatch(source, uniDiff) {\n\t  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\t  if (typeof uniDiff === 'string') {\n\t    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);\n\t  }\n\n\t  if (Array.isArray(uniDiff)) {\n\t    if (uniDiff.length > 1) {\n\t      throw new Error('applyPatch only works with a single input.');\n\t    }\n\n\t    uniDiff = uniDiff[0];\n\t  }\n\n\t  // Apply the diff to the input\n\t  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n\t      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n\t      hunks = uniDiff.hunks,\n\t      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/{\n\t    return (/*istanbul ignore end*/line === patchContent\n\t    );\n\t  },\n\t      errorCount = 0,\n\t      fuzzFactor = options.fuzzFactor || 0,\n\t      minLine = 0,\n\t      offset = 0,\n\t      removeEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,\n\t      addEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n\t  /**\n\t   * Checks if the hunk exactly fits on the provided location\n\t   */\n\t  function hunkFits(hunk, toPos) {\n\t    for (var j = 0; j < hunk.lines.length; j++) {\n\t      var line = hunk.lines[j],\n\t          operation = line.length > 0 ? line[0] : ' ',\n\t          content = line.length > 0 ? line.substr(1) : line;\n\n\t      if (operation === ' ' || operation === '-') {\n\t        // Context sanity check\n\t        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n\t          errorCount++;\n\n\t          if (errorCount > fuzzFactor) {\n\t            return false;\n\t          }\n\t        }\n\t        toPos++;\n\t      }\n\t    }\n\n\t    return true;\n\t  }\n\n\t  // Search best fit offsets for each hunk based on the previous ones\n\t  for (var i = 0; i < hunks.length; i++) {\n\t    var hunk = hunks[i],\n\t        maxLine = lines.length - hunk.oldLines,\n\t        localOffset = 0,\n\t        toPos = offset + hunk.oldStart - 1;\n\n\t    var iterator = /*istanbul ignore start*/(0, _distanceIterator2['default']) /*istanbul ignore end*/(toPos, minLine, maxLine);\n\n\t    for (; localOffset !== undefined; localOffset = iterator()) {\n\t      if (hunkFits(hunk, toPos + localOffset)) {\n\t        hunk.offset = offset += localOffset;\n\t        break;\n\t      }\n\t    }\n\n\t    if (localOffset === undefined) {\n\t      return false;\n\t    }\n\n\t    // Set lower text limit to end of the current hunk, so next ones don't try\n\t    // to fit over already patched text\n\t    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n\t  }\n\n\t  // Apply patch hunks\n\t  var diffOffset = 0;\n\t  for (var _i = 0; _i < hunks.length; _i++) {\n\t    var _hunk = hunks[_i],\n\t        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\t    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n\t    if (_toPos < 0) {\n\t      // Creating a new file\n\t      _toPos = 0;\n\t    }\n\n\t    for (var j = 0; j < _hunk.lines.length; j++) {\n\t      var line = _hunk.lines[j],\n\t          operation = line.length > 0 ? line[0] : ' ',\n\t          content = line.length > 0 ? line.substr(1) : line,\n\t          delimiter = _hunk.linedelimiters[j];\n\n\t      if (operation === ' ') {\n\t        _toPos++;\n\t      } else if (operation === '-') {\n\t        lines.splice(_toPos, 1);\n\t        delimiters.splice(_toPos, 1);\n\t        /* istanbul ignore else */\n\t      } else if (operation === '+') {\n\t        lines.splice(_toPos, 0, content);\n\t        delimiters.splice(_toPos, 0, delimiter);\n\t        _toPos++;\n\t      } else if (operation === '\\\\') {\n\t        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\t        if (previousOperation === '+') {\n\t          removeEOFNL = true;\n\t        } else if (previousOperation === '-') {\n\t          addEOFNL = true;\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  // Handle EOFNL insertion/removal\n\t  if (removeEOFNL) {\n\t    while (!lines[lines.length - 1]) {\n\t      lines.pop();\n\t      delimiters.pop();\n\t    }\n\t  } else if (addEOFNL) {\n\t    lines.push('');\n\t    delimiters.push('\\n');\n\t  }\n\t  for (var _k = 0; _k < lines.length - 1; _k++) {\n\t    lines[_k] = lines[_k] + delimiters[_k];\n\t  }\n\t  return lines.join('');\n\t}\n\n\t// Wrapper that supports multiple file patches via callbacks.\n\tfunction applyPatches(uniDiff, options) {\n\t  if (typeof uniDiff === 'string') {\n\t    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);\n\t  }\n\n\t  var currentIndex = 0;\n\t  function processIndex() {\n\t    var index = uniDiff[currentIndex++];\n\t    if (!index) {\n\t      return options.complete();\n\t    }\n\n\t    options.loadFile(index, function (err, data) {\n\t      if (err) {\n\t        return options.complete(err);\n\t      }\n\n\t      var updatedContent = applyPatch(data, index, options);\n\t      options.patched(index, updatedContent, function (err) {\n\t        if (err) {\n\t          return options.complete(err);\n\t        }\n\n\t        processIndex();\n\t      });\n\t    });\n\t  }\n\t  processIndex();\n\t}\n\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/parsePatch = parsePatch;\n\tfunction parsePatch(uniDiff) {\n\t  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n\t      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n\t      list = [],\n\t      i = 0;\n\n\t  function parseIndex() {\n\t    var index = {};\n\t    list.push(index);\n\n\t    // Parse diff metadata\n\t    while (i < diffstr.length) {\n\t      var line = diffstr[i];\n\n\t      // File header found, end parsing diff metadata\n\t      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n\t        break;\n\t      }\n\n\t      // Diff index\n\t      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\t      if (header) {\n\t        index.index = header[1];\n\t      }\n\n\t      i++;\n\t    }\n\n\t    // Parse file headers if they are defined. Unified diff requires them, but\n\t    // there's no technical issues to have an isolated hunk without file header\n\t    parseFileHeader(index);\n\t    parseFileHeader(index);\n\n\t    // Parse hunks\n\t    index.hunks = [];\n\n\t    while (i < diffstr.length) {\n\t      var _line = diffstr[i];\n\n\t      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n\t        break;\n\t      } else if (/^@@/.test(_line)) {\n\t        index.hunks.push(parseHunk());\n\t      } else if (_line && options.strict) {\n\t        // Ignore unexpected content unless in strict mode\n\t        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n\t      } else {\n\t        i++;\n\t      }\n\t    }\n\t  }\n\n\t  // Parses the --- and +++ headers, if none are found, no lines\n\t  // are consumed.\n\t  function parseFileHeader(index) {\n\t    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\t    if (fileHeader) {\n\t      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n\t      var data = fileHeader[2].split('\\t', 2);\n\t      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\t      if (/^\".*\"$/.test(fileName)) {\n\t        fileName = fileName.substr(1, fileName.length - 2);\n\t      }\n\t      index[keyPrefix + 'FileName'] = fileName;\n\t      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n\n\t      i++;\n\t    }\n\t  }\n\n\t  // Parses a hunk\n\t  // This assumes that we are at the start of a hunk.\n\t  function parseHunk() {\n\t    var chunkHeaderIndex = i,\n\t        chunkHeaderLine = diffstr[i++],\n\t        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n\n\t    var hunk = {\n\t      oldStart: +chunkHeader[1],\n\t      oldLines: +chunkHeader[2] || 1,\n\t      newStart: +chunkHeader[3],\n\t      newLines: +chunkHeader[4] || 1,\n\t      lines: [],\n\t      linedelimiters: []\n\t    };\n\n\t    var addCount = 0,\n\t        removeCount = 0;\n\t    for (; i < diffstr.length; i++) {\n\t      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n\t      // But they could be the header for the next file. Therefore prune such cases out.\n\t      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n\t        break;\n\t      }\n\t      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n\t      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n\t        hunk.lines.push(diffstr[i]);\n\t        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n\t        if (operation === '+') {\n\t          addCount++;\n\t        } else if (operation === '-') {\n\t          removeCount++;\n\t        } else if (operation === ' ') {\n\t          addCount++;\n\t          removeCount++;\n\t        }\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\n\t    // Handle the empty block count case\n\t    if (!addCount && hunk.newLines === 1) {\n\t      hunk.newLines = 0;\n\t    }\n\t    if (!removeCount && hunk.oldLines === 1) {\n\t      hunk.oldLines = 0;\n\t    }\n\n\t    // Perform optional sanity checking\n\t    if (options.strict) {\n\t      if (addCount !== hunk.newLines) {\n\t        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n\t      }\n\t      if (removeCount !== hunk.oldLines) {\n\t        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n\t      }\n\t    }\n\n\t    return hunk;\n\t  }\n\n\t  while (i < diffstr.length) {\n\t    parseIndex();\n\t  }\n\n\t  return list;\n\t}\n\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/\"use strict\";\n\n\texports.__esModule = true;\n\n\texports[\"default\"] = /*istanbul ignore end*/function (start, minLine, maxLine) {\n\t  var wantForward = true,\n\t      backwardExhausted = false,\n\t      forwardExhausted = false,\n\t      localOffset = 1;\n\n\t  return function iterator() {\n\t    if (wantForward && !forwardExhausted) {\n\t      if (backwardExhausted) {\n\t        localOffset++;\n\t      } else {\n\t        wantForward = false;\n\t      }\n\n\t      // Check if trying to fit beyond text length, and if not, check it fits\n\t      // after offset location (or desired location on first iteration)\n\t      if (start + localOffset <= maxLine) {\n\t        return localOffset;\n\t      }\n\n\t      forwardExhausted = true;\n\t    }\n\n\t    if (!backwardExhausted) {\n\t      if (!forwardExhausted) {\n\t        wantForward = true;\n\t      }\n\n\t      // Check if trying to fit before text beginning, and if not, check it fits\n\t      // before offset location\n\t      if (minLine <= start - localOffset) {\n\t        return -localOffset++;\n\t      }\n\n\t      backwardExhausted = true;\n\t      return iterator();\n\t    }\n\n\t    // We tried to fit hunk before text beginning and beyond text length, then\n\t    // hunk can't fit on the text. Return undefined\n\t  };\n\t};\n\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/calcLineCount = calcLineCount;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/merge = merge;\n\n\tvar /*istanbul ignore start*/_create = __webpack_require__(14) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_array = __webpack_require__(15) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\t/*istanbul ignore end*/function calcLineCount(hunk) {\n\t  /*istanbul ignore start*/var _calcOldNewLineCount = /*istanbul ignore end*/calcOldNewLineCount(hunk.lines),\n\t      oldLines = _calcOldNewLineCount.oldLines,\n\t      newLines = _calcOldNewLineCount.newLines;\n\n\t  if (oldLines !== undefined) {\n\t    hunk.oldLines = oldLines;\n\t  } else {\n\t    delete hunk.oldLines;\n\t  }\n\n\t  if (newLines !== undefined) {\n\t    hunk.newLines = newLines;\n\t  } else {\n\t    delete hunk.newLines;\n\t  }\n\t}\n\n\tfunction merge(mine, theirs, base) {\n\t  mine = loadPatch(mine, base);\n\t  theirs = loadPatch(theirs, base);\n\n\t  var ret = {};\n\n\t  // For index we just let it pass through as it doesn't have any necessary meaning.\n\t  // Leaving sanity checks on this to the API consumer that may know more about the\n\t  // meaning in their own context.\n\t  if (mine.index || theirs.index) {\n\t    ret.index = mine.index || theirs.index;\n\t  }\n\n\t  if (mine.newFileName || theirs.newFileName) {\n\t    if (!fileNameChanged(mine)) {\n\t      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n\t      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n\t      ret.newFileName = theirs.newFileName || mine.newFileName;\n\t      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n\t      ret.newHeader = theirs.newHeader || mine.newHeader;\n\t    } else if (!fileNameChanged(theirs)) {\n\t      // No header or no change in theirs, use ours\n\t      ret.oldFileName = mine.oldFileName;\n\t      ret.newFileName = mine.newFileName;\n\t      ret.oldHeader = mine.oldHeader;\n\t      ret.newHeader = mine.newHeader;\n\t    } else {\n\t      // Both changed... figure it out\n\t      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n\t      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n\t      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n\t      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n\t    }\n\t  }\n\n\t  ret.hunks = [];\n\n\t  var mineIndex = 0,\n\t      theirsIndex = 0,\n\t      mineOffset = 0,\n\t      theirsOffset = 0;\n\n\t  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n\t    var mineCurrent = mine.hunks[mineIndex] || { oldStart: Infinity },\n\t        theirsCurrent = theirs.hunks[theirsIndex] || { oldStart: Infinity };\n\n\t    if (hunkBefore(mineCurrent, theirsCurrent)) {\n\t      // This patch does not overlap with any of the others, yay.\n\t      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n\t      mineIndex++;\n\t      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n\t    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n\t      // This patch does not overlap with any of the others, yay.\n\t      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n\t      theirsIndex++;\n\t      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n\t    } else {\n\t      // Overlap, merge as best we can\n\t      var mergedHunk = {\n\t        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n\t        oldLines: 0,\n\t        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n\t        newLines: 0,\n\t        lines: []\n\t      };\n\t      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n\t      theirsIndex++;\n\t      mineIndex++;\n\n\t      ret.hunks.push(mergedHunk);\n\t    }\n\t  }\n\n\t  return ret;\n\t}\n\n\tfunction loadPatch(param, base) {\n\t  if (typeof param === 'string') {\n\t    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n\t      return (/*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(param)[0]\n\t      );\n\t    }\n\n\t    if (!base) {\n\t      throw new Error('Must provide a base reference or pass in a patch');\n\t    }\n\t    return (/*istanbul ignore start*/(0, _create.structuredPatch) /*istanbul ignore end*/(undefined, undefined, base, param)\n\t    );\n\t  }\n\n\t  return param;\n\t}\n\n\tfunction fileNameChanged(patch) {\n\t  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n\t}\n\n\tfunction selectField(index, mine, theirs) {\n\t  if (mine === theirs) {\n\t    return mine;\n\t  } else {\n\t    index.conflict = true;\n\t    return { mine: mine, theirs: theirs };\n\t  }\n\t}\n\n\tfunction hunkBefore(test, check) {\n\t  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n\t}\n\n\tfunction cloneHunk(hunk, offset) {\n\t  return {\n\t    oldStart: hunk.oldStart, oldLines: hunk.oldLines,\n\t    newStart: hunk.newStart + offset, newLines: hunk.newLines,\n\t    lines: hunk.lines\n\t  };\n\t}\n\n\tfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n\t  // This will generally result in a conflicted hunk, but there are cases where the context\n\t  // is the only overlap where we can successfully merge the content here.\n\t  var mine = { offset: mineOffset, lines: mineLines, index: 0 },\n\t      their = { offset: theirOffset, lines: theirLines, index: 0 };\n\n\t  // Handle any leading content\n\t  insertLeading(hunk, mine, their);\n\t  insertLeading(hunk, their, mine);\n\n\t  // Now in the overlap content. Scan through and select the best changes from each.\n\t  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n\t    var mineCurrent = mine.lines[mine.index],\n\t        theirCurrent = their.lines[their.index];\n\n\t    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n\t      // Both modified ...\n\t      mutualChange(hunk, mine, their);\n\t    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n\t      /*istanbul ignore start*/var _hunk$lines;\n\n\t      /*istanbul ignore end*/ // Mine inserted\n\t      /*istanbul ignore start*/(_hunk$lines = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(mine)));\n\t    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n\t      /*istanbul ignore start*/var _hunk$lines2;\n\n\t      /*istanbul ignore end*/ // Theirs inserted\n\t      /*istanbul ignore start*/(_hunk$lines2 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(their)));\n\t    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n\t      // Mine removed or edited\n\t      removal(hunk, mine, their);\n\t    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n\t      // Their removed or edited\n\t      removal(hunk, their, mine, true);\n\t    } else if (mineCurrent === theirCurrent) {\n\t      // Context identity\n\t      hunk.lines.push(mineCurrent);\n\t      mine.index++;\n\t      their.index++;\n\t    } else {\n\t      // Context mismatch\n\t      conflict(hunk, collectChange(mine), collectChange(their));\n\t    }\n\t  }\n\n\t  // Now push anything that may be remaining\n\t  insertTrailing(hunk, mine);\n\t  insertTrailing(hunk, their);\n\n\t  calcLineCount(hunk);\n\t}\n\n\tfunction mutualChange(hunk, mine, their) {\n\t  var myChanges = collectChange(mine),\n\t      theirChanges = collectChange(their);\n\n\t  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n\t    // Special case for remove changes that are supersets of one another\n\t    if ( /*istanbul ignore start*/(0, _array.arrayStartsWith) /*istanbul ignore end*/(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n\t      /*istanbul ignore start*/var _hunk$lines3;\n\n\t      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines3 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));\n\t      return;\n\t    } else if ( /*istanbul ignore start*/(0, _array.arrayStartsWith) /*istanbul ignore end*/(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n\t      /*istanbul ignore start*/var _hunk$lines4;\n\n\t      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines4 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines4 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges));\n\t      return;\n\t    }\n\t  } else if ( /*istanbul ignore start*/(0, _array.arrayEqual) /*istanbul ignore end*/(myChanges, theirChanges)) {\n\t    /*istanbul ignore start*/var _hunk$lines5;\n\n\t    /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines5 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines5 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));\n\t    return;\n\t  }\n\n\t  conflict(hunk, myChanges, theirChanges);\n\t}\n\n\tfunction removal(hunk, mine, their, swap) {\n\t  var myChanges = collectChange(mine),\n\t      theirChanges = collectContext(their, myChanges);\n\t  if (theirChanges.merged) {\n\t    /*istanbul ignore start*/var _hunk$lines6;\n\n\t    /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines6 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines6 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges.merged));\n\t  } else {\n\t    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n\t  }\n\t}\n\n\tfunction conflict(hunk, mine, their) {\n\t  hunk.conflict = true;\n\t  hunk.lines.push({\n\t    conflict: true,\n\t    mine: mine,\n\t    theirs: their\n\t  });\n\t}\n\n\tfunction insertLeading(hunk, insert, their) {\n\t  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n\t    var line = insert.lines[insert.index++];\n\t    hunk.lines.push(line);\n\t    insert.offset++;\n\t  }\n\t}\n\tfunction insertTrailing(hunk, insert) {\n\t  while (insert.index < insert.lines.length) {\n\t    var line = insert.lines[insert.index++];\n\t    hunk.lines.push(line);\n\t  }\n\t}\n\n\tfunction collectChange(state) {\n\t  var ret = [],\n\t      operation = state.lines[state.index][0];\n\t  while (state.index < state.lines.length) {\n\t    var line = state.lines[state.index];\n\n\t    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\t    if (operation === '-' && line[0] === '+') {\n\t      operation = '+';\n\t    }\n\n\t    if (operation === line[0]) {\n\t      ret.push(line);\n\t      state.index++;\n\t    } else {\n\t      break;\n\t    }\n\t  }\n\n\t  return ret;\n\t}\n\tfunction collectContext(state, matchChanges) {\n\t  var changes = [],\n\t      merged = [],\n\t      matchIndex = 0,\n\t      contextChanges = false,\n\t      conflicted = false;\n\t  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n\t    var change = state.lines[state.index],\n\t        match = matchChanges[matchIndex];\n\n\t    // Once we've hit our add, then we are done\n\t    if (match[0] === '+') {\n\t      break;\n\t    }\n\n\t    contextChanges = contextChanges || change[0] !== ' ';\n\n\t    merged.push(match);\n\t    matchIndex++;\n\n\t    // Consume any additions in the other block as a conflict to attempt\n\t    // to pull in the remaining context after this\n\t    if (change[0] === '+') {\n\t      conflicted = true;\n\n\t      while (change[0] === '+') {\n\t        changes.push(change);\n\t        change = state.lines[++state.index];\n\t      }\n\t    }\n\n\t    if (match.substr(1) === change.substr(1)) {\n\t      changes.push(change);\n\t      state.index++;\n\t    } else {\n\t      conflicted = true;\n\t    }\n\t  }\n\n\t  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n\t    conflicted = true;\n\t  }\n\n\t  if (conflicted) {\n\t    return changes;\n\t  }\n\n\t  while (matchIndex < matchChanges.length) {\n\t    merged.push(matchChanges[matchIndex++]);\n\t  }\n\n\t  return {\n\t    merged: merged,\n\t    changes: changes\n\t  };\n\t}\n\n\tfunction allRemoves(changes) {\n\t  return changes.reduce(function (prev, change) {\n\t    return prev && change[0] === '-';\n\t  }, true);\n\t}\n\tfunction skipRemoveSuperset(state, removeChanges, delta) {\n\t  for (var i = 0; i < delta; i++) {\n\t    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\t    if (state.lines[state.index + i] !== ' ' + changeContent) {\n\t      return false;\n\t    }\n\t  }\n\n\t  state.index += delta;\n\t  return true;\n\t}\n\n\tfunction calcOldNewLineCount(lines) {\n\t  var oldLines = 0;\n\t  var newLines = 0;\n\n\t  lines.forEach(function (line) {\n\t    if (typeof line !== 'string') {\n\t      var myCount = calcOldNewLineCount(line.mine);\n\t      var theirCount = calcOldNewLineCount(line.theirs);\n\n\t      if (oldLines !== undefined) {\n\t        if (myCount.oldLines === theirCount.oldLines) {\n\t          oldLines += myCount.oldLines;\n\t        } else {\n\t          oldLines = undefined;\n\t        }\n\t      }\n\n\t      if (newLines !== undefined) {\n\t        if (myCount.newLines === theirCount.newLines) {\n\t          newLines += myCount.newLines;\n\t        } else {\n\t          newLines = undefined;\n\t        }\n\t      }\n\t    } else {\n\t      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n\t        newLines++;\n\t      }\n\t      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n\t        oldLines++;\n\t      }\n\t    }\n\t  });\n\n\t  return { oldLines: oldLines, newLines: newLines };\n\t}\n\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/structuredPatch = structuredPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = createTwoFilesPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = createPatch;\n\n\tvar /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\t/*istanbul ignore end*/function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n\t  if (!options) {\n\t    options = {};\n\t  }\n\t  if (typeof options.context === 'undefined') {\n\t    options.context = 4;\n\t  }\n\n\t  var diff = /*istanbul ignore start*/(0, _line.diffLines) /*istanbul ignore end*/(oldStr, newStr, options);\n\t  diff.push({ value: '', lines: [] }); // Append an empty value to make cleanup easier\n\n\t  function contextLines(lines) {\n\t    return lines.map(function (entry) {\n\t      return ' ' + entry;\n\t    });\n\t  }\n\n\t  var hunks = [];\n\t  var oldRangeStart = 0,\n\t      newRangeStart = 0,\n\t      curRange = [],\n\t      oldLine = 1,\n\t      newLine = 1;\n\n\t  /*istanbul ignore start*/var _loop = function _loop( /*istanbul ignore end*/i) {\n\t    var current = diff[i],\n\t        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n\t    current.lines = lines;\n\n\t    if (current.added || current.removed) {\n\t      /*istanbul ignore start*/var _curRange;\n\n\t      /*istanbul ignore end*/ // If we have previous context, start with that\n\t      if (!oldRangeStart) {\n\t        var prev = diff[i - 1];\n\t        oldRangeStart = oldLine;\n\t        newRangeStart = newLine;\n\n\t        if (prev) {\n\t          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n\t          oldRangeStart -= curRange.length;\n\t          newRangeStart -= curRange.length;\n\t        }\n\t      }\n\n\t      // Output our changes\n\t      /*istanbul ignore start*/(_curRange = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/lines.map(function (entry) {\n\t        return (current.added ? '+' : '-') + entry;\n\t      })));\n\n\t      // Track the updated file position\n\t      if (current.added) {\n\t        newLine += lines.length;\n\t      } else {\n\t        oldLine += lines.length;\n\t      }\n\t    } else {\n\t      // Identical context lines. Track line changes\n\t      if (oldRangeStart) {\n\t        // Close out any changes that have been output (or join overlapping)\n\t        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n\t          /*istanbul ignore start*/var _curRange2;\n\n\t          /*istanbul ignore end*/ // Overlapping\n\t          /*istanbul ignore start*/(_curRange2 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines)));\n\t        } else {\n\t          /*istanbul ignore start*/var _curRange3;\n\n\t          /*istanbul ignore end*/ // end the range and output\n\t          var contextSize = Math.min(lines.length, options.context);\n\t          /*istanbul ignore start*/(_curRange3 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines.slice(0, contextSize))));\n\n\t          var hunk = {\n\t            oldStart: oldRangeStart,\n\t            oldLines: oldLine - oldRangeStart + contextSize,\n\t            newStart: newRangeStart,\n\t            newLines: newLine - newRangeStart + contextSize,\n\t            lines: curRange\n\t          };\n\t          if (i >= diff.length - 2 && lines.length <= options.context) {\n\t            // EOF is inside this hunk\n\t            var oldEOFNewline = /\\n$/.test(oldStr);\n\t            var newEOFNewline = /\\n$/.test(newStr);\n\t            if (lines.length == 0 && !oldEOFNewline) {\n\t              // special case: old has no eol and no trailing context; no-nl can end up before adds\n\t              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n\t            } else if (!oldEOFNewline || !newEOFNewline) {\n\t              curRange.push('\\\\ No newline at end of file');\n\t            }\n\t          }\n\t          hunks.push(hunk);\n\n\t          oldRangeStart = 0;\n\t          newRangeStart = 0;\n\t          curRange = [];\n\t        }\n\t      }\n\t      oldLine += lines.length;\n\t      newLine += lines.length;\n\t    }\n\t  };\n\n\t  for (var i = 0; i < diff.length; i++) {\n\t    /*istanbul ignore start*/_loop( /*istanbul ignore end*/i);\n\t  }\n\n\t  return {\n\t    oldFileName: oldFileName, newFileName: newFileName,\n\t    oldHeader: oldHeader, newHeader: newHeader,\n\t    hunks: hunks\n\t  };\n\t}\n\n\tfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n\t  var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n\n\t  var ret = [];\n\t  if (oldFileName == newFileName) {\n\t    ret.push('Index: ' + oldFileName);\n\t  }\n\t  ret.push('===================================================================');\n\t  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n\t  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n\t  for (var i = 0; i < diff.hunks.length; i++) {\n\t    var hunk = diff.hunks[i];\n\t    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n\t    ret.push.apply(ret, hunk.lines);\n\t  }\n\n\t  return ret.join('\\n') + '\\n';\n\t}\n\n\tfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n\t  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n\t}\n\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/\"use strict\";\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/arrayEqual = arrayEqual;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/arrayStartsWith = arrayStartsWith;\n\tfunction arrayEqual(a, b) {\n\t  if (a.length !== b.length) {\n\t    return false;\n\t  }\n\n\t  return arrayStartsWith(a, b);\n\t}\n\n\tfunction arrayStartsWith(array, start) {\n\t  if (start.length > array.length) {\n\t    return false;\n\t  }\n\n\t  for (var i = 0; i < start.length; i++) {\n\t    if (start[i] !== array[i]) {\n\t      return false;\n\t    }\n\t  }\n\n\t  return true;\n\t}\n\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/\"use strict\";\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/convertChangesToDMP = convertChangesToDMP;\n\t// See: http://code.google.com/p/google-diff-match-patch/wiki/API\n\tfunction convertChangesToDMP(changes) {\n\t  var ret = [],\n\t      change = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,\n\t      operation = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\t  for (var i = 0; i < changes.length; i++) {\n\t    change = changes[i];\n\t    if (change.added) {\n\t      operation = 1;\n\t    } else if (change.removed) {\n\t      operation = -1;\n\t    } else {\n\t      operation = 0;\n\t    }\n\n\t    ret.push([operation, change.value]);\n\t  }\n\t  return ret;\n\t}\n\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/convertChangesToXML = convertChangesToXML;\n\tfunction convertChangesToXML(changes) {\n\t  var ret = [];\n\t  for (var i = 0; i < changes.length; i++) {\n\t    var change = changes[i];\n\t    if (change.added) {\n\t      ret.push('<ins>');\n\t    } else if (change.removed) {\n\t      ret.push('<del>');\n\t    }\n\n\t    ret.push(escapeHTML(change.value));\n\n\t    if (change.added) {\n\t      ret.push('</ins>');\n\t    } else if (change.removed) {\n\t      ret.push('</del>');\n\t    }\n\t  }\n\t  return ret.join('');\n\t}\n\n\tfunction escapeHTML(s) {\n\t  var n = s;\n\t  n = n.replace(/&/g, '&amp;');\n\t  n = n.replace(/</g, '&lt;');\n\t  n = n.replace(/>/g, '&gt;');\n\t  n = n.replace(/\"/g, '&quot;');\n\n\t  return n;\n\t}\n\n\n\n/***/ })\n/******/ ])\n});\n;\n},{}],46:[function(require,module,exports){\n'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n\n},{}],47:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar objectCreate = Object.create || objectCreatePolyfill\nvar objectKeys = Object.keys || objectKeysPolyfill\nvar bind = Function.prototype.bind || functionBindPolyfill\n\nfunction EventEmitter() {\n  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {\n    this._events = objectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nvar hasDefineProperty;\ntry {\n  var o = {};\n  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });\n  hasDefineProperty = o.x === 0;\n} catch (err) { hasDefineProperty = false }\nif (hasDefineProperty) {\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function() {\n      return defaultMaxListeners;\n    },\n    set: function(arg) {\n      // check whether the input is a positive number (whose value is zero or\n      // greater and not a NaN).\n      if (typeof arg !== 'number' || arg < 0 || arg !== arg)\n        throw new TypeError('\"defaultMaxListeners\" must be a positive number');\n      defaultMaxListeners = arg;\n    }\n  });\n} else {\n  EventEmitter.defaultMaxListeners = defaultMaxListeners;\n}\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    if (arguments.length > 1)\n      er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Unhandled \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n      // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n      // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = objectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n          listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n          prepend ? [listener, existing] : [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n            existing.length + ' \"' + String(type) + '\" listeners ' +\n            'added. Use emitter.setMaxListeners() to ' +\n            'increase limit.');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        if (typeof console === 'object' && console.warn) {\n          console.warn('%s: %s', w.name, w.message);\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    switch (arguments.length) {\n      case 0:\n        return this.listener.call(this.target);\n      case 1:\n        return this.listener.call(this.target, arguments[0]);\n      case 2:\n        return this.listener.call(this.target, arguments[0], arguments[1]);\n      case 3:\n        return this.listener.call(this.target, arguments[0], arguments[1],\n            arguments[2]);\n      default:\n        var args = new Array(arguments.length);\n        for (var i = 0; i < args.length; ++i)\n          args[i] = arguments[i];\n        this.listener.apply(this.target, args);\n    }\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = bind.call(onceWrapper, state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = objectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else\n          spliceOne(list, position);\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = objectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = objectKeys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = objectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n\n  if (!events)\n    ret = [];\n  else {\n    evlistener = events[type];\n    if (!evlistener)\n      ret = [];\n    else if (typeof evlistener === 'function')\n      ret = [evlistener.listener || evlistener];\n    else\n      ret = unwrapListeners(evlistener);\n  }\n\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction objectCreatePolyfill(proto) {\n  var F = function() {};\n  F.prototype = proto;\n  return new F;\n}\nfunction objectKeysPolyfill(obj) {\n  var keys = [];\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {\n    keys.push(k);\n  }\n  return k;\n}\nfunction functionBindPolyfill(context) {\n  var fn = this;\n  return function () {\n    return fn.apply(context, arguments);\n  };\n}\n\n},{}],48:[function(require,module,exports){\n(function (global){\n/*! https://mths.be/he v1.1.1 by @mathias | MIT license */\n;(function(root) {\n\n\t// Detect free variables `exports`.\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`.\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`.\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t// All astral symbols.\n\tvar regexAstralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\t// All ASCII symbols (not just printable ASCII) except those listed in the\n\t// first column of the overrides table.\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides\n\tvar regexAsciiWhitelist = /[\\x01-\\x7F]/g;\n\t// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or\n\t// code points listed in the first column of the overrides table on\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.\n\tvar regexBmpWhitelist = /[\\x01-\\t\\x0B\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g;\n\n\tvar regexEncodeNonAscii = /<\\u20D2|=\\u20E5|>\\u20D2|\\u205F\\u200A|\\u219D\\u0338|\\u2202\\u0338|\\u2220\\u20D2|\\u2229\\uFE00|\\u222A\\uFE00|\\u223C\\u20D2|\\u223D\\u0331|\\u223E\\u0333|\\u2242\\u0338|\\u224B\\u0338|\\u224D\\u20D2|\\u224E\\u0338|\\u224F\\u0338|\\u2250\\u0338|\\u2261\\u20E5|\\u2264\\u20D2|\\u2265\\u20D2|\\u2266\\u0338|\\u2267\\u0338|\\u2268\\uFE00|\\u2269\\uFE00|\\u226A\\u0338|\\u226A\\u20D2|\\u226B\\u0338|\\u226B\\u20D2|\\u227F\\u0338|\\u2282\\u20D2|\\u2283\\u20D2|\\u228A\\uFE00|\\u228B\\uFE00|\\u228F\\u0338|\\u2290\\u0338|\\u2293\\uFE00|\\u2294\\uFE00|\\u22B4\\u20D2|\\u22B5\\u20D2|\\u22D8\\u0338|\\u22D9\\u0338|\\u22DA\\uFE00|\\u22DB\\uFE00|\\u22F5\\u0338|\\u22F9\\u0338|\\u2933\\u0338|\\u29CF\\u0338|\\u29D0\\u0338|\\u2A6D\\u0338|\\u2A70\\u0338|\\u2A7D\\u0338|\\u2A7E\\u0338|\\u2AA1\\u0338|\\u2AA2\\u0338|\\u2AAC\\uFE00|\\u2AAD\\uFE00|\\u2AAF\\u0338|\\u2AB0\\u0338|\\u2AC5\\u0338|\\u2AC6\\u0338|\\u2ACB\\uFE00|\\u2ACC\\uFE00|\\u2AFD\\u20E5|[\\xA0-\\u0113\\u0116-\\u0122\\u0124-\\u012B\\u012E-\\u014D\\u0150-\\u017E\\u0192\\u01B5\\u01F5\\u0237\\u02C6\\u02C7\\u02D8-\\u02DD\\u0311\\u0391-\\u03A1\\u03A3-\\u03A9\\u03B1-\\u03C9\\u03D1\\u03D2\\u03D5\\u03D6\\u03DC\\u03DD\\u03F0\\u03F1\\u03F5\\u03F6\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E\\u045F\\u2002-\\u2005\\u2007-\\u2010\\u2013-\\u2016\\u2018-\\u201A\\u201C-\\u201E\\u2020-\\u2022\\u2025\\u2026\\u2030-\\u2035\\u2039\\u203A\\u203E\\u2041\\u2043\\u2044\\u204F\\u2057\\u205F-\\u2063\\u20AC\\u20DB\\u20DC\\u2102\\u2105\\u210A-\\u2113\\u2115-\\u211E\\u2122\\u2124\\u2127-\\u2129\\u212C\\u212D\\u212F-\\u2131\\u2133-\\u2138\\u2145-\\u2148\\u2153-\\u215E\\u2190-\\u219B\\u219D-\\u21A7\\u21A9-\\u21AE\\u21B0-\\u21B3\\u21B5-\\u21B7\\u21BA-\\u21DB\\u21DD\\u21E4\\u21E5\\u21F5\\u21FD-\\u2205\\u2207-\\u2209\\u220B\\u220C\\u220F-\\u2214\\u2216-\\u2218\\u221A\\u221D-\\u2238\\u223A-\\u2257\\u2259\\u225A\\u225C\\u225F-\\u2262\\u2264-\\u228B\\u228D-\\u229B\\u229D-\\u22A5\\u22A7-\\u22B0\\u22B2-\\u22BB\\u22BD-\\u22DB\\u22DE-\\u22E3\\u22E6-\\u22F7\\u22F9-\\u22FE\\u2305\\u2306\\u2308-\\u2310\\u2312\\u2313\\u2315\\u2316\\u231C-\\u231F\\u2322\\u2323\\u232D\\u232E\\u2336\\u233D\\u233F\\u237C\\u23B0\\u23B1\\u23B4-\\u23B6\\u23DC-\\u23DF\\u23E2\\u23E7\\u2423\\u24C8\\u2500\\u2502\\u250C\\u2510\\u2514\\u2518\\u251C\\u2524\\u252C\\u2534\\u253C\\u2550-\\u256C\\u2580\\u2584\\u2588\\u2591-\\u2593\\u25A1\\u25AA\\u25AB\\u25AD\\u25AE\\u25B1\\u25B3-\\u25B5\\u25B8\\u25B9\\u25BD-\\u25BF\\u25C2\\u25C3\\u25CA\\u25CB\\u25EC\\u25EF\\u25F8-\\u25FC\\u2605\\u2606\\u260E\\u2640\\u2642\\u2660\\u2663\\u2665\\u2666\\u266A\\u266D-\\u266F\\u2713\\u2717\\u2720\\u2736\\u2758\\u2772\\u2773\\u27C8\\u27C9\\u27E6-\\u27ED\\u27F5-\\u27FA\\u27FC\\u27FF\\u2902-\\u2905\\u290C-\\u2913\\u2916\\u2919-\\u2920\\u2923-\\u292A\\u2933\\u2935-\\u2939\\u293C\\u293D\\u2945\\u2948-\\u294B\\u294E-\\u2976\\u2978\\u2979\\u297B-\\u297F\\u2985\\u2986\\u298B-\\u2996\\u299A\\u299C\\u299D\\u29A4-\\u29B7\\u29B9\\u29BB\\u29BC\\u29BE-\\u29C5\\u29C9\\u29CD-\\u29D0\\u29DC-\\u29DE\\u29E3-\\u29E5\\u29EB\\u29F4\\u29F6\\u2A00-\\u2A02\\u2A04\\u2A06\\u2A0C\\u2A0D\\u2A10-\\u2A17\\u2A22-\\u2A27\\u2A29\\u2A2A\\u2A2D-\\u2A31\\u2A33-\\u2A3C\\u2A3F\\u2A40\\u2A42-\\u2A4D\\u2A50\\u2A53-\\u2A58\\u2A5A-\\u2A5D\\u2A5F\\u2A66\\u2A6A\\u2A6D-\\u2A75\\u2A77-\\u2A9A\\u2A9D-\\u2AA2\\u2AA4-\\u2AB0\\u2AB3-\\u2AC8\\u2ACB\\u2ACC\\u2ACF-\\u2ADB\\u2AE4\\u2AE6-\\u2AE9\\u2AEB-\\u2AF3\\u2AFD\\uFB00-\\uFB04]|\\uD835[\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDCCF\\uDD04\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDD6B]/g;\n\tvar encodeMap = {'\\xAD':'shy','\\u200C':'zwnj','\\u200D':'zwj','\\u200E':'lrm','\\u2063':'ic','\\u2062':'it','\\u2061':'af','\\u200F':'rlm','\\u200B':'ZeroWidthSpace','\\u2060':'NoBreak','\\u0311':'DownBreve','\\u20DB':'tdot','\\u20DC':'DotDot','\\t':'Tab','\\n':'NewLine','\\u2008':'puncsp','\\u205F':'MediumSpace','\\u2009':'thinsp','\\u200A':'hairsp','\\u2004':'emsp13','\\u2002':'ensp','\\u2005':'emsp14','\\u2003':'emsp','\\u2007':'numsp','\\xA0':'nbsp','\\u205F\\u200A':'ThickSpace','\\u203E':'oline','_':'lowbar','\\u2010':'dash','\\u2013':'ndash','\\u2014':'mdash','\\u2015':'horbar',',':'comma',';':'semi','\\u204F':'bsemi',':':'colon','\\u2A74':'Colone','!':'excl','\\xA1':'iexcl','?':'quest','\\xBF':'iquest','.':'period','\\u2025':'nldr','\\u2026':'mldr','\\xB7':'middot','\\'':'apos','\\u2018':'lsquo','\\u2019':'rsquo','\\u201A':'sbquo','\\u2039':'lsaquo','\\u203A':'rsaquo','\"':'quot','\\u201C':'ldquo','\\u201D':'rdquo','\\u201E':'bdquo','\\xAB':'laquo','\\xBB':'raquo','(':'lpar',')':'rpar','[':'lsqb',']':'rsqb','{':'lcub','}':'rcub','\\u2308':'lceil','\\u2309':'rceil','\\u230A':'lfloor','\\u230B':'rfloor','\\u2985':'lopar','\\u2986':'ropar','\\u298B':'lbrke','\\u298C':'rbrke','\\u298D':'lbrkslu','\\u298E':'rbrksld','\\u298F':'lbrksld','\\u2990':'rbrkslu','\\u2991':'langd','\\u2992':'rangd','\\u2993':'lparlt','\\u2994':'rpargt','\\u2995':'gtlPar','\\u2996':'ltrPar','\\u27E6':'lobrk','\\u27E7':'robrk','\\u27E8':'lang','\\u27E9':'rang','\\u27EA':'Lang','\\u27EB':'Rang','\\u27EC':'loang','\\u27ED':'roang','\\u2772':'lbbrk','\\u2773':'rbbrk','\\u2016':'Vert','\\xA7':'sect','\\xB6':'para','@':'commat','*':'ast','/':'sol','undefined':null,'&':'amp','#':'num','%':'percnt','\\u2030':'permil','\\u2031':'pertenk','\\u2020':'dagger','\\u2021':'Dagger','\\u2022':'bull','\\u2043':'hybull','\\u2032':'prime','\\u2033':'Prime','\\u2034':'tprime','\\u2057':'qprime','\\u2035':'bprime','\\u2041':'caret','`':'grave','\\xB4':'acute','\\u02DC':'tilde','^':'Hat','\\xAF':'macr','\\u02D8':'breve','\\u02D9':'dot','\\xA8':'die','\\u02DA':'ring','\\u02DD':'dblac','\\xB8':'cedil','\\u02DB':'ogon','\\u02C6':'circ','\\u02C7':'caron','\\xB0':'deg','\\xA9':'copy','\\xAE':'reg','\\u2117':'copysr','\\u2118':'wp','\\u211E':'rx','\\u2127':'mho','\\u2129':'iiota','\\u2190':'larr','\\u219A':'nlarr','\\u2192':'rarr','\\u219B':'nrarr','\\u2191':'uarr','\\u2193':'darr','\\u2194':'harr','\\u21AE':'nharr','\\u2195':'varr','\\u2196':'nwarr','\\u2197':'nearr','\\u2198':'searr','\\u2199':'swarr','\\u219D':'rarrw','\\u219D\\u0338':'nrarrw','\\u219E':'Larr','\\u219F':'Uarr','\\u21A0':'Rarr','\\u21A1':'Darr','\\u21A2':'larrtl','\\u21A3':'rarrtl','\\u21A4':'mapstoleft','\\u21A5':'mapstoup','\\u21A6':'map','\\u21A7':'mapstodown','\\u21A9':'larrhk','\\u21AA':'rarrhk','\\u21AB':'larrlp','\\u21AC':'rarrlp','\\u21AD':'harrw','\\u21B0':'lsh','\\u21B1':'rsh','\\u21B2':'ldsh','\\u21B3':'rdsh','\\u21B5':'crarr','\\u21B6':'cularr','\\u21B7':'curarr','\\u21BA':'olarr','\\u21BB':'orarr','\\u21BC':'lharu','\\u21BD':'lhard','\\u21BE':'uharr','\\u21BF':'uharl','\\u21C0':'rharu','\\u21C1':'rhard','\\u21C2':'dharr','\\u21C3':'dharl','\\u21C4':'rlarr','\\u21C5':'udarr','\\u21C6':'lrarr','\\u21C7':'llarr','\\u21C8':'uuarr','\\u21C9':'rrarr','\\u21CA':'ddarr','\\u21CB':'lrhar','\\u21CC':'rlhar','\\u21D0':'lArr','\\u21CD':'nlArr','\\u21D1':'uArr','\\u21D2':'rArr','\\u21CF':'nrArr','\\u21D3':'dArr','\\u21D4':'iff','\\u21CE':'nhArr','\\u21D5':'vArr','\\u21D6':'nwArr','\\u21D7':'neArr','\\u21D8':'seArr','\\u21D9':'swArr','\\u21DA':'lAarr','\\u21DB':'rAarr','\\u21DD':'zigrarr','\\u21E4':'larrb','\\u21E5':'rarrb','\\u21F5':'duarr','\\u21FD':'loarr','\\u21FE':'roarr','\\u21FF':'hoarr','\\u2200':'forall','\\u2201':'comp','\\u2202':'part','\\u2202\\u0338':'npart','\\u2203':'exist','\\u2204':'nexist','\\u2205':'empty','\\u2207':'Del','\\u2208':'in','\\u2209':'notin','\\u220B':'ni','\\u220C':'notni','\\u03F6':'bepsi','\\u220F':'prod','\\u2210':'coprod','\\u2211':'sum','+':'plus','\\xB1':'pm','\\xF7':'div','\\xD7':'times','<':'lt','\\u226E':'nlt','<\\u20D2':'nvlt','=':'equals','\\u2260':'ne','=\\u20E5':'bne','\\u2A75':'Equal','>':'gt','\\u226F':'ngt','>\\u20D2':'nvgt','\\xAC':'not','|':'vert','\\xA6':'brvbar','\\u2212':'minus','\\u2213':'mp','\\u2214':'plusdo','\\u2044':'frasl','\\u2216':'setmn','\\u2217':'lowast','\\u2218':'compfn','\\u221A':'Sqrt','\\u221D':'prop','\\u221E':'infin','\\u221F':'angrt','\\u2220':'ang','\\u2220\\u20D2':'nang','\\u2221':'angmsd','\\u2222':'angsph','\\u2223':'mid','\\u2224':'nmid','\\u2225':'par','\\u2226':'npar','\\u2227':'and','\\u2228':'or','\\u2229':'cap','\\u2229\\uFE00':'caps','\\u222A':'cup','\\u222A\\uFE00':'cups','\\u222B':'int','\\u222C':'Int','\\u222D':'tint','\\u2A0C':'qint','\\u222E':'oint','\\u222F':'Conint','\\u2230':'Cconint','\\u2231':'cwint','\\u2232':'cwconint','\\u2233':'awconint','\\u2234':'there4','\\u2235':'becaus','\\u2236':'ratio','\\u2237':'Colon','\\u2238':'minusd','\\u223A':'mDDot','\\u223B':'homtht','\\u223C':'sim','\\u2241':'nsim','\\u223C\\u20D2':'nvsim','\\u223D':'bsim','\\u223D\\u0331':'race','\\u223E':'ac','\\u223E\\u0333':'acE','\\u223F':'acd','\\u2240':'wr','\\u2242':'esim','\\u2242\\u0338':'nesim','\\u2243':'sime','\\u2244':'nsime','\\u2245':'cong','\\u2247':'ncong','\\u2246':'simne','\\u2248':'ap','\\u2249':'nap','\\u224A':'ape','\\u224B':'apid','\\u224B\\u0338':'napid','\\u224C':'bcong','\\u224D':'CupCap','\\u226D':'NotCupCap','\\u224D\\u20D2':'nvap','\\u224E':'bump','\\u224E\\u0338':'nbump','\\u224F':'bumpe','\\u224F\\u0338':'nbumpe','\\u2250':'doteq','\\u2250\\u0338':'nedot','\\u2251':'eDot','\\u2252':'efDot','\\u2253':'erDot','\\u2254':'colone','\\u2255':'ecolon','\\u2256':'ecir','\\u2257':'cire','\\u2259':'wedgeq','\\u225A':'veeeq','\\u225C':'trie','\\u225F':'equest','\\u2261':'equiv','\\u2262':'nequiv','\\u2261\\u20E5':'bnequiv','\\u2264':'le','\\u2270':'nle','\\u2264\\u20D2':'nvle','\\u2265':'ge','\\u2271':'nge','\\u2265\\u20D2':'nvge','\\u2266':'lE','\\u2266\\u0338':'nlE','\\u2267':'gE','\\u2267\\u0338':'ngE','\\u2268\\uFE00':'lvnE','\\u2268':'lnE','\\u2269':'gnE','\\u2269\\uFE00':'gvnE','\\u226A':'ll','\\u226A\\u0338':'nLtv','\\u226A\\u20D2':'nLt','\\u226B':'gg','\\u226B\\u0338':'nGtv','\\u226B\\u20D2':'nGt','\\u226C':'twixt','\\u2272':'lsim','\\u2274':'nlsim','\\u2273':'gsim','\\u2275':'ngsim','\\u2276':'lg','\\u2278':'ntlg','\\u2277':'gl','\\u2279':'ntgl','\\u227A':'pr','\\u2280':'npr','\\u227B':'sc','\\u2281':'nsc','\\u227C':'prcue','\\u22E0':'nprcue','\\u227D':'sccue','\\u22E1':'nsccue','\\u227E':'prsim','\\u227F':'scsim','\\u227F\\u0338':'NotSucceedsTilde','\\u2282':'sub','\\u2284':'nsub','\\u2282\\u20D2':'vnsub','\\u2283':'sup','\\u2285':'nsup','\\u2283\\u20D2':'vnsup','\\u2286':'sube','\\u2288':'nsube','\\u2287':'supe','\\u2289':'nsupe','\\u228A\\uFE00':'vsubne','\\u228A':'subne','\\u228B\\uFE00':'vsupne','\\u228B':'supne','\\u228D':'cupdot','\\u228E':'uplus','\\u228F':'sqsub','\\u228F\\u0338':'NotSquareSubset','\\u2290':'sqsup','\\u2290\\u0338':'NotSquareSuperset','\\u2291':'sqsube','\\u22E2':'nsqsube','\\u2292':'sqsupe','\\u22E3':'nsqsupe','\\u2293':'sqcap','\\u2293\\uFE00':'sqcaps','\\u2294':'sqcup','\\u2294\\uFE00':'sqcups','\\u2295':'oplus','\\u2296':'ominus','\\u2297':'otimes','\\u2298':'osol','\\u2299':'odot','\\u229A':'ocir','\\u229B':'oast','\\u229D':'odash','\\u229E':'plusb','\\u229F':'minusb','\\u22A0':'timesb','\\u22A1':'sdotb','\\u22A2':'vdash','\\u22AC':'nvdash','\\u22A3':'dashv','\\u22A4':'top','\\u22A5':'bot','\\u22A7':'models','\\u22A8':'vDash','\\u22AD':'nvDash','\\u22A9':'Vdash','\\u22AE':'nVdash','\\u22AA':'Vvdash','\\u22AB':'VDash','\\u22AF':'nVDash','\\u22B0':'prurel','\\u22B2':'vltri','\\u22EA':'nltri','\\u22B3':'vrtri','\\u22EB':'nrtri','\\u22B4':'ltrie','\\u22EC':'nltrie','\\u22B4\\u20D2':'nvltrie','\\u22B5':'rtrie','\\u22ED':'nrtrie','\\u22B5\\u20D2':'nvrtrie','\\u22B6':'origof','\\u22B7':'imof','\\u22B8':'mumap','\\u22B9':'hercon','\\u22BA':'intcal','\\u22BB':'veebar','\\u22BD':'barvee','\\u22BE':'angrtvb','\\u22BF':'lrtri','\\u22C0':'Wedge','\\u22C1':'Vee','\\u22C2':'xcap','\\u22C3':'xcup','\\u22C4':'diam','\\u22C5':'sdot','\\u22C6':'Star','\\u22C7':'divonx','\\u22C8':'bowtie','\\u22C9':'ltimes','\\u22CA':'rtimes','\\u22CB':'lthree','\\u22CC':'rthree','\\u22CD':'bsime','\\u22CE':'cuvee','\\u22CF':'cuwed','\\u22D0':'Sub','\\u22D1':'Sup','\\u22D2':'Cap','\\u22D3':'Cup','\\u22D4':'fork','\\u22D5':'epar','\\u22D6':'ltdot','\\u22D7':'gtdot','\\u22D8':'Ll','\\u22D8\\u0338':'nLl','\\u22D9':'Gg','\\u22D9\\u0338':'nGg','\\u22DA\\uFE00':'lesg','\\u22DA':'leg','\\u22DB':'gel','\\u22DB\\uFE00':'gesl','\\u22DE':'cuepr','\\u22DF':'cuesc','\\u22E6':'lnsim','\\u22E7':'gnsim','\\u22E8':'prnsim','\\u22E9':'scnsim','\\u22EE':'vellip','\\u22EF':'ctdot','\\u22F0':'utdot','\\u22F1':'dtdot','\\u22F2':'disin','\\u22F3':'isinsv','\\u22F4':'isins','\\u22F5':'isindot','\\u22F5\\u0338':'notindot','\\u22F6':'notinvc','\\u22F7':'notinvb','\\u22F9':'isinE','\\u22F9\\u0338':'notinE','\\u22FA':'nisd','\\u22FB':'xnis','\\u22FC':'nis','\\u22FD':'notnivc','\\u22FE':'notnivb','\\u2305':'barwed','\\u2306':'Barwed','\\u230C':'drcrop','\\u230D':'dlcrop','\\u230E':'urcrop','\\u230F':'ulcrop','\\u2310':'bnot','\\u2312':'profline','\\u2313':'profsurf','\\u2315':'telrec','\\u2316':'target','\\u231C':'ulcorn','\\u231D':'urcorn','\\u231E':'dlcorn','\\u231F':'drcorn','\\u2322':'frown','\\u2323':'smile','\\u232D':'cylcty','\\u232E':'profalar','\\u2336':'topbot','\\u233D':'ovbar','\\u233F':'solbar','\\u237C':'angzarr','\\u23B0':'lmoust','\\u23B1':'rmoust','\\u23B4':'tbrk','\\u23B5':'bbrk','\\u23B6':'bbrktbrk','\\u23DC':'OverParenthesis','\\u23DD':'UnderParenthesis','\\u23DE':'OverBrace','\\u23DF':'UnderBrace','\\u23E2':'trpezium','\\u23E7':'elinters','\\u2423':'blank','\\u2500':'boxh','\\u2502':'boxv','\\u250C':'boxdr','\\u2510':'boxdl','\\u2514':'boxur','\\u2518':'boxul','\\u251C':'boxvr','\\u2524':'boxvl','\\u252C':'boxhd','\\u2534':'boxhu','\\u253C':'boxvh','\\u2550':'boxH','\\u2551':'boxV','\\u2552':'boxdR','\\u2553':'boxDr','\\u2554':'boxDR','\\u2555':'boxdL','\\u2556':'boxDl','\\u2557':'boxDL','\\u2558':'boxuR','\\u2559':'boxUr','\\u255A':'boxUR','\\u255B':'boxuL','\\u255C':'boxUl','\\u255D':'boxUL','\\u255E':'boxvR','\\u255F':'boxVr','\\u2560':'boxVR','\\u2561':'boxvL','\\u2562':'boxVl','\\u2563':'boxVL','\\u2564':'boxHd','\\u2565':'boxhD','\\u2566':'boxHD','\\u2567':'boxHu','\\u2568':'boxhU','\\u2569':'boxHU','\\u256A':'boxvH','\\u256B':'boxVh','\\u256C':'boxVH','\\u2580':'uhblk','\\u2584':'lhblk','\\u2588':'block','\\u2591':'blk14','\\u2592':'blk12','\\u2593':'blk34','\\u25A1':'squ','\\u25AA':'squf','\\u25AB':'EmptyVerySmallSquare','\\u25AD':'rect','\\u25AE':'marker','\\u25B1':'fltns','\\u25B3':'xutri','\\u25B4':'utrif','\\u25B5':'utri','\\u25B8':'rtrif','\\u25B9':'rtri','\\u25BD':'xdtri','\\u25BE':'dtrif','\\u25BF':'dtri','\\u25C2':'ltrif','\\u25C3':'ltri','\\u25CA':'loz','\\u25CB':'cir','\\u25EC':'tridot','\\u25EF':'xcirc','\\u25F8':'ultri','\\u25F9':'urtri','\\u25FA':'lltri','\\u25FB':'EmptySmallSquare','\\u25FC':'FilledSmallSquare','\\u2605':'starf','\\u2606':'star','\\u260E':'phone','\\u2640':'female','\\u2642':'male','\\u2660':'spades','\\u2663':'clubs','\\u2665':'hearts','\\u2666':'diams','\\u266A':'sung','\\u2713':'check','\\u2717':'cross','\\u2720':'malt','\\u2736':'sext','\\u2758':'VerticalSeparator','\\u27C8':'bsolhsub','\\u27C9':'suphsol','\\u27F5':'xlarr','\\u27F6':'xrarr','\\u27F7':'xharr','\\u27F8':'xlArr','\\u27F9':'xrArr','\\u27FA':'xhArr','\\u27FC':'xmap','\\u27FF':'dzigrarr','\\u2902':'nvlArr','\\u2903':'nvrArr','\\u2904':'nvHarr','\\u2905':'Map','\\u290C':'lbarr','\\u290D':'rbarr','\\u290E':'lBarr','\\u290F':'rBarr','\\u2910':'RBarr','\\u2911':'DDotrahd','\\u2912':'UpArrowBar','\\u2913':'DownArrowBar','\\u2916':'Rarrtl','\\u2919':'latail','\\u291A':'ratail','\\u291B':'lAtail','\\u291C':'rAtail','\\u291D':'larrfs','\\u291E':'rarrfs','\\u291F':'larrbfs','\\u2920':'rarrbfs','\\u2923':'nwarhk','\\u2924':'nearhk','\\u2925':'searhk','\\u2926':'swarhk','\\u2927':'nwnear','\\u2928':'toea','\\u2929':'tosa','\\u292A':'swnwar','\\u2933':'rarrc','\\u2933\\u0338':'nrarrc','\\u2935':'cudarrr','\\u2936':'ldca','\\u2937':'rdca','\\u2938':'cudarrl','\\u2939':'larrpl','\\u293C':'curarrm','\\u293D':'cularrp','\\u2945':'rarrpl','\\u2948':'harrcir','\\u2949':'Uarrocir','\\u294A':'lurdshar','\\u294B':'ldrushar','\\u294E':'LeftRightVector','\\u294F':'RightUpDownVector','\\u2950':'DownLeftRightVector','\\u2951':'LeftUpDownVector','\\u2952':'LeftVectorBar','\\u2953':'RightVectorBar','\\u2954':'RightUpVectorBar','\\u2955':'RightDownVectorBar','\\u2956':'DownLeftVectorBar','\\u2957':'DownRightVectorBar','\\u2958':'LeftUpVectorBar','\\u2959':'LeftDownVectorBar','\\u295A':'LeftTeeVector','\\u295B':'RightTeeVector','\\u295C':'RightUpTeeVector','\\u295D':'RightDownTeeVector','\\u295E':'DownLeftTeeVector','\\u295F':'DownRightTeeVector','\\u2960':'LeftUpTeeVector','\\u2961':'LeftDownTeeVector','\\u2962':'lHar','\\u2963':'uHar','\\u2964':'rHar','\\u2965':'dHar','\\u2966':'luruhar','\\u2967':'ldrdhar','\\u2968':'ruluhar','\\u2969':'rdldhar','\\u296A':'lharul','\\u296B':'llhard','\\u296C':'rharul','\\u296D':'lrhard','\\u296E':'udhar','\\u296F':'duhar','\\u2970':'RoundImplies','\\u2971':'erarr','\\u2972':'simrarr','\\u2973':'larrsim','\\u2974':'rarrsim','\\u2975':'rarrap','\\u2976':'ltlarr','\\u2978':'gtrarr','\\u2979':'subrarr','\\u297B':'suplarr','\\u297C':'lfisht','\\u297D':'rfisht','\\u297E':'ufisht','\\u297F':'dfisht','\\u299A':'vzigzag','\\u299C':'vangrt','\\u299D':'angrtvbd','\\u29A4':'ange','\\u29A5':'range','\\u29A6':'dwangle','\\u29A7':'uwangle','\\u29A8':'angmsdaa','\\u29A9':'angmsdab','\\u29AA':'angmsdac','\\u29AB':'angmsdad','\\u29AC':'angmsdae','\\u29AD':'angmsdaf','\\u29AE':'angmsdag','\\u29AF':'angmsdah','\\u29B0':'bemptyv','\\u29B1':'demptyv','\\u29B2':'cemptyv','\\u29B3':'raemptyv','\\u29B4':'laemptyv','\\u29B5':'ohbar','\\u29B6':'omid','\\u29B7':'opar','\\u29B9':'operp','\\u29BB':'olcross','\\u29BC':'odsold','\\u29BE':'olcir','\\u29BF':'ofcir','\\u29C0':'olt','\\u29C1':'ogt','\\u29C2':'cirscir','\\u29C3':'cirE','\\u29C4':'solb','\\u29C5':'bsolb','\\u29C9':'boxbox','\\u29CD':'trisb','\\u29CE':'rtriltri','\\u29CF':'LeftTriangleBar','\\u29CF\\u0338':'NotLeftTriangleBar','\\u29D0':'RightTriangleBar','\\u29D0\\u0338':'NotRightTriangleBar','\\u29DC':'iinfin','\\u29DD':'infintie','\\u29DE':'nvinfin','\\u29E3':'eparsl','\\u29E4':'smeparsl','\\u29E5':'eqvparsl','\\u29EB':'lozf','\\u29F4':'RuleDelayed','\\u29F6':'dsol','\\u2A00':'xodot','\\u2A01':'xoplus','\\u2A02':'xotime','\\u2A04':'xuplus','\\u2A06':'xsqcup','\\u2A0D':'fpartint','\\u2A10':'cirfnint','\\u2A11':'awint','\\u2A12':'rppolint','\\u2A13':'scpolint','\\u2A14':'npolint','\\u2A15':'pointint','\\u2A16':'quatint','\\u2A17':'intlarhk','\\u2A22':'pluscir','\\u2A23':'plusacir','\\u2A24':'simplus','\\u2A25':'plusdu','\\u2A26':'plussim','\\u2A27':'plustwo','\\u2A29':'mcomma','\\u2A2A':'minusdu','\\u2A2D':'loplus','\\u2A2E':'roplus','\\u2A2F':'Cross','\\u2A30':'timesd','\\u2A31':'timesbar','\\u2A33':'smashp','\\u2A34':'lotimes','\\u2A35':'rotimes','\\u2A36':'otimesas','\\u2A37':'Otimes','\\u2A38':'odiv','\\u2A39':'triplus','\\u2A3A':'triminus','\\u2A3B':'tritime','\\u2A3C':'iprod','\\u2A3F':'amalg','\\u2A40':'capdot','\\u2A42':'ncup','\\u2A43':'ncap','\\u2A44':'capand','\\u2A45':'cupor','\\u2A46':'cupcap','\\u2A47':'capcup','\\u2A48':'cupbrcap','\\u2A49':'capbrcup','\\u2A4A':'cupcup','\\u2A4B':'capcap','\\u2A4C':'ccups','\\u2A4D':'ccaps','\\u2A50':'ccupssm','\\u2A53':'And','\\u2A54':'Or','\\u2A55':'andand','\\u2A56':'oror','\\u2A57':'orslope','\\u2A58':'andslope','\\u2A5A':'andv','\\u2A5B':'orv','\\u2A5C':'andd','\\u2A5D':'ord','\\u2A5F':'wedbar','\\u2A66':'sdote','\\u2A6A':'simdot','\\u2A6D':'congdot','\\u2A6D\\u0338':'ncongdot','\\u2A6E':'easter','\\u2A6F':'apacir','\\u2A70':'apE','\\u2A70\\u0338':'napE','\\u2A71':'eplus','\\u2A72':'pluse','\\u2A73':'Esim','\\u2A77':'eDDot','\\u2A78':'equivDD','\\u2A79':'ltcir','\\u2A7A':'gtcir','\\u2A7B':'ltquest','\\u2A7C':'gtquest','\\u2A7D':'les','\\u2A7D\\u0338':'nles','\\u2A7E':'ges','\\u2A7E\\u0338':'nges','\\u2A7F':'lesdot','\\u2A80':'gesdot','\\u2A81':'lesdoto','\\u2A82':'gesdoto','\\u2A83':'lesdotor','\\u2A84':'gesdotol','\\u2A85':'lap','\\u2A86':'gap','\\u2A87':'lne','\\u2A88':'gne','\\u2A89':'lnap','\\u2A8A':'gnap','\\u2A8B':'lEg','\\u2A8C':'gEl','\\u2A8D':'lsime','\\u2A8E':'gsime','\\u2A8F':'lsimg','\\u2A90':'gsiml','\\u2A91':'lgE','\\u2A92':'glE','\\u2A93':'lesges','\\u2A94':'gesles','\\u2A95':'els','\\u2A96':'egs','\\u2A97':'elsdot','\\u2A98':'egsdot','\\u2A99':'el','\\u2A9A':'eg','\\u2A9D':'siml','\\u2A9E':'simg','\\u2A9F':'simlE','\\u2AA0':'simgE','\\u2AA1':'LessLess','\\u2AA1\\u0338':'NotNestedLessLess','\\u2AA2':'GreaterGreater','\\u2AA2\\u0338':'NotNestedGreaterGreater','\\u2AA4':'glj','\\u2AA5':'gla','\\u2AA6':'ltcc','\\u2AA7':'gtcc','\\u2AA8':'lescc','\\u2AA9':'gescc','\\u2AAA':'smt','\\u2AAB':'lat','\\u2AAC':'smte','\\u2AAC\\uFE00':'smtes','\\u2AAD':'late','\\u2AAD\\uFE00':'lates','\\u2AAE':'bumpE','\\u2AAF':'pre','\\u2AAF\\u0338':'npre','\\u2AB0':'sce','\\u2AB0\\u0338':'nsce','\\u2AB3':'prE','\\u2AB4':'scE','\\u2AB5':'prnE','\\u2AB6':'scnE','\\u2AB7':'prap','\\u2AB8':'scap','\\u2AB9':'prnap','\\u2ABA':'scnap','\\u2ABB':'Pr','\\u2ABC':'Sc','\\u2ABD':'subdot','\\u2ABE':'supdot','\\u2ABF':'subplus','\\u2AC0':'supplus','\\u2AC1':'submult','\\u2AC2':'supmult','\\u2AC3':'subedot','\\u2AC4':'supedot','\\u2AC5':'subE','\\u2AC5\\u0338':'nsubE','\\u2AC6':'supE','\\u2AC6\\u0338':'nsupE','\\u2AC7':'subsim','\\u2AC8':'supsim','\\u2ACB\\uFE00':'vsubnE','\\u2ACB':'subnE','\\u2ACC\\uFE00':'vsupnE','\\u2ACC':'supnE','\\u2ACF':'csub','\\u2AD0':'csup','\\u2AD1':'csube','\\u2AD2':'csupe','\\u2AD3':'subsup','\\u2AD4':'supsub','\\u2AD5':'subsub','\\u2AD6':'supsup','\\u2AD7':'suphsub','\\u2AD8':'supdsub','\\u2AD9':'forkv','\\u2ADA':'topfork','\\u2ADB':'mlcp','\\u2AE4':'Dashv','\\u2AE6':'Vdashl','\\u2AE7':'Barv','\\u2AE8':'vBar','\\u2AE9':'vBarv','\\u2AEB':'Vbar','\\u2AEC':'Not','\\u2AED':'bNot','\\u2AEE':'rnmid','\\u2AEF':'cirmid','\\u2AF0':'midcir','\\u2AF1':'topcir','\\u2AF2':'nhpar','\\u2AF3':'parsim','\\u2AFD':'parsl','\\u2AFD\\u20E5':'nparsl','\\u266D':'flat','\\u266E':'natur','\\u266F':'sharp','\\xA4':'curren','\\xA2':'cent','$':'dollar','\\xA3':'pound','\\xA5':'yen','\\u20AC':'euro','\\xB9':'sup1','\\xBD':'half','\\u2153':'frac13','\\xBC':'frac14','\\u2155':'frac15','\\u2159':'frac16','\\u215B':'frac18','\\xB2':'sup2','\\u2154':'frac23','\\u2156':'frac25','\\xB3':'sup3','\\xBE':'frac34','\\u2157':'frac35','\\u215C':'frac38','\\u2158':'frac45','\\u215A':'frac56','\\u215D':'frac58','\\u215E':'frac78','\\uD835\\uDCB6':'ascr','\\uD835\\uDD52':'aopf','\\uD835\\uDD1E':'afr','\\uD835\\uDD38':'Aopf','\\uD835\\uDD04':'Afr','\\uD835\\uDC9C':'Ascr','\\xAA':'ordf','\\xE1':'aacute','\\xC1':'Aacute','\\xE0':'agrave','\\xC0':'Agrave','\\u0103':'abreve','\\u0102':'Abreve','\\xE2':'acirc','\\xC2':'Acirc','\\xE5':'aring','\\xC5':'angst','\\xE4':'auml','\\xC4':'Auml','\\xE3':'atilde','\\xC3':'Atilde','\\u0105':'aogon','\\u0104':'Aogon','\\u0101':'amacr','\\u0100':'Amacr','\\xE6':'aelig','\\xC6':'AElig','\\uD835\\uDCB7':'bscr','\\uD835\\uDD53':'bopf','\\uD835\\uDD1F':'bfr','\\uD835\\uDD39':'Bopf','\\u212C':'Bscr','\\uD835\\uDD05':'Bfr','\\uD835\\uDD20':'cfr','\\uD835\\uDCB8':'cscr','\\uD835\\uDD54':'copf','\\u212D':'Cfr','\\uD835\\uDC9E':'Cscr','\\u2102':'Copf','\\u0107':'cacute','\\u0106':'Cacute','\\u0109':'ccirc','\\u0108':'Ccirc','\\u010D':'ccaron','\\u010C':'Ccaron','\\u010B':'cdot','\\u010A':'Cdot','\\xE7':'ccedil','\\xC7':'Ccedil','\\u2105':'incare','\\uD835\\uDD21':'dfr','\\u2146':'dd','\\uD835\\uDD55':'dopf','\\uD835\\uDCB9':'dscr','\\uD835\\uDC9F':'Dscr','\\uD835\\uDD07':'Dfr','\\u2145':'DD','\\uD835\\uDD3B':'Dopf','\\u010F':'dcaron','\\u010E':'Dcaron','\\u0111':'dstrok','\\u0110':'Dstrok','\\xF0':'eth','\\xD0':'ETH','\\u2147':'ee','\\u212F':'escr','\\uD835\\uDD22':'efr','\\uD835\\uDD56':'eopf','\\u2130':'Escr','\\uD835\\uDD08':'Efr','\\uD835\\uDD3C':'Eopf','\\xE9':'eacute','\\xC9':'Eacute','\\xE8':'egrave','\\xC8':'Egrave','\\xEA':'ecirc','\\xCA':'Ecirc','\\u011B':'ecaron','\\u011A':'Ecaron','\\xEB':'euml','\\xCB':'Euml','\\u0117':'edot','\\u0116':'Edot','\\u0119':'eogon','\\u0118':'Eogon','\\u0113':'emacr','\\u0112':'Emacr','\\uD835\\uDD23':'ffr','\\uD835\\uDD57':'fopf','\\uD835\\uDCBB':'fscr','\\uD835\\uDD09':'Ffr','\\uD835\\uDD3D':'Fopf','\\u2131':'Fscr','\\uFB00':'fflig','\\uFB03':'ffilig','\\uFB04':'ffllig','\\uFB01':'filig','fj':'fjlig','\\uFB02':'fllig','\\u0192':'fnof','\\u210A':'gscr','\\uD835\\uDD58':'gopf','\\uD835\\uDD24':'gfr','\\uD835\\uDCA2':'Gscr','\\uD835\\uDD3E':'Gopf','\\uD835\\uDD0A':'Gfr','\\u01F5':'gacute','\\u011F':'gbreve','\\u011E':'Gbreve','\\u011D':'gcirc','\\u011C':'Gcirc','\\u0121':'gdot','\\u0120':'Gdot','\\u0122':'Gcedil','\\uD835\\uDD25':'hfr','\\u210E':'planckh','\\uD835\\uDCBD':'hscr','\\uD835\\uDD59':'hopf','\\u210B':'Hscr','\\u210C':'Hfr','\\u210D':'Hopf','\\u0125':'hcirc','\\u0124':'Hcirc','\\u210F':'hbar','\\u0127':'hstrok','\\u0126':'Hstrok','\\uD835\\uDD5A':'iopf','\\uD835\\uDD26':'ifr','\\uD835\\uDCBE':'iscr','\\u2148':'ii','\\uD835\\uDD40':'Iopf','\\u2110':'Iscr','\\u2111':'Im','\\xED':'iacute','\\xCD':'Iacute','\\xEC':'igrave','\\xCC':'Igrave','\\xEE':'icirc','\\xCE':'Icirc','\\xEF':'iuml','\\xCF':'Iuml','\\u0129':'itilde','\\u0128':'Itilde','\\u0130':'Idot','\\u012F':'iogon','\\u012E':'Iogon','\\u012B':'imacr','\\u012A':'Imacr','\\u0133':'ijlig','\\u0132':'IJlig','\\u0131':'imath','\\uD835\\uDCBF':'jscr','\\uD835\\uDD5B':'jopf','\\uD835\\uDD27':'jfr','\\uD835\\uDCA5':'Jscr','\\uD835\\uDD0D':'Jfr','\\uD835\\uDD41':'Jopf','\\u0135':'jcirc','\\u0134':'Jcirc','\\u0237':'jmath','\\uD835\\uDD5C':'kopf','\\uD835\\uDCC0':'kscr','\\uD835\\uDD28':'kfr','\\uD835\\uDCA6':'Kscr','\\uD835\\uDD42':'Kopf','\\uD835\\uDD0E':'Kfr','\\u0137':'kcedil','\\u0136':'Kcedil','\\uD835\\uDD29':'lfr','\\uD835\\uDCC1':'lscr','\\u2113':'ell','\\uD835\\uDD5D':'lopf','\\u2112':'Lscr','\\uD835\\uDD0F':'Lfr','\\uD835\\uDD43':'Lopf','\\u013A':'lacute','\\u0139':'Lacute','\\u013E':'lcaron','\\u013D':'Lcaron','\\u013C':'lcedil','\\u013B':'Lcedil','\\u0142':'lstrok','\\u0141':'Lstrok','\\u0140':'lmidot','\\u013F':'Lmidot','\\uD835\\uDD2A':'mfr','\\uD835\\uDD5E':'mopf','\\uD835\\uDCC2':'mscr','\\uD835\\uDD10':'Mfr','\\uD835\\uDD44':'Mopf','\\u2133':'Mscr','\\uD835\\uDD2B':'nfr','\\uD835\\uDD5F':'nopf','\\uD835\\uDCC3':'nscr','\\u2115':'Nopf','\\uD835\\uDCA9':'Nscr','\\uD835\\uDD11':'Nfr','\\u0144':'nacute','\\u0143':'Nacute','\\u0148':'ncaron','\\u0147':'Ncaron','\\xF1':'ntilde','\\xD1':'Ntilde','\\u0146':'ncedil','\\u0145':'Ncedil','\\u2116':'numero','\\u014B':'eng','\\u014A':'ENG','\\uD835\\uDD60':'oopf','\\uD835\\uDD2C':'ofr','\\u2134':'oscr','\\uD835\\uDCAA':'Oscr','\\uD835\\uDD12':'Ofr','\\uD835\\uDD46':'Oopf','\\xBA':'ordm','\\xF3':'oacute','\\xD3':'Oacute','\\xF2':'ograve','\\xD2':'Ograve','\\xF4':'ocirc','\\xD4':'Ocirc','\\xF6':'ouml','\\xD6':'Ouml','\\u0151':'odblac','\\u0150':'Odblac','\\xF5':'otilde','\\xD5':'Otilde','\\xF8':'oslash','\\xD8':'Oslash','\\u014D':'omacr','\\u014C':'Omacr','\\u0153':'oelig','\\u0152':'OElig','\\uD835\\uDD2D':'pfr','\\uD835\\uDCC5':'pscr','\\uD835\\uDD61':'popf','\\u2119':'Popf','\\uD835\\uDD13':'Pfr','\\uD835\\uDCAB':'Pscr','\\uD835\\uDD62':'qopf','\\uD835\\uDD2E':'qfr','\\uD835\\uDCC6':'qscr','\\uD835\\uDCAC':'Qscr','\\uD835\\uDD14':'Qfr','\\u211A':'Qopf','\\u0138':'kgreen','\\uD835\\uDD2F':'rfr','\\uD835\\uDD63':'ropf','\\uD835\\uDCC7':'rscr','\\u211B':'Rscr','\\u211C':'Re','\\u211D':'Ropf','\\u0155':'racute','\\u0154':'Racute','\\u0159':'rcaron','\\u0158':'Rcaron','\\u0157':'rcedil','\\u0156':'Rcedil','\\uD835\\uDD64':'sopf','\\uD835\\uDCC8':'sscr','\\uD835\\uDD30':'sfr','\\uD835\\uDD4A':'Sopf','\\uD835\\uDD16':'Sfr','\\uD835\\uDCAE':'Sscr','\\u24C8':'oS','\\u015B':'sacute','\\u015A':'Sacute','\\u015D':'scirc','\\u015C':'Scirc','\\u0161':'scaron','\\u0160':'Scaron','\\u015F':'scedil','\\u015E':'Scedil','\\xDF':'szlig','\\uD835\\uDD31':'tfr','\\uD835\\uDCC9':'tscr','\\uD835\\uDD65':'topf','\\uD835\\uDCAF':'Tscr','\\uD835\\uDD17':'Tfr','\\uD835\\uDD4B':'Topf','\\u0165':'tcaron','\\u0164':'Tcaron','\\u0163':'tcedil','\\u0162':'Tcedil','\\u2122':'trade','\\u0167':'tstrok','\\u0166':'Tstrok','\\uD835\\uDCCA':'uscr','\\uD835\\uDD66':'uopf','\\uD835\\uDD32':'ufr','\\uD835\\uDD4C':'Uopf','\\uD835\\uDD18':'Ufr','\\uD835\\uDCB0':'Uscr','\\xFA':'uacute','\\xDA':'Uacute','\\xF9':'ugrave','\\xD9':'Ugrave','\\u016D':'ubreve','\\u016C':'Ubreve','\\xFB':'ucirc','\\xDB':'Ucirc','\\u016F':'uring','\\u016E':'Uring','\\xFC':'uuml','\\xDC':'Uuml','\\u0171':'udblac','\\u0170':'Udblac','\\u0169':'utilde','\\u0168':'Utilde','\\u0173':'uogon','\\u0172':'Uogon','\\u016B':'umacr','\\u016A':'Umacr','\\uD835\\uDD33':'vfr','\\uD835\\uDD67':'vopf','\\uD835\\uDCCB':'vscr','\\uD835\\uDD19':'Vfr','\\uD835\\uDD4D':'Vopf','\\uD835\\uDCB1':'Vscr','\\uD835\\uDD68':'wopf','\\uD835\\uDCCC':'wscr','\\uD835\\uDD34':'wfr','\\uD835\\uDCB2':'Wscr','\\uD835\\uDD4E':'Wopf','\\uD835\\uDD1A':'Wfr','\\u0175':'wcirc','\\u0174':'Wcirc','\\uD835\\uDD35':'xfr','\\uD835\\uDCCD':'xscr','\\uD835\\uDD69':'xopf','\\uD835\\uDD4F':'Xopf','\\uD835\\uDD1B':'Xfr','\\uD835\\uDCB3':'Xscr','\\uD835\\uDD36':'yfr','\\uD835\\uDCCE':'yscr','\\uD835\\uDD6A':'yopf','\\uD835\\uDCB4':'Yscr','\\uD835\\uDD1C':'Yfr','\\uD835\\uDD50':'Yopf','\\xFD':'yacute','\\xDD':'Yacute','\\u0177':'ycirc','\\u0176':'Ycirc','\\xFF':'yuml','\\u0178':'Yuml','\\uD835\\uDCCF':'zscr','\\uD835\\uDD37':'zfr','\\uD835\\uDD6B':'zopf','\\u2128':'Zfr','\\u2124':'Zopf','\\uD835\\uDCB5':'Zscr','\\u017A':'zacute','\\u0179':'Zacute','\\u017E':'zcaron','\\u017D':'Zcaron','\\u017C':'zdot','\\u017B':'Zdot','\\u01B5':'imped','\\xFE':'thorn','\\xDE':'THORN','\\u0149':'napos','\\u03B1':'alpha','\\u0391':'Alpha','\\u03B2':'beta','\\u0392':'Beta','\\u03B3':'gamma','\\u0393':'Gamma','\\u03B4':'delta','\\u0394':'Delta','\\u03B5':'epsi','\\u03F5':'epsiv','\\u0395':'Epsilon','\\u03DD':'gammad','\\u03DC':'Gammad','\\u03B6':'zeta','\\u0396':'Zeta','\\u03B7':'eta','\\u0397':'Eta','\\u03B8':'theta','\\u03D1':'thetav','\\u0398':'Theta','\\u03B9':'iota','\\u0399':'Iota','\\u03BA':'kappa','\\u03F0':'kappav','\\u039A':'Kappa','\\u03BB':'lambda','\\u039B':'Lambda','\\u03BC':'mu','\\xB5':'micro','\\u039C':'Mu','\\u03BD':'nu','\\u039D':'Nu','\\u03BE':'xi','\\u039E':'Xi','\\u03BF':'omicron','\\u039F':'Omicron','\\u03C0':'pi','\\u03D6':'piv','\\u03A0':'Pi','\\u03C1':'rho','\\u03F1':'rhov','\\u03A1':'Rho','\\u03C3':'sigma','\\u03A3':'Sigma','\\u03C2':'sigmaf','\\u03C4':'tau','\\u03A4':'Tau','\\u03C5':'upsi','\\u03A5':'Upsilon','\\u03D2':'Upsi','\\u03C6':'phi','\\u03D5':'phiv','\\u03A6':'Phi','\\u03C7':'chi','\\u03A7':'Chi','\\u03C8':'psi','\\u03A8':'Psi','\\u03C9':'omega','\\u03A9':'ohm','\\u0430':'acy','\\u0410':'Acy','\\u0431':'bcy','\\u0411':'Bcy','\\u0432':'vcy','\\u0412':'Vcy','\\u0433':'gcy','\\u0413':'Gcy','\\u0453':'gjcy','\\u0403':'GJcy','\\u0434':'dcy','\\u0414':'Dcy','\\u0452':'djcy','\\u0402':'DJcy','\\u0435':'iecy','\\u0415':'IEcy','\\u0451':'iocy','\\u0401':'IOcy','\\u0454':'jukcy','\\u0404':'Jukcy','\\u0436':'zhcy','\\u0416':'ZHcy','\\u0437':'zcy','\\u0417':'Zcy','\\u0455':'dscy','\\u0405':'DScy','\\u0438':'icy','\\u0418':'Icy','\\u0456':'iukcy','\\u0406':'Iukcy','\\u0457':'yicy','\\u0407':'YIcy','\\u0439':'jcy','\\u0419':'Jcy','\\u0458':'jsercy','\\u0408':'Jsercy','\\u043A':'kcy','\\u041A':'Kcy','\\u045C':'kjcy','\\u040C':'KJcy','\\u043B':'lcy','\\u041B':'Lcy','\\u0459':'ljcy','\\u0409':'LJcy','\\u043C':'mcy','\\u041C':'Mcy','\\u043D':'ncy','\\u041D':'Ncy','\\u045A':'njcy','\\u040A':'NJcy','\\u043E':'ocy','\\u041E':'Ocy','\\u043F':'pcy','\\u041F':'Pcy','\\u0440':'rcy','\\u0420':'Rcy','\\u0441':'scy','\\u0421':'Scy','\\u0442':'tcy','\\u0422':'Tcy','\\u045B':'tshcy','\\u040B':'TSHcy','\\u0443':'ucy','\\u0423':'Ucy','\\u045E':'ubrcy','\\u040E':'Ubrcy','\\u0444':'fcy','\\u0424':'Fcy','\\u0445':'khcy','\\u0425':'KHcy','\\u0446':'tscy','\\u0426':'TScy','\\u0447':'chcy','\\u0427':'CHcy','\\u045F':'dzcy','\\u040F':'DZcy','\\u0448':'shcy','\\u0428':'SHcy','\\u0449':'shchcy','\\u0429':'SHCHcy','\\u044A':'hardcy','\\u042A':'HARDcy','\\u044B':'ycy','\\u042B':'Ycy','\\u044C':'softcy','\\u042C':'SOFTcy','\\u044D':'ecy','\\u042D':'Ecy','\\u044E':'yucy','\\u042E':'YUcy','\\u044F':'yacy','\\u042F':'YAcy','\\u2135':'aleph','\\u2136':'beth','\\u2137':'gimel','\\u2138':'daleth'};\n\n\tvar regexEscape = /[\"&'<>`]/g;\n\tvar escapeMap = {\n\t\t'\"': '&quot;',\n\t\t'&': '&amp;',\n\t\t'\\'': '&#x27;',\n\t\t'<': '&lt;',\n\t\t// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the\n\t\t// following is not strictly necessary unless it’s part of a tag or an\n\t\t// unquoted attribute value. We’re only escaping it to support those\n\t\t// situations, and for XML support.\n\t\t'>': '&gt;',\n\t\t// In Internet Explorer ≤ 8, the backtick character can be used\n\t\t// to break out of (un)quoted attribute values or HTML comments.\n\t\t// See http://html5sec.org/#102, http://html5sec.org/#108, and\n\t\t// http://html5sec.org/#133.\n\t\t'`': '&#x60;'\n\t};\n\n\tvar regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;\n\tvar regexInvalidRawCodePoint = /[\\0-\\x08\\x0B\\x0E-\\x1F\\x7F-\\x9F\\uFDD0-\\uFDEF\\uFFFE\\uFFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F\\uDBBF\\uDBFF][\\uDFFE\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n\tvar regexDecode = /&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)([=a-zA-Z0-9])?/g;\n\tvar decodeMap = {'aacute':'\\xE1','Aacute':'\\xC1','abreve':'\\u0103','Abreve':'\\u0102','ac':'\\u223E','acd':'\\u223F','acE':'\\u223E\\u0333','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','acy':'\\u0430','Acy':'\\u0410','aelig':'\\xE6','AElig':'\\xC6','af':'\\u2061','afr':'\\uD835\\uDD1E','Afr':'\\uD835\\uDD04','agrave':'\\xE0','Agrave':'\\xC0','alefsym':'\\u2135','aleph':'\\u2135','alpha':'\\u03B1','Alpha':'\\u0391','amacr':'\\u0101','Amacr':'\\u0100','amalg':'\\u2A3F','amp':'&','AMP':'&','and':'\\u2227','And':'\\u2A53','andand':'\\u2A55','andd':'\\u2A5C','andslope':'\\u2A58','andv':'\\u2A5A','ang':'\\u2220','ange':'\\u29A4','angle':'\\u2220','angmsd':'\\u2221','angmsdaa':'\\u29A8','angmsdab':'\\u29A9','angmsdac':'\\u29AA','angmsdad':'\\u29AB','angmsdae':'\\u29AC','angmsdaf':'\\u29AD','angmsdag':'\\u29AE','angmsdah':'\\u29AF','angrt':'\\u221F','angrtvb':'\\u22BE','angrtvbd':'\\u299D','angsph':'\\u2222','angst':'\\xC5','angzarr':'\\u237C','aogon':'\\u0105','Aogon':'\\u0104','aopf':'\\uD835\\uDD52','Aopf':'\\uD835\\uDD38','ap':'\\u2248','apacir':'\\u2A6F','ape':'\\u224A','apE':'\\u2A70','apid':'\\u224B','apos':'\\'','ApplyFunction':'\\u2061','approx':'\\u2248','approxeq':'\\u224A','aring':'\\xE5','Aring':'\\xC5','ascr':'\\uD835\\uDCB6','Ascr':'\\uD835\\uDC9C','Assign':'\\u2254','ast':'*','asymp':'\\u2248','asympeq':'\\u224D','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','awconint':'\\u2233','awint':'\\u2A11','backcong':'\\u224C','backepsilon':'\\u03F6','backprime':'\\u2035','backsim':'\\u223D','backsimeq':'\\u22CD','Backslash':'\\u2216','Barv':'\\u2AE7','barvee':'\\u22BD','barwed':'\\u2305','Barwed':'\\u2306','barwedge':'\\u2305','bbrk':'\\u23B5','bbrktbrk':'\\u23B6','bcong':'\\u224C','bcy':'\\u0431','Bcy':'\\u0411','bdquo':'\\u201E','becaus':'\\u2235','because':'\\u2235','Because':'\\u2235','bemptyv':'\\u29B0','bepsi':'\\u03F6','bernou':'\\u212C','Bernoullis':'\\u212C','beta':'\\u03B2','Beta':'\\u0392','beth':'\\u2136','between':'\\u226C','bfr':'\\uD835\\uDD1F','Bfr':'\\uD835\\uDD05','bigcap':'\\u22C2','bigcirc':'\\u25EF','bigcup':'\\u22C3','bigodot':'\\u2A00','bigoplus':'\\u2A01','bigotimes':'\\u2A02','bigsqcup':'\\u2A06','bigstar':'\\u2605','bigtriangledown':'\\u25BD','bigtriangleup':'\\u25B3','biguplus':'\\u2A04','bigvee':'\\u22C1','bigwedge':'\\u22C0','bkarow':'\\u290D','blacklozenge':'\\u29EB','blacksquare':'\\u25AA','blacktriangle':'\\u25B4','blacktriangledown':'\\u25BE','blacktriangleleft':'\\u25C2','blacktriangleright':'\\u25B8','blank':'\\u2423','blk12':'\\u2592','blk14':'\\u2591','blk34':'\\u2593','block':'\\u2588','bne':'=\\u20E5','bnequiv':'\\u2261\\u20E5','bnot':'\\u2310','bNot':'\\u2AED','bopf':'\\uD835\\uDD53','Bopf':'\\uD835\\uDD39','bot':'\\u22A5','bottom':'\\u22A5','bowtie':'\\u22C8','boxbox':'\\u29C9','boxdl':'\\u2510','boxdL':'\\u2555','boxDl':'\\u2556','boxDL':'\\u2557','boxdr':'\\u250C','boxdR':'\\u2552','boxDr':'\\u2553','boxDR':'\\u2554','boxh':'\\u2500','boxH':'\\u2550','boxhd':'\\u252C','boxhD':'\\u2565','boxHd':'\\u2564','boxHD':'\\u2566','boxhu':'\\u2534','boxhU':'\\u2568','boxHu':'\\u2567','boxHU':'\\u2569','boxminus':'\\u229F','boxplus':'\\u229E','boxtimes':'\\u22A0','boxul':'\\u2518','boxuL':'\\u255B','boxUl':'\\u255C','boxUL':'\\u255D','boxur':'\\u2514','boxuR':'\\u2558','boxUr':'\\u2559','boxUR':'\\u255A','boxv':'\\u2502','boxV':'\\u2551','boxvh':'\\u253C','boxvH':'\\u256A','boxVh':'\\u256B','boxVH':'\\u256C','boxvl':'\\u2524','boxvL':'\\u2561','boxVl':'\\u2562','boxVL':'\\u2563','boxvr':'\\u251C','boxvR':'\\u255E','boxVr':'\\u255F','boxVR':'\\u2560','bprime':'\\u2035','breve':'\\u02D8','Breve':'\\u02D8','brvbar':'\\xA6','bscr':'\\uD835\\uDCB7','Bscr':'\\u212C','bsemi':'\\u204F','bsim':'\\u223D','bsime':'\\u22CD','bsol':'\\\\','bsolb':'\\u29C5','bsolhsub':'\\u27C8','bull':'\\u2022','bullet':'\\u2022','bump':'\\u224E','bumpe':'\\u224F','bumpE':'\\u2AAE','bumpeq':'\\u224F','Bumpeq':'\\u224E','cacute':'\\u0107','Cacute':'\\u0106','cap':'\\u2229','Cap':'\\u22D2','capand':'\\u2A44','capbrcup':'\\u2A49','capcap':'\\u2A4B','capcup':'\\u2A47','capdot':'\\u2A40','CapitalDifferentialD':'\\u2145','caps':'\\u2229\\uFE00','caret':'\\u2041','caron':'\\u02C7','Cayleys':'\\u212D','ccaps':'\\u2A4D','ccaron':'\\u010D','Ccaron':'\\u010C','ccedil':'\\xE7','Ccedil':'\\xC7','ccirc':'\\u0109','Ccirc':'\\u0108','Cconint':'\\u2230','ccups':'\\u2A4C','ccupssm':'\\u2A50','cdot':'\\u010B','Cdot':'\\u010A','cedil':'\\xB8','Cedilla':'\\xB8','cemptyv':'\\u29B2','cent':'\\xA2','centerdot':'\\xB7','CenterDot':'\\xB7','cfr':'\\uD835\\uDD20','Cfr':'\\u212D','chcy':'\\u0447','CHcy':'\\u0427','check':'\\u2713','checkmark':'\\u2713','chi':'\\u03C7','Chi':'\\u03A7','cir':'\\u25CB','circ':'\\u02C6','circeq':'\\u2257','circlearrowleft':'\\u21BA','circlearrowright':'\\u21BB','circledast':'\\u229B','circledcirc':'\\u229A','circleddash':'\\u229D','CircleDot':'\\u2299','circledR':'\\xAE','circledS':'\\u24C8','CircleMinus':'\\u2296','CirclePlus':'\\u2295','CircleTimes':'\\u2297','cire':'\\u2257','cirE':'\\u29C3','cirfnint':'\\u2A10','cirmid':'\\u2AEF','cirscir':'\\u29C2','ClockwiseContourIntegral':'\\u2232','CloseCurlyDoubleQuote':'\\u201D','CloseCurlyQuote':'\\u2019','clubs':'\\u2663','clubsuit':'\\u2663','colon':':','Colon':'\\u2237','colone':'\\u2254','Colone':'\\u2A74','coloneq':'\\u2254','comma':',','commat':'@','comp':'\\u2201','compfn':'\\u2218','complement':'\\u2201','complexes':'\\u2102','cong':'\\u2245','congdot':'\\u2A6D','Congruent':'\\u2261','conint':'\\u222E','Conint':'\\u222F','ContourIntegral':'\\u222E','copf':'\\uD835\\uDD54','Copf':'\\u2102','coprod':'\\u2210','Coproduct':'\\u2210','copy':'\\xA9','COPY':'\\xA9','copysr':'\\u2117','CounterClockwiseContourIntegral':'\\u2233','crarr':'\\u21B5','cross':'\\u2717','Cross':'\\u2A2F','cscr':'\\uD835\\uDCB8','Cscr':'\\uD835\\uDC9E','csub':'\\u2ACF','csube':'\\u2AD1','csup':'\\u2AD0','csupe':'\\u2AD2','ctdot':'\\u22EF','cudarrl':'\\u2938','cudarrr':'\\u2935','cuepr':'\\u22DE','cuesc':'\\u22DF','cularr':'\\u21B6','cularrp':'\\u293D','cup':'\\u222A','Cup':'\\u22D3','cupbrcap':'\\u2A48','cupcap':'\\u2A46','CupCap':'\\u224D','cupcup':'\\u2A4A','cupdot':'\\u228D','cupor':'\\u2A45','cups':'\\u222A\\uFE00','curarr':'\\u21B7','curarrm':'\\u293C','curlyeqprec':'\\u22DE','curlyeqsucc':'\\u22DF','curlyvee':'\\u22CE','curlywedge':'\\u22CF','curren':'\\xA4','curvearrowleft':'\\u21B6','curvearrowright':'\\u21B7','cuvee':'\\u22CE','cuwed':'\\u22CF','cwconint':'\\u2232','cwint':'\\u2231','cylcty':'\\u232D','dagger':'\\u2020','Dagger':'\\u2021','daleth':'\\u2138','darr':'\\u2193','dArr':'\\u21D3','Darr':'\\u21A1','dash':'\\u2010','dashv':'\\u22A3','Dashv':'\\u2AE4','dbkarow':'\\u290F','dblac':'\\u02DD','dcaron':'\\u010F','Dcaron':'\\u010E','dcy':'\\u0434','Dcy':'\\u0414','dd':'\\u2146','DD':'\\u2145','ddagger':'\\u2021','ddarr':'\\u21CA','DDotrahd':'\\u2911','ddotseq':'\\u2A77','deg':'\\xB0','Del':'\\u2207','delta':'\\u03B4','Delta':'\\u0394','demptyv':'\\u29B1','dfisht':'\\u297F','dfr':'\\uD835\\uDD21','Dfr':'\\uD835\\uDD07','dHar':'\\u2965','dharl':'\\u21C3','dharr':'\\u21C2','DiacriticalAcute':'\\xB4','DiacriticalDot':'\\u02D9','DiacriticalDoubleAcute':'\\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\\u02DC','diam':'\\u22C4','diamond':'\\u22C4','Diamond':'\\u22C4','diamondsuit':'\\u2666','diams':'\\u2666','die':'\\xA8','DifferentialD':'\\u2146','digamma':'\\u03DD','disin':'\\u22F2','div':'\\xF7','divide':'\\xF7','divideontimes':'\\u22C7','divonx':'\\u22C7','djcy':'\\u0452','DJcy':'\\u0402','dlcorn':'\\u231E','dlcrop':'\\u230D','dollar':'$','dopf':'\\uD835\\uDD55','Dopf':'\\uD835\\uDD3B','dot':'\\u02D9','Dot':'\\xA8','DotDot':'\\u20DC','doteq':'\\u2250','doteqdot':'\\u2251','DotEqual':'\\u2250','dotminus':'\\u2238','dotplus':'\\u2214','dotsquare':'\\u22A1','doublebarwedge':'\\u2306','DoubleContourIntegral':'\\u222F','DoubleDot':'\\xA8','DoubleDownArrow':'\\u21D3','DoubleLeftArrow':'\\u21D0','DoubleLeftRightArrow':'\\u21D4','DoubleLeftTee':'\\u2AE4','DoubleLongLeftArrow':'\\u27F8','DoubleLongLeftRightArrow':'\\u27FA','DoubleLongRightArrow':'\\u27F9','DoubleRightArrow':'\\u21D2','DoubleRightTee':'\\u22A8','DoubleUpArrow':'\\u21D1','DoubleUpDownArrow':'\\u21D5','DoubleVerticalBar':'\\u2225','downarrow':'\\u2193','Downarrow':'\\u21D3','DownArrow':'\\u2193','DownArrowBar':'\\u2913','DownArrowUpArrow':'\\u21F5','DownBreve':'\\u0311','downdownarrows':'\\u21CA','downharpoonleft':'\\u21C3','downharpoonright':'\\u21C2','DownLeftRightVector':'\\u2950','DownLeftTeeVector':'\\u295E','DownLeftVector':'\\u21BD','DownLeftVectorBar':'\\u2956','DownRightTeeVector':'\\u295F','DownRightVector':'\\u21C1','DownRightVectorBar':'\\u2957','DownTee':'\\u22A4','DownTeeArrow':'\\u21A7','drbkarow':'\\u2910','drcorn':'\\u231F','drcrop':'\\u230C','dscr':'\\uD835\\uDCB9','Dscr':'\\uD835\\uDC9F','dscy':'\\u0455','DScy':'\\u0405','dsol':'\\u29F6','dstrok':'\\u0111','Dstrok':'\\u0110','dtdot':'\\u22F1','dtri':'\\u25BF','dtrif':'\\u25BE','duarr':'\\u21F5','duhar':'\\u296F','dwangle':'\\u29A6','dzcy':'\\u045F','DZcy':'\\u040F','dzigrarr':'\\u27FF','eacute':'\\xE9','Eacute':'\\xC9','easter':'\\u2A6E','ecaron':'\\u011B','Ecaron':'\\u011A','ecir':'\\u2256','ecirc':'\\xEA','Ecirc':'\\xCA','ecolon':'\\u2255','ecy':'\\u044D','Ecy':'\\u042D','eDDot':'\\u2A77','edot':'\\u0117','eDot':'\\u2251','Edot':'\\u0116','ee':'\\u2147','efDot':'\\u2252','efr':'\\uD835\\uDD22','Efr':'\\uD835\\uDD08','eg':'\\u2A9A','egrave':'\\xE8','Egrave':'\\xC8','egs':'\\u2A96','egsdot':'\\u2A98','el':'\\u2A99','Element':'\\u2208','elinters':'\\u23E7','ell':'\\u2113','els':'\\u2A95','elsdot':'\\u2A97','emacr':'\\u0113','Emacr':'\\u0112','empty':'\\u2205','emptyset':'\\u2205','EmptySmallSquare':'\\u25FB','emptyv':'\\u2205','EmptyVerySmallSquare':'\\u25AB','emsp':'\\u2003','emsp13':'\\u2004','emsp14':'\\u2005','eng':'\\u014B','ENG':'\\u014A','ensp':'\\u2002','eogon':'\\u0119','Eogon':'\\u0118','eopf':'\\uD835\\uDD56','Eopf':'\\uD835\\uDD3C','epar':'\\u22D5','eparsl':'\\u29E3','eplus':'\\u2A71','epsi':'\\u03B5','epsilon':'\\u03B5','Epsilon':'\\u0395','epsiv':'\\u03F5','eqcirc':'\\u2256','eqcolon':'\\u2255','eqsim':'\\u2242','eqslantgtr':'\\u2A96','eqslantless':'\\u2A95','Equal':'\\u2A75','equals':'=','EqualTilde':'\\u2242','equest':'\\u225F','Equilibrium':'\\u21CC','equiv':'\\u2261','equivDD':'\\u2A78','eqvparsl':'\\u29E5','erarr':'\\u2971','erDot':'\\u2253','escr':'\\u212F','Escr':'\\u2130','esdot':'\\u2250','esim':'\\u2242','Esim':'\\u2A73','eta':'\\u03B7','Eta':'\\u0397','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','euro':'\\u20AC','excl':'!','exist':'\\u2203','Exists':'\\u2203','expectation':'\\u2130','exponentiale':'\\u2147','ExponentialE':'\\u2147','fallingdotseq':'\\u2252','fcy':'\\u0444','Fcy':'\\u0424','female':'\\u2640','ffilig':'\\uFB03','fflig':'\\uFB00','ffllig':'\\uFB04','ffr':'\\uD835\\uDD23','Ffr':'\\uD835\\uDD09','filig':'\\uFB01','FilledSmallSquare':'\\u25FC','FilledVerySmallSquare':'\\u25AA','fjlig':'fj','flat':'\\u266D','fllig':'\\uFB02','fltns':'\\u25B1','fnof':'\\u0192','fopf':'\\uD835\\uDD57','Fopf':'\\uD835\\uDD3D','forall':'\\u2200','ForAll':'\\u2200','fork':'\\u22D4','forkv':'\\u2AD9','Fouriertrf':'\\u2131','fpartint':'\\u2A0D','frac12':'\\xBD','frac13':'\\u2153','frac14':'\\xBC','frac15':'\\u2155','frac16':'\\u2159','frac18':'\\u215B','frac23':'\\u2154','frac25':'\\u2156','frac34':'\\xBE','frac35':'\\u2157','frac38':'\\u215C','frac45':'\\u2158','frac56':'\\u215A','frac58':'\\u215D','frac78':'\\u215E','frasl':'\\u2044','frown':'\\u2322','fscr':'\\uD835\\uDCBB','Fscr':'\\u2131','gacute':'\\u01F5','gamma':'\\u03B3','Gamma':'\\u0393','gammad':'\\u03DD','Gammad':'\\u03DC','gap':'\\u2A86','gbreve':'\\u011F','Gbreve':'\\u011E','Gcedil':'\\u0122','gcirc':'\\u011D','Gcirc':'\\u011C','gcy':'\\u0433','Gcy':'\\u0413','gdot':'\\u0121','Gdot':'\\u0120','ge':'\\u2265','gE':'\\u2267','gel':'\\u22DB','gEl':'\\u2A8C','geq':'\\u2265','geqq':'\\u2267','geqslant':'\\u2A7E','ges':'\\u2A7E','gescc':'\\u2AA9','gesdot':'\\u2A80','gesdoto':'\\u2A82','gesdotol':'\\u2A84','gesl':'\\u22DB\\uFE00','gesles':'\\u2A94','gfr':'\\uD835\\uDD24','Gfr':'\\uD835\\uDD0A','gg':'\\u226B','Gg':'\\u22D9','ggg':'\\u22D9','gimel':'\\u2137','gjcy':'\\u0453','GJcy':'\\u0403','gl':'\\u2277','gla':'\\u2AA5','glE':'\\u2A92','glj':'\\u2AA4','gnap':'\\u2A8A','gnapprox':'\\u2A8A','gne':'\\u2A88','gnE':'\\u2269','gneq':'\\u2A88','gneqq':'\\u2269','gnsim':'\\u22E7','gopf':'\\uD835\\uDD58','Gopf':'\\uD835\\uDD3E','grave':'`','GreaterEqual':'\\u2265','GreaterEqualLess':'\\u22DB','GreaterFullEqual':'\\u2267','GreaterGreater':'\\u2AA2','GreaterLess':'\\u2277','GreaterSlantEqual':'\\u2A7E','GreaterTilde':'\\u2273','gscr':'\\u210A','Gscr':'\\uD835\\uDCA2','gsim':'\\u2273','gsime':'\\u2A8E','gsiml':'\\u2A90','gt':'>','Gt':'\\u226B','GT':'>','gtcc':'\\u2AA7','gtcir':'\\u2A7A','gtdot':'\\u22D7','gtlPar':'\\u2995','gtquest':'\\u2A7C','gtrapprox':'\\u2A86','gtrarr':'\\u2978','gtrdot':'\\u22D7','gtreqless':'\\u22DB','gtreqqless':'\\u2A8C','gtrless':'\\u2277','gtrsim':'\\u2273','gvertneqq':'\\u2269\\uFE00','gvnE':'\\u2269\\uFE00','Hacek':'\\u02C7','hairsp':'\\u200A','half':'\\xBD','hamilt':'\\u210B','hardcy':'\\u044A','HARDcy':'\\u042A','harr':'\\u2194','hArr':'\\u21D4','harrcir':'\\u2948','harrw':'\\u21AD','Hat':'^','hbar':'\\u210F','hcirc':'\\u0125','Hcirc':'\\u0124','hearts':'\\u2665','heartsuit':'\\u2665','hellip':'\\u2026','hercon':'\\u22B9','hfr':'\\uD835\\uDD25','Hfr':'\\u210C','HilbertSpace':'\\u210B','hksearow':'\\u2925','hkswarow':'\\u2926','hoarr':'\\u21FF','homtht':'\\u223B','hookleftarrow':'\\u21A9','hookrightarrow':'\\u21AA','hopf':'\\uD835\\uDD59','Hopf':'\\u210D','horbar':'\\u2015','HorizontalLine':'\\u2500','hscr':'\\uD835\\uDCBD','Hscr':'\\u210B','hslash':'\\u210F','hstrok':'\\u0127','Hstrok':'\\u0126','HumpDownHump':'\\u224E','HumpEqual':'\\u224F','hybull':'\\u2043','hyphen':'\\u2010','iacute':'\\xED','Iacute':'\\xCD','ic':'\\u2063','icirc':'\\xEE','Icirc':'\\xCE','icy':'\\u0438','Icy':'\\u0418','Idot':'\\u0130','iecy':'\\u0435','IEcy':'\\u0415','iexcl':'\\xA1','iff':'\\u21D4','ifr':'\\uD835\\uDD26','Ifr':'\\u2111','igrave':'\\xEC','Igrave':'\\xCC','ii':'\\u2148','iiiint':'\\u2A0C','iiint':'\\u222D','iinfin':'\\u29DC','iiota':'\\u2129','ijlig':'\\u0133','IJlig':'\\u0132','Im':'\\u2111','imacr':'\\u012B','Imacr':'\\u012A','image':'\\u2111','ImaginaryI':'\\u2148','imagline':'\\u2110','imagpart':'\\u2111','imath':'\\u0131','imof':'\\u22B7','imped':'\\u01B5','Implies':'\\u21D2','in':'\\u2208','incare':'\\u2105','infin':'\\u221E','infintie':'\\u29DD','inodot':'\\u0131','int':'\\u222B','Int':'\\u222C','intcal':'\\u22BA','integers':'\\u2124','Integral':'\\u222B','intercal':'\\u22BA','Intersection':'\\u22C2','intlarhk':'\\u2A17','intprod':'\\u2A3C','InvisibleComma':'\\u2063','InvisibleTimes':'\\u2062','iocy':'\\u0451','IOcy':'\\u0401','iogon':'\\u012F','Iogon':'\\u012E','iopf':'\\uD835\\uDD5A','Iopf':'\\uD835\\uDD40','iota':'\\u03B9','Iota':'\\u0399','iprod':'\\u2A3C','iquest':'\\xBF','iscr':'\\uD835\\uDCBE','Iscr':'\\u2110','isin':'\\u2208','isindot':'\\u22F5','isinE':'\\u22F9','isins':'\\u22F4','isinsv':'\\u22F3','isinv':'\\u2208','it':'\\u2062','itilde':'\\u0129','Itilde':'\\u0128','iukcy':'\\u0456','Iukcy':'\\u0406','iuml':'\\xEF','Iuml':'\\xCF','jcirc':'\\u0135','Jcirc':'\\u0134','jcy':'\\u0439','Jcy':'\\u0419','jfr':'\\uD835\\uDD27','Jfr':'\\uD835\\uDD0D','jmath':'\\u0237','jopf':'\\uD835\\uDD5B','Jopf':'\\uD835\\uDD41','jscr':'\\uD835\\uDCBF','Jscr':'\\uD835\\uDCA5','jsercy':'\\u0458','Jsercy':'\\u0408','jukcy':'\\u0454','Jukcy':'\\u0404','kappa':'\\u03BA','Kappa':'\\u039A','kappav':'\\u03F0','kcedil':'\\u0137','Kcedil':'\\u0136','kcy':'\\u043A','Kcy':'\\u041A','kfr':'\\uD835\\uDD28','Kfr':'\\uD835\\uDD0E','kgreen':'\\u0138','khcy':'\\u0445','KHcy':'\\u0425','kjcy':'\\u045C','KJcy':'\\u040C','kopf':'\\uD835\\uDD5C','Kopf':'\\uD835\\uDD42','kscr':'\\uD835\\uDCC0','Kscr':'\\uD835\\uDCA6','lAarr':'\\u21DA','lacute':'\\u013A','Lacute':'\\u0139','laemptyv':'\\u29B4','lagran':'\\u2112','lambda':'\\u03BB','Lambda':'\\u039B','lang':'\\u27E8','Lang':'\\u27EA','langd':'\\u2991','langle':'\\u27E8','lap':'\\u2A85','Laplacetrf':'\\u2112','laquo':'\\xAB','larr':'\\u2190','lArr':'\\u21D0','Larr':'\\u219E','larrb':'\\u21E4','larrbfs':'\\u291F','larrfs':'\\u291D','larrhk':'\\u21A9','larrlp':'\\u21AB','larrpl':'\\u2939','larrsim':'\\u2973','larrtl':'\\u21A2','lat':'\\u2AAB','latail':'\\u2919','lAtail':'\\u291B','late':'\\u2AAD','lates':'\\u2AAD\\uFE00','lbarr':'\\u290C','lBarr':'\\u290E','lbbrk':'\\u2772','lbrace':'{','lbrack':'[','lbrke':'\\u298B','lbrksld':'\\u298F','lbrkslu':'\\u298D','lcaron':'\\u013E','Lcaron':'\\u013D','lcedil':'\\u013C','Lcedil':'\\u013B','lceil':'\\u2308','lcub':'{','lcy':'\\u043B','Lcy':'\\u041B','ldca':'\\u2936','ldquo':'\\u201C','ldquor':'\\u201E','ldrdhar':'\\u2967','ldrushar':'\\u294B','ldsh':'\\u21B2','le':'\\u2264','lE':'\\u2266','LeftAngleBracket':'\\u27E8','leftarrow':'\\u2190','Leftarrow':'\\u21D0','LeftArrow':'\\u2190','LeftArrowBar':'\\u21E4','LeftArrowRightArrow':'\\u21C6','leftarrowtail':'\\u21A2','LeftCeiling':'\\u2308','LeftDoubleBracket':'\\u27E6','LeftDownTeeVector':'\\u2961','LeftDownVector':'\\u21C3','LeftDownVectorBar':'\\u2959','LeftFloor':'\\u230A','leftharpoondown':'\\u21BD','leftharpoonup':'\\u21BC','leftleftarrows':'\\u21C7','leftrightarrow':'\\u2194','Leftrightarrow':'\\u21D4','LeftRightArrow':'\\u2194','leftrightarrows':'\\u21C6','leftrightharpoons':'\\u21CB','leftrightsquigarrow':'\\u21AD','LeftRightVector':'\\u294E','LeftTee':'\\u22A3','LeftTeeArrow':'\\u21A4','LeftTeeVector':'\\u295A','leftthreetimes':'\\u22CB','LeftTriangle':'\\u22B2','LeftTriangleBar':'\\u29CF','LeftTriangleEqual':'\\u22B4','LeftUpDownVector':'\\u2951','LeftUpTeeVector':'\\u2960','LeftUpVector':'\\u21BF','LeftUpVectorBar':'\\u2958','LeftVector':'\\u21BC','LeftVectorBar':'\\u2952','leg':'\\u22DA','lEg':'\\u2A8B','leq':'\\u2264','leqq':'\\u2266','leqslant':'\\u2A7D','les':'\\u2A7D','lescc':'\\u2AA8','lesdot':'\\u2A7F','lesdoto':'\\u2A81','lesdotor':'\\u2A83','lesg':'\\u22DA\\uFE00','lesges':'\\u2A93','lessapprox':'\\u2A85','lessdot':'\\u22D6','lesseqgtr':'\\u22DA','lesseqqgtr':'\\u2A8B','LessEqualGreater':'\\u22DA','LessFullEqual':'\\u2266','LessGreater':'\\u2276','lessgtr':'\\u2276','LessLess':'\\u2AA1','lesssim':'\\u2272','LessSlantEqual':'\\u2A7D','LessTilde':'\\u2272','lfisht':'\\u297C','lfloor':'\\u230A','lfr':'\\uD835\\uDD29','Lfr':'\\uD835\\uDD0F','lg':'\\u2276','lgE':'\\u2A91','lHar':'\\u2962','lhard':'\\u21BD','lharu':'\\u21BC','lharul':'\\u296A','lhblk':'\\u2584','ljcy':'\\u0459','LJcy':'\\u0409','ll':'\\u226A','Ll':'\\u22D8','llarr':'\\u21C7','llcorner':'\\u231E','Lleftarrow':'\\u21DA','llhard':'\\u296B','lltri':'\\u25FA','lmidot':'\\u0140','Lmidot':'\\u013F','lmoust':'\\u23B0','lmoustache':'\\u23B0','lnap':'\\u2A89','lnapprox':'\\u2A89','lne':'\\u2A87','lnE':'\\u2268','lneq':'\\u2A87','lneqq':'\\u2268','lnsim':'\\u22E6','loang':'\\u27EC','loarr':'\\u21FD','lobrk':'\\u27E6','longleftarrow':'\\u27F5','Longleftarrow':'\\u27F8','LongLeftArrow':'\\u27F5','longleftrightarrow':'\\u27F7','Longleftrightarrow':'\\u27FA','LongLeftRightArrow':'\\u27F7','longmapsto':'\\u27FC','longrightarrow':'\\u27F6','Longrightarrow':'\\u27F9','LongRightArrow':'\\u27F6','looparrowleft':'\\u21AB','looparrowright':'\\u21AC','lopar':'\\u2985','lopf':'\\uD835\\uDD5D','Lopf':'\\uD835\\uDD43','loplus':'\\u2A2D','lotimes':'\\u2A34','lowast':'\\u2217','lowbar':'_','LowerLeftArrow':'\\u2199','LowerRightArrow':'\\u2198','loz':'\\u25CA','lozenge':'\\u25CA','lozf':'\\u29EB','lpar':'(','lparlt':'\\u2993','lrarr':'\\u21C6','lrcorner':'\\u231F','lrhar':'\\u21CB','lrhard':'\\u296D','lrm':'\\u200E','lrtri':'\\u22BF','lsaquo':'\\u2039','lscr':'\\uD835\\uDCC1','Lscr':'\\u2112','lsh':'\\u21B0','Lsh':'\\u21B0','lsim':'\\u2272','lsime':'\\u2A8D','lsimg':'\\u2A8F','lsqb':'[','lsquo':'\\u2018','lsquor':'\\u201A','lstrok':'\\u0142','Lstrok':'\\u0141','lt':'<','Lt':'\\u226A','LT':'<','ltcc':'\\u2AA6','ltcir':'\\u2A79','ltdot':'\\u22D6','lthree':'\\u22CB','ltimes':'\\u22C9','ltlarr':'\\u2976','ltquest':'\\u2A7B','ltri':'\\u25C3','ltrie':'\\u22B4','ltrif':'\\u25C2','ltrPar':'\\u2996','lurdshar':'\\u294A','luruhar':'\\u2966','lvertneqq':'\\u2268\\uFE00','lvnE':'\\u2268\\uFE00','macr':'\\xAF','male':'\\u2642','malt':'\\u2720','maltese':'\\u2720','map':'\\u21A6','Map':'\\u2905','mapsto':'\\u21A6','mapstodown':'\\u21A7','mapstoleft':'\\u21A4','mapstoup':'\\u21A5','marker':'\\u25AE','mcomma':'\\u2A29','mcy':'\\u043C','Mcy':'\\u041C','mdash':'\\u2014','mDDot':'\\u223A','measuredangle':'\\u2221','MediumSpace':'\\u205F','Mellintrf':'\\u2133','mfr':'\\uD835\\uDD2A','Mfr':'\\uD835\\uDD10','mho':'\\u2127','micro':'\\xB5','mid':'\\u2223','midast':'*','midcir':'\\u2AF0','middot':'\\xB7','minus':'\\u2212','minusb':'\\u229F','minusd':'\\u2238','minusdu':'\\u2A2A','MinusPlus':'\\u2213','mlcp':'\\u2ADB','mldr':'\\u2026','mnplus':'\\u2213','models':'\\u22A7','mopf':'\\uD835\\uDD5E','Mopf':'\\uD835\\uDD44','mp':'\\u2213','mscr':'\\uD835\\uDCC2','Mscr':'\\u2133','mstpos':'\\u223E','mu':'\\u03BC','Mu':'\\u039C','multimap':'\\u22B8','mumap':'\\u22B8','nabla':'\\u2207','nacute':'\\u0144','Nacute':'\\u0143','nang':'\\u2220\\u20D2','nap':'\\u2249','napE':'\\u2A70\\u0338','napid':'\\u224B\\u0338','napos':'\\u0149','napprox':'\\u2249','natur':'\\u266E','natural':'\\u266E','naturals':'\\u2115','nbsp':'\\xA0','nbump':'\\u224E\\u0338','nbumpe':'\\u224F\\u0338','ncap':'\\u2A43','ncaron':'\\u0148','Ncaron':'\\u0147','ncedil':'\\u0146','Ncedil':'\\u0145','ncong':'\\u2247','ncongdot':'\\u2A6D\\u0338','ncup':'\\u2A42','ncy':'\\u043D','Ncy':'\\u041D','ndash':'\\u2013','ne':'\\u2260','nearhk':'\\u2924','nearr':'\\u2197','neArr':'\\u21D7','nearrow':'\\u2197','nedot':'\\u2250\\u0338','NegativeMediumSpace':'\\u200B','NegativeThickSpace':'\\u200B','NegativeThinSpace':'\\u200B','NegativeVeryThinSpace':'\\u200B','nequiv':'\\u2262','nesear':'\\u2928','nesim':'\\u2242\\u0338','NestedGreaterGreater':'\\u226B','NestedLessLess':'\\u226A','NewLine':'\\n','nexist':'\\u2204','nexists':'\\u2204','nfr':'\\uD835\\uDD2B','Nfr':'\\uD835\\uDD11','nge':'\\u2271','ngE':'\\u2267\\u0338','ngeq':'\\u2271','ngeqq':'\\u2267\\u0338','ngeqslant':'\\u2A7E\\u0338','nges':'\\u2A7E\\u0338','nGg':'\\u22D9\\u0338','ngsim':'\\u2275','ngt':'\\u226F','nGt':'\\u226B\\u20D2','ngtr':'\\u226F','nGtv':'\\u226B\\u0338','nharr':'\\u21AE','nhArr':'\\u21CE','nhpar':'\\u2AF2','ni':'\\u220B','nis':'\\u22FC','nisd':'\\u22FA','niv':'\\u220B','njcy':'\\u045A','NJcy':'\\u040A','nlarr':'\\u219A','nlArr':'\\u21CD','nldr':'\\u2025','nle':'\\u2270','nlE':'\\u2266\\u0338','nleftarrow':'\\u219A','nLeftarrow':'\\u21CD','nleftrightarrow':'\\u21AE','nLeftrightarrow':'\\u21CE','nleq':'\\u2270','nleqq':'\\u2266\\u0338','nleqslant':'\\u2A7D\\u0338','nles':'\\u2A7D\\u0338','nless':'\\u226E','nLl':'\\u22D8\\u0338','nlsim':'\\u2274','nlt':'\\u226E','nLt':'\\u226A\\u20D2','nltri':'\\u22EA','nltrie':'\\u22EC','nLtv':'\\u226A\\u0338','nmid':'\\u2224','NoBreak':'\\u2060','NonBreakingSpace':'\\xA0','nopf':'\\uD835\\uDD5F','Nopf':'\\u2115','not':'\\xAC','Not':'\\u2AEC','NotCongruent':'\\u2262','NotCupCap':'\\u226D','NotDoubleVerticalBar':'\\u2226','NotElement':'\\u2209','NotEqual':'\\u2260','NotEqualTilde':'\\u2242\\u0338','NotExists':'\\u2204','NotGreater':'\\u226F','NotGreaterEqual':'\\u2271','NotGreaterFullEqual':'\\u2267\\u0338','NotGreaterGreater':'\\u226B\\u0338','NotGreaterLess':'\\u2279','NotGreaterSlantEqual':'\\u2A7E\\u0338','NotGreaterTilde':'\\u2275','NotHumpDownHump':'\\u224E\\u0338','NotHumpEqual':'\\u224F\\u0338','notin':'\\u2209','notindot':'\\u22F5\\u0338','notinE':'\\u22F9\\u0338','notinva':'\\u2209','notinvb':'\\u22F7','notinvc':'\\u22F6','NotLeftTriangle':'\\u22EA','NotLeftTriangleBar':'\\u29CF\\u0338','NotLeftTriangleEqual':'\\u22EC','NotLess':'\\u226E','NotLessEqual':'\\u2270','NotLessGreater':'\\u2278','NotLessLess':'\\u226A\\u0338','NotLessSlantEqual':'\\u2A7D\\u0338','NotLessTilde':'\\u2274','NotNestedGreaterGreater':'\\u2AA2\\u0338','NotNestedLessLess':'\\u2AA1\\u0338','notni':'\\u220C','notniva':'\\u220C','notnivb':'\\u22FE','notnivc':'\\u22FD','NotPrecedes':'\\u2280','NotPrecedesEqual':'\\u2AAF\\u0338','NotPrecedesSlantEqual':'\\u22E0','NotReverseElement':'\\u220C','NotRightTriangle':'\\u22EB','NotRightTriangleBar':'\\u29D0\\u0338','NotRightTriangleEqual':'\\u22ED','NotSquareSubset':'\\u228F\\u0338','NotSquareSubsetEqual':'\\u22E2','NotSquareSuperset':'\\u2290\\u0338','NotSquareSupersetEqual':'\\u22E3','NotSubset':'\\u2282\\u20D2','NotSubsetEqual':'\\u2288','NotSucceeds':'\\u2281','NotSucceedsEqual':'\\u2AB0\\u0338','NotSucceedsSlantEqual':'\\u22E1','NotSucceedsTilde':'\\u227F\\u0338','NotSuperset':'\\u2283\\u20D2','NotSupersetEqual':'\\u2289','NotTilde':'\\u2241','NotTildeEqual':'\\u2244','NotTildeFullEqual':'\\u2247','NotTildeTilde':'\\u2249','NotVerticalBar':'\\u2224','npar':'\\u2226','nparallel':'\\u2226','nparsl':'\\u2AFD\\u20E5','npart':'\\u2202\\u0338','npolint':'\\u2A14','npr':'\\u2280','nprcue':'\\u22E0','npre':'\\u2AAF\\u0338','nprec':'\\u2280','npreceq':'\\u2AAF\\u0338','nrarr':'\\u219B','nrArr':'\\u21CF','nrarrc':'\\u2933\\u0338','nrarrw':'\\u219D\\u0338','nrightarrow':'\\u219B','nRightarrow':'\\u21CF','nrtri':'\\u22EB','nrtrie':'\\u22ED','nsc':'\\u2281','nsccue':'\\u22E1','nsce':'\\u2AB0\\u0338','nscr':'\\uD835\\uDCC3','Nscr':'\\uD835\\uDCA9','nshortmid':'\\u2224','nshortparallel':'\\u2226','nsim':'\\u2241','nsime':'\\u2244','nsimeq':'\\u2244','nsmid':'\\u2224','nspar':'\\u2226','nsqsube':'\\u22E2','nsqsupe':'\\u22E3','nsub':'\\u2284','nsube':'\\u2288','nsubE':'\\u2AC5\\u0338','nsubset':'\\u2282\\u20D2','nsubseteq':'\\u2288','nsubseteqq':'\\u2AC5\\u0338','nsucc':'\\u2281','nsucceq':'\\u2AB0\\u0338','nsup':'\\u2285','nsupe':'\\u2289','nsupE':'\\u2AC6\\u0338','nsupset':'\\u2283\\u20D2','nsupseteq':'\\u2289','nsupseteqq':'\\u2AC6\\u0338','ntgl':'\\u2279','ntilde':'\\xF1','Ntilde':'\\xD1','ntlg':'\\u2278','ntriangleleft':'\\u22EA','ntrianglelefteq':'\\u22EC','ntriangleright':'\\u22EB','ntrianglerighteq':'\\u22ED','nu':'\\u03BD','Nu':'\\u039D','num':'#','numero':'\\u2116','numsp':'\\u2007','nvap':'\\u224D\\u20D2','nvdash':'\\u22AC','nvDash':'\\u22AD','nVdash':'\\u22AE','nVDash':'\\u22AF','nvge':'\\u2265\\u20D2','nvgt':'>\\u20D2','nvHarr':'\\u2904','nvinfin':'\\u29DE','nvlArr':'\\u2902','nvle':'\\u2264\\u20D2','nvlt':'<\\u20D2','nvltrie':'\\u22B4\\u20D2','nvrArr':'\\u2903','nvrtrie':'\\u22B5\\u20D2','nvsim':'\\u223C\\u20D2','nwarhk':'\\u2923','nwarr':'\\u2196','nwArr':'\\u21D6','nwarrow':'\\u2196','nwnear':'\\u2927','oacute':'\\xF3','Oacute':'\\xD3','oast':'\\u229B','ocir':'\\u229A','ocirc':'\\xF4','Ocirc':'\\xD4','ocy':'\\u043E','Ocy':'\\u041E','odash':'\\u229D','odblac':'\\u0151','Odblac':'\\u0150','odiv':'\\u2A38','odot':'\\u2299','odsold':'\\u29BC','oelig':'\\u0153','OElig':'\\u0152','ofcir':'\\u29BF','ofr':'\\uD835\\uDD2C','Ofr':'\\uD835\\uDD12','ogon':'\\u02DB','ograve':'\\xF2','Ograve':'\\xD2','ogt':'\\u29C1','ohbar':'\\u29B5','ohm':'\\u03A9','oint':'\\u222E','olarr':'\\u21BA','olcir':'\\u29BE','olcross':'\\u29BB','oline':'\\u203E','olt':'\\u29C0','omacr':'\\u014D','Omacr':'\\u014C','omega':'\\u03C9','Omega':'\\u03A9','omicron':'\\u03BF','Omicron':'\\u039F','omid':'\\u29B6','ominus':'\\u2296','oopf':'\\uD835\\uDD60','Oopf':'\\uD835\\uDD46','opar':'\\u29B7','OpenCurlyDoubleQuote':'\\u201C','OpenCurlyQuote':'\\u2018','operp':'\\u29B9','oplus':'\\u2295','or':'\\u2228','Or':'\\u2A54','orarr':'\\u21BB','ord':'\\u2A5D','order':'\\u2134','orderof':'\\u2134','ordf':'\\xAA','ordm':'\\xBA','origof':'\\u22B6','oror':'\\u2A56','orslope':'\\u2A57','orv':'\\u2A5B','oS':'\\u24C8','oscr':'\\u2134','Oscr':'\\uD835\\uDCAA','oslash':'\\xF8','Oslash':'\\xD8','osol':'\\u2298','otilde':'\\xF5','Otilde':'\\xD5','otimes':'\\u2297','Otimes':'\\u2A37','otimesas':'\\u2A36','ouml':'\\xF6','Ouml':'\\xD6','ovbar':'\\u233D','OverBar':'\\u203E','OverBrace':'\\u23DE','OverBracket':'\\u23B4','OverParenthesis':'\\u23DC','par':'\\u2225','para':'\\xB6','parallel':'\\u2225','parsim':'\\u2AF3','parsl':'\\u2AFD','part':'\\u2202','PartialD':'\\u2202','pcy':'\\u043F','Pcy':'\\u041F','percnt':'%','period':'.','permil':'\\u2030','perp':'\\u22A5','pertenk':'\\u2031','pfr':'\\uD835\\uDD2D','Pfr':'\\uD835\\uDD13','phi':'\\u03C6','Phi':'\\u03A6','phiv':'\\u03D5','phmmat':'\\u2133','phone':'\\u260E','pi':'\\u03C0','Pi':'\\u03A0','pitchfork':'\\u22D4','piv':'\\u03D6','planck':'\\u210F','planckh':'\\u210E','plankv':'\\u210F','plus':'+','plusacir':'\\u2A23','plusb':'\\u229E','pluscir':'\\u2A22','plusdo':'\\u2214','plusdu':'\\u2A25','pluse':'\\u2A72','PlusMinus':'\\xB1','plusmn':'\\xB1','plussim':'\\u2A26','plustwo':'\\u2A27','pm':'\\xB1','Poincareplane':'\\u210C','pointint':'\\u2A15','popf':'\\uD835\\uDD61','Popf':'\\u2119','pound':'\\xA3','pr':'\\u227A','Pr':'\\u2ABB','prap':'\\u2AB7','prcue':'\\u227C','pre':'\\u2AAF','prE':'\\u2AB3','prec':'\\u227A','precapprox':'\\u2AB7','preccurlyeq':'\\u227C','Precedes':'\\u227A','PrecedesEqual':'\\u2AAF','PrecedesSlantEqual':'\\u227C','PrecedesTilde':'\\u227E','preceq':'\\u2AAF','precnapprox':'\\u2AB9','precneqq':'\\u2AB5','precnsim':'\\u22E8','precsim':'\\u227E','prime':'\\u2032','Prime':'\\u2033','primes':'\\u2119','prnap':'\\u2AB9','prnE':'\\u2AB5','prnsim':'\\u22E8','prod':'\\u220F','Product':'\\u220F','profalar':'\\u232E','profline':'\\u2312','profsurf':'\\u2313','prop':'\\u221D','Proportion':'\\u2237','Proportional':'\\u221D','propto':'\\u221D','prsim':'\\u227E','prurel':'\\u22B0','pscr':'\\uD835\\uDCC5','Pscr':'\\uD835\\uDCAB','psi':'\\u03C8','Psi':'\\u03A8','puncsp':'\\u2008','qfr':'\\uD835\\uDD2E','Qfr':'\\uD835\\uDD14','qint':'\\u2A0C','qopf':'\\uD835\\uDD62','Qopf':'\\u211A','qprime':'\\u2057','qscr':'\\uD835\\uDCC6','Qscr':'\\uD835\\uDCAC','quaternions':'\\u210D','quatint':'\\u2A16','quest':'?','questeq':'\\u225F','quot':'\"','QUOT':'\"','rAarr':'\\u21DB','race':'\\u223D\\u0331','racute':'\\u0155','Racute':'\\u0154','radic':'\\u221A','raemptyv':'\\u29B3','rang':'\\u27E9','Rang':'\\u27EB','rangd':'\\u2992','range':'\\u29A5','rangle':'\\u27E9','raquo':'\\xBB','rarr':'\\u2192','rArr':'\\u21D2','Rarr':'\\u21A0','rarrap':'\\u2975','rarrb':'\\u21E5','rarrbfs':'\\u2920','rarrc':'\\u2933','rarrfs':'\\u291E','rarrhk':'\\u21AA','rarrlp':'\\u21AC','rarrpl':'\\u2945','rarrsim':'\\u2974','rarrtl':'\\u21A3','Rarrtl':'\\u2916','rarrw':'\\u219D','ratail':'\\u291A','rAtail':'\\u291C','ratio':'\\u2236','rationals':'\\u211A','rbarr':'\\u290D','rBarr':'\\u290F','RBarr':'\\u2910','rbbrk':'\\u2773','rbrace':'}','rbrack':']','rbrke':'\\u298C','rbrksld':'\\u298E','rbrkslu':'\\u2990','rcaron':'\\u0159','Rcaron':'\\u0158','rcedil':'\\u0157','Rcedil':'\\u0156','rceil':'\\u2309','rcub':'}','rcy':'\\u0440','Rcy':'\\u0420','rdca':'\\u2937','rdldhar':'\\u2969','rdquo':'\\u201D','rdquor':'\\u201D','rdsh':'\\u21B3','Re':'\\u211C','real':'\\u211C','realine':'\\u211B','realpart':'\\u211C','reals':'\\u211D','rect':'\\u25AD','reg':'\\xAE','REG':'\\xAE','ReverseElement':'\\u220B','ReverseEquilibrium':'\\u21CB','ReverseUpEquilibrium':'\\u296F','rfisht':'\\u297D','rfloor':'\\u230B','rfr':'\\uD835\\uDD2F','Rfr':'\\u211C','rHar':'\\u2964','rhard':'\\u21C1','rharu':'\\u21C0','rharul':'\\u296C','rho':'\\u03C1','Rho':'\\u03A1','rhov':'\\u03F1','RightAngleBracket':'\\u27E9','rightarrow':'\\u2192','Rightarrow':'\\u21D2','RightArrow':'\\u2192','RightArrowBar':'\\u21E5','RightArrowLeftArrow':'\\u21C4','rightarrowtail':'\\u21A3','RightCeiling':'\\u2309','RightDoubleBracket':'\\u27E7','RightDownTeeVector':'\\u295D','RightDownVector':'\\u21C2','RightDownVectorBar':'\\u2955','RightFloor':'\\u230B','rightharpoondown':'\\u21C1','rightharpoonup':'\\u21C0','rightleftarrows':'\\u21C4','rightleftharpoons':'\\u21CC','rightrightarrows':'\\u21C9','rightsquigarrow':'\\u219D','RightTee':'\\u22A2','RightTeeArrow':'\\u21A6','RightTeeVector':'\\u295B','rightthreetimes':'\\u22CC','RightTriangle':'\\u22B3','RightTriangleBar':'\\u29D0','RightTriangleEqual':'\\u22B5','RightUpDownVector':'\\u294F','RightUpTeeVector':'\\u295C','RightUpVector':'\\u21BE','RightUpVectorBar':'\\u2954','RightVector':'\\u21C0','RightVectorBar':'\\u2953','ring':'\\u02DA','risingdotseq':'\\u2253','rlarr':'\\u21C4','rlhar':'\\u21CC','rlm':'\\u200F','rmoust':'\\u23B1','rmoustache':'\\u23B1','rnmid':'\\u2AEE','roang':'\\u27ED','roarr':'\\u21FE','robrk':'\\u27E7','ropar':'\\u2986','ropf':'\\uD835\\uDD63','Ropf':'\\u211D','roplus':'\\u2A2E','rotimes':'\\u2A35','RoundImplies':'\\u2970','rpar':')','rpargt':'\\u2994','rppolint':'\\u2A12','rrarr':'\\u21C9','Rrightarrow':'\\u21DB','rsaquo':'\\u203A','rscr':'\\uD835\\uDCC7','Rscr':'\\u211B','rsh':'\\u21B1','Rsh':'\\u21B1','rsqb':']','rsquo':'\\u2019','rsquor':'\\u2019','rthree':'\\u22CC','rtimes':'\\u22CA','rtri':'\\u25B9','rtrie':'\\u22B5','rtrif':'\\u25B8','rtriltri':'\\u29CE','RuleDelayed':'\\u29F4','ruluhar':'\\u2968','rx':'\\u211E','sacute':'\\u015B','Sacute':'\\u015A','sbquo':'\\u201A','sc':'\\u227B','Sc':'\\u2ABC','scap':'\\u2AB8','scaron':'\\u0161','Scaron':'\\u0160','sccue':'\\u227D','sce':'\\u2AB0','scE':'\\u2AB4','scedil':'\\u015F','Scedil':'\\u015E','scirc':'\\u015D','Scirc':'\\u015C','scnap':'\\u2ABA','scnE':'\\u2AB6','scnsim':'\\u22E9','scpolint':'\\u2A13','scsim':'\\u227F','scy':'\\u0441','Scy':'\\u0421','sdot':'\\u22C5','sdotb':'\\u22A1','sdote':'\\u2A66','searhk':'\\u2925','searr':'\\u2198','seArr':'\\u21D8','searrow':'\\u2198','sect':'\\xA7','semi':';','seswar':'\\u2929','setminus':'\\u2216','setmn':'\\u2216','sext':'\\u2736','sfr':'\\uD835\\uDD30','Sfr':'\\uD835\\uDD16','sfrown':'\\u2322','sharp':'\\u266F','shchcy':'\\u0449','SHCHcy':'\\u0429','shcy':'\\u0448','SHcy':'\\u0428','ShortDownArrow':'\\u2193','ShortLeftArrow':'\\u2190','shortmid':'\\u2223','shortparallel':'\\u2225','ShortRightArrow':'\\u2192','ShortUpArrow':'\\u2191','shy':'\\xAD','sigma':'\\u03C3','Sigma':'\\u03A3','sigmaf':'\\u03C2','sigmav':'\\u03C2','sim':'\\u223C','simdot':'\\u2A6A','sime':'\\u2243','simeq':'\\u2243','simg':'\\u2A9E','simgE':'\\u2AA0','siml':'\\u2A9D','simlE':'\\u2A9F','simne':'\\u2246','simplus':'\\u2A24','simrarr':'\\u2972','slarr':'\\u2190','SmallCircle':'\\u2218','smallsetminus':'\\u2216','smashp':'\\u2A33','smeparsl':'\\u29E4','smid':'\\u2223','smile':'\\u2323','smt':'\\u2AAA','smte':'\\u2AAC','smtes':'\\u2AAC\\uFE00','softcy':'\\u044C','SOFTcy':'\\u042C','sol':'/','solb':'\\u29C4','solbar':'\\u233F','sopf':'\\uD835\\uDD64','Sopf':'\\uD835\\uDD4A','spades':'\\u2660','spadesuit':'\\u2660','spar':'\\u2225','sqcap':'\\u2293','sqcaps':'\\u2293\\uFE00','sqcup':'\\u2294','sqcups':'\\u2294\\uFE00','Sqrt':'\\u221A','sqsub':'\\u228F','sqsube':'\\u2291','sqsubset':'\\u228F','sqsubseteq':'\\u2291','sqsup':'\\u2290','sqsupe':'\\u2292','sqsupset':'\\u2290','sqsupseteq':'\\u2292','squ':'\\u25A1','square':'\\u25A1','Square':'\\u25A1','SquareIntersection':'\\u2293','SquareSubset':'\\u228F','SquareSubsetEqual':'\\u2291','SquareSuperset':'\\u2290','SquareSupersetEqual':'\\u2292','SquareUnion':'\\u2294','squarf':'\\u25AA','squf':'\\u25AA','srarr':'\\u2192','sscr':'\\uD835\\uDCC8','Sscr':'\\uD835\\uDCAE','ssetmn':'\\u2216','ssmile':'\\u2323','sstarf':'\\u22C6','star':'\\u2606','Star':'\\u22C6','starf':'\\u2605','straightepsilon':'\\u03F5','straightphi':'\\u03D5','strns':'\\xAF','sub':'\\u2282','Sub':'\\u22D0','subdot':'\\u2ABD','sube':'\\u2286','subE':'\\u2AC5','subedot':'\\u2AC3','submult':'\\u2AC1','subne':'\\u228A','subnE':'\\u2ACB','subplus':'\\u2ABF','subrarr':'\\u2979','subset':'\\u2282','Subset':'\\u22D0','subseteq':'\\u2286','subseteqq':'\\u2AC5','SubsetEqual':'\\u2286','subsetneq':'\\u228A','subsetneqq':'\\u2ACB','subsim':'\\u2AC7','subsub':'\\u2AD5','subsup':'\\u2AD3','succ':'\\u227B','succapprox':'\\u2AB8','succcurlyeq':'\\u227D','Succeeds':'\\u227B','SucceedsEqual':'\\u2AB0','SucceedsSlantEqual':'\\u227D','SucceedsTilde':'\\u227F','succeq':'\\u2AB0','succnapprox':'\\u2ABA','succneqq':'\\u2AB6','succnsim':'\\u22E9','succsim':'\\u227F','SuchThat':'\\u220B','sum':'\\u2211','Sum':'\\u2211','sung':'\\u266A','sup':'\\u2283','Sup':'\\u22D1','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','supdot':'\\u2ABE','supdsub':'\\u2AD8','supe':'\\u2287','supE':'\\u2AC6','supedot':'\\u2AC4','Superset':'\\u2283','SupersetEqual':'\\u2287','suphsol':'\\u27C9','suphsub':'\\u2AD7','suplarr':'\\u297B','supmult':'\\u2AC2','supne':'\\u228B','supnE':'\\u2ACC','supplus':'\\u2AC0','supset':'\\u2283','Supset':'\\u22D1','supseteq':'\\u2287','supseteqq':'\\u2AC6','supsetneq':'\\u228B','supsetneqq':'\\u2ACC','supsim':'\\u2AC8','supsub':'\\u2AD4','supsup':'\\u2AD6','swarhk':'\\u2926','swarr':'\\u2199','swArr':'\\u21D9','swarrow':'\\u2199','swnwar':'\\u292A','szlig':'\\xDF','Tab':'\\t','target':'\\u2316','tau':'\\u03C4','Tau':'\\u03A4','tbrk':'\\u23B4','tcaron':'\\u0165','Tcaron':'\\u0164','tcedil':'\\u0163','Tcedil':'\\u0162','tcy':'\\u0442','Tcy':'\\u0422','tdot':'\\u20DB','telrec':'\\u2315','tfr':'\\uD835\\uDD31','Tfr':'\\uD835\\uDD17','there4':'\\u2234','therefore':'\\u2234','Therefore':'\\u2234','theta':'\\u03B8','Theta':'\\u0398','thetasym':'\\u03D1','thetav':'\\u03D1','thickapprox':'\\u2248','thicksim':'\\u223C','ThickSpace':'\\u205F\\u200A','thinsp':'\\u2009','ThinSpace':'\\u2009','thkap':'\\u2248','thksim':'\\u223C','thorn':'\\xFE','THORN':'\\xDE','tilde':'\\u02DC','Tilde':'\\u223C','TildeEqual':'\\u2243','TildeFullEqual':'\\u2245','TildeTilde':'\\u2248','times':'\\xD7','timesb':'\\u22A0','timesbar':'\\u2A31','timesd':'\\u2A30','tint':'\\u222D','toea':'\\u2928','top':'\\u22A4','topbot':'\\u2336','topcir':'\\u2AF1','topf':'\\uD835\\uDD65','Topf':'\\uD835\\uDD4B','topfork':'\\u2ADA','tosa':'\\u2929','tprime':'\\u2034','trade':'\\u2122','TRADE':'\\u2122','triangle':'\\u25B5','triangledown':'\\u25BF','triangleleft':'\\u25C3','trianglelefteq':'\\u22B4','triangleq':'\\u225C','triangleright':'\\u25B9','trianglerighteq':'\\u22B5','tridot':'\\u25EC','trie':'\\u225C','triminus':'\\u2A3A','TripleDot':'\\u20DB','triplus':'\\u2A39','trisb':'\\u29CD','tritime':'\\u2A3B','trpezium':'\\u23E2','tscr':'\\uD835\\uDCC9','Tscr':'\\uD835\\uDCAF','tscy':'\\u0446','TScy':'\\u0426','tshcy':'\\u045B','TSHcy':'\\u040B','tstrok':'\\u0167','Tstrok':'\\u0166','twixt':'\\u226C','twoheadleftarrow':'\\u219E','twoheadrightarrow':'\\u21A0','uacute':'\\xFA','Uacute':'\\xDA','uarr':'\\u2191','uArr':'\\u21D1','Uarr':'\\u219F','Uarrocir':'\\u2949','ubrcy':'\\u045E','Ubrcy':'\\u040E','ubreve':'\\u016D','Ubreve':'\\u016C','ucirc':'\\xFB','Ucirc':'\\xDB','ucy':'\\u0443','Ucy':'\\u0423','udarr':'\\u21C5','udblac':'\\u0171','Udblac':'\\u0170','udhar':'\\u296E','ufisht':'\\u297E','ufr':'\\uD835\\uDD32','Ufr':'\\uD835\\uDD18','ugrave':'\\xF9','Ugrave':'\\xD9','uHar':'\\u2963','uharl':'\\u21BF','uharr':'\\u21BE','uhblk':'\\u2580','ulcorn':'\\u231C','ulcorner':'\\u231C','ulcrop':'\\u230F','ultri':'\\u25F8','umacr':'\\u016B','Umacr':'\\u016A','uml':'\\xA8','UnderBar':'_','UnderBrace':'\\u23DF','UnderBracket':'\\u23B5','UnderParenthesis':'\\u23DD','Union':'\\u22C3','UnionPlus':'\\u228E','uogon':'\\u0173','Uogon':'\\u0172','uopf':'\\uD835\\uDD66','Uopf':'\\uD835\\uDD4C','uparrow':'\\u2191','Uparrow':'\\u21D1','UpArrow':'\\u2191','UpArrowBar':'\\u2912','UpArrowDownArrow':'\\u21C5','updownarrow':'\\u2195','Updownarrow':'\\u21D5','UpDownArrow':'\\u2195','UpEquilibrium':'\\u296E','upharpoonleft':'\\u21BF','upharpoonright':'\\u21BE','uplus':'\\u228E','UpperLeftArrow':'\\u2196','UpperRightArrow':'\\u2197','upsi':'\\u03C5','Upsi':'\\u03D2','upsih':'\\u03D2','upsilon':'\\u03C5','Upsilon':'\\u03A5','UpTee':'\\u22A5','UpTeeArrow':'\\u21A5','upuparrows':'\\u21C8','urcorn':'\\u231D','urcorner':'\\u231D','urcrop':'\\u230E','uring':'\\u016F','Uring':'\\u016E','urtri':'\\u25F9','uscr':'\\uD835\\uDCCA','Uscr':'\\uD835\\uDCB0','utdot':'\\u22F0','utilde':'\\u0169','Utilde':'\\u0168','utri':'\\u25B5','utrif':'\\u25B4','uuarr':'\\u21C8','uuml':'\\xFC','Uuml':'\\xDC','uwangle':'\\u29A7','vangrt':'\\u299C','varepsilon':'\\u03F5','varkappa':'\\u03F0','varnothing':'\\u2205','varphi':'\\u03D5','varpi':'\\u03D6','varpropto':'\\u221D','varr':'\\u2195','vArr':'\\u21D5','varrho':'\\u03F1','varsigma':'\\u03C2','varsubsetneq':'\\u228A\\uFE00','varsubsetneqq':'\\u2ACB\\uFE00','varsupsetneq':'\\u228B\\uFE00','varsupsetneqq':'\\u2ACC\\uFE00','vartheta':'\\u03D1','vartriangleleft':'\\u22B2','vartriangleright':'\\u22B3','vBar':'\\u2AE8','Vbar':'\\u2AEB','vBarv':'\\u2AE9','vcy':'\\u0432','Vcy':'\\u0412','vdash':'\\u22A2','vDash':'\\u22A8','Vdash':'\\u22A9','VDash':'\\u22AB','Vdashl':'\\u2AE6','vee':'\\u2228','Vee':'\\u22C1','veebar':'\\u22BB','veeeq':'\\u225A','vellip':'\\u22EE','verbar':'|','Verbar':'\\u2016','vert':'|','Vert':'\\u2016','VerticalBar':'\\u2223','VerticalLine':'|','VerticalSeparator':'\\u2758','VerticalTilde':'\\u2240','VeryThinSpace':'\\u200A','vfr':'\\uD835\\uDD33','Vfr':'\\uD835\\uDD19','vltri':'\\u22B2','vnsub':'\\u2282\\u20D2','vnsup':'\\u2283\\u20D2','vopf':'\\uD835\\uDD67','Vopf':'\\uD835\\uDD4D','vprop':'\\u221D','vrtri':'\\u22B3','vscr':'\\uD835\\uDCCB','Vscr':'\\uD835\\uDCB1','vsubne':'\\u228A\\uFE00','vsubnE':'\\u2ACB\\uFE00','vsupne':'\\u228B\\uFE00','vsupnE':'\\u2ACC\\uFE00','Vvdash':'\\u22AA','vzigzag':'\\u299A','wcirc':'\\u0175','Wcirc':'\\u0174','wedbar':'\\u2A5F','wedge':'\\u2227','Wedge':'\\u22C0','wedgeq':'\\u2259','weierp':'\\u2118','wfr':'\\uD835\\uDD34','Wfr':'\\uD835\\uDD1A','wopf':'\\uD835\\uDD68','Wopf':'\\uD835\\uDD4E','wp':'\\u2118','wr':'\\u2240','wreath':'\\u2240','wscr':'\\uD835\\uDCCC','Wscr':'\\uD835\\uDCB2','xcap':'\\u22C2','xcirc':'\\u25EF','xcup':'\\u22C3','xdtri':'\\u25BD','xfr':'\\uD835\\uDD35','Xfr':'\\uD835\\uDD1B','xharr':'\\u27F7','xhArr':'\\u27FA','xi':'\\u03BE','Xi':'\\u039E','xlarr':'\\u27F5','xlArr':'\\u27F8','xmap':'\\u27FC','xnis':'\\u22FB','xodot':'\\u2A00','xopf':'\\uD835\\uDD69','Xopf':'\\uD835\\uDD4F','xoplus':'\\u2A01','xotime':'\\u2A02','xrarr':'\\u27F6','xrArr':'\\u27F9','xscr':'\\uD835\\uDCCD','Xscr':'\\uD835\\uDCB3','xsqcup':'\\u2A06','xuplus':'\\u2A04','xutri':'\\u25B3','xvee':'\\u22C1','xwedge':'\\u22C0','yacute':'\\xFD','Yacute':'\\xDD','yacy':'\\u044F','YAcy':'\\u042F','ycirc':'\\u0177','Ycirc':'\\u0176','ycy':'\\u044B','Ycy':'\\u042B','yen':'\\xA5','yfr':'\\uD835\\uDD36','Yfr':'\\uD835\\uDD1C','yicy':'\\u0457','YIcy':'\\u0407','yopf':'\\uD835\\uDD6A','Yopf':'\\uD835\\uDD50','yscr':'\\uD835\\uDCCE','Yscr':'\\uD835\\uDCB4','yucy':'\\u044E','YUcy':'\\u042E','yuml':'\\xFF','Yuml':'\\u0178','zacute':'\\u017A','Zacute':'\\u0179','zcaron':'\\u017E','Zcaron':'\\u017D','zcy':'\\u0437','Zcy':'\\u0417','zdot':'\\u017C','Zdot':'\\u017B','zeetrf':'\\u2128','ZeroWidthSpace':'\\u200B','zeta':'\\u03B6','Zeta':'\\u0396','zfr':'\\uD835\\uDD37','Zfr':'\\u2128','zhcy':'\\u0436','ZHcy':'\\u0416','zigrarr':'\\u21DD','zopf':'\\uD835\\uDD6B','Zopf':'\\u2124','zscr':'\\uD835\\uDCCF','Zscr':'\\uD835\\uDCB5','zwj':'\\u200D','zwnj':'\\u200C'};\n\tvar decodeMapLegacy = {'aacute':'\\xE1','Aacute':'\\xC1','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','aelig':'\\xE6','AElig':'\\xC6','agrave':'\\xE0','Agrave':'\\xC0','amp':'&','AMP':'&','aring':'\\xE5','Aring':'\\xC5','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','brvbar':'\\xA6','ccedil':'\\xE7','Ccedil':'\\xC7','cedil':'\\xB8','cent':'\\xA2','copy':'\\xA9','COPY':'\\xA9','curren':'\\xA4','deg':'\\xB0','divide':'\\xF7','eacute':'\\xE9','Eacute':'\\xC9','ecirc':'\\xEA','Ecirc':'\\xCA','egrave':'\\xE8','Egrave':'\\xC8','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','frac12':'\\xBD','frac14':'\\xBC','frac34':'\\xBE','gt':'>','GT':'>','iacute':'\\xED','Iacute':'\\xCD','icirc':'\\xEE','Icirc':'\\xCE','iexcl':'\\xA1','igrave':'\\xEC','Igrave':'\\xCC','iquest':'\\xBF','iuml':'\\xEF','Iuml':'\\xCF','laquo':'\\xAB','lt':'<','LT':'<','macr':'\\xAF','micro':'\\xB5','middot':'\\xB7','nbsp':'\\xA0','not':'\\xAC','ntilde':'\\xF1','Ntilde':'\\xD1','oacute':'\\xF3','Oacute':'\\xD3','ocirc':'\\xF4','Ocirc':'\\xD4','ograve':'\\xF2','Ograve':'\\xD2','ordf':'\\xAA','ordm':'\\xBA','oslash':'\\xF8','Oslash':'\\xD8','otilde':'\\xF5','Otilde':'\\xD5','ouml':'\\xF6','Ouml':'\\xD6','para':'\\xB6','plusmn':'\\xB1','pound':'\\xA3','quot':'\"','QUOT':'\"','raquo':'\\xBB','reg':'\\xAE','REG':'\\xAE','sect':'\\xA7','shy':'\\xAD','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','szlig':'\\xDF','thorn':'\\xFE','THORN':'\\xDE','times':'\\xD7','uacute':'\\xFA','Uacute':'\\xDA','ucirc':'\\xFB','Ucirc':'\\xDB','ugrave':'\\xF9','Ugrave':'\\xD9','uml':'\\xA8','uuml':'\\xFC','Uuml':'\\xDC','yacute':'\\xFD','Yacute':'\\xDD','yen':'\\xA5','yuml':'\\xFF'};\n\tvar decodeMapNumeric = {'0':'\\uFFFD','128':'\\u20AC','130':'\\u201A','131':'\\u0192','132':'\\u201E','133':'\\u2026','134':'\\u2020','135':'\\u2021','136':'\\u02C6','137':'\\u2030','138':'\\u0160','139':'\\u2039','140':'\\u0152','142':'\\u017D','145':'\\u2018','146':'\\u2019','147':'\\u201C','148':'\\u201D','149':'\\u2022','150':'\\u2013','151':'\\u2014','152':'\\u02DC','153':'\\u2122','154':'\\u0161','155':'\\u203A','156':'\\u0153','158':'\\u017E','159':'\\u0178'};\n\tvar invalidReferenceCodePoints = [1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65000,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\tvar object = {};\n\tvar hasOwnProperty = object.hasOwnProperty;\n\tvar has = function(object, propertyName) {\n\t\treturn hasOwnProperty.call(object, propertyName);\n\t};\n\n\tvar contains = function(array, value) {\n\t\tvar index = -1;\n\t\tvar length = array.length;\n\t\twhile (++index < length) {\n\t\t\tif (array[index] == value) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\tvar merge = function(options, defaults) {\n\t\tif (!options) {\n\t\t\treturn defaults;\n\t\t}\n\t\tvar result = {};\n\t\tvar key;\n\t\tfor (key in defaults) {\n\t\t\t// A `hasOwnProperty` check is not needed here, since only recognized\n\t\t\t// option names are used anyway. Any others are ignored.\n\t\t\tresult[key] = has(options, key) ? options[key] : defaults[key];\n\t\t}\n\t\treturn result;\n\t};\n\n\t// Modified version of `ucs2encode`; see https://mths.be/punycode.\n\tvar codePointToSymbol = function(codePoint, strict) {\n\t\tvar output = '';\n\t\tif ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {\n\t\t\t// See issue #4:\n\t\t\t// “Otherwise, if the number is in the range 0xD800 to 0xDFFF or is\n\t\t\t// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD\n\t\t\t// REPLACEMENT CHARACTER.”\n\t\t\tif (strict) {\n\t\t\t\tparseError('character reference outside the permissible Unicode range');\n\t\t\t}\n\t\t\treturn '\\uFFFD';\n\t\t}\n\t\tif (has(decodeMapNumeric, codePoint)) {\n\t\t\tif (strict) {\n\t\t\t\tparseError('disallowed character reference');\n\t\t\t}\n\t\t\treturn decodeMapNumeric[codePoint];\n\t\t}\n\t\tif (strict && contains(invalidReferenceCodePoints, codePoint)) {\n\t\t\tparseError('disallowed character reference');\n\t\t}\n\t\tif (codePoint > 0xFFFF) {\n\t\t\tcodePoint -= 0x10000;\n\t\t\toutput += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);\n\t\t\tcodePoint = 0xDC00 | codePoint & 0x3FF;\n\t\t}\n\t\toutput += stringFromCharCode(codePoint);\n\t\treturn output;\n\t};\n\n\tvar hexEscape = function(codePoint) {\n\t\treturn '&#x' + codePoint.toString(16).toUpperCase() + ';';\n\t};\n\n\tvar decEscape = function(codePoint) {\n\t\treturn '&#' + codePoint + ';';\n\t};\n\n\tvar parseError = function(message) {\n\t\tthrow Error('Parse error: ' + message);\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar encode = function(string, options) {\n\t\toptions = merge(options, encode.options);\n\t\tvar strict = options.strict;\n\t\tif (strict && regexInvalidRawCodePoint.test(string)) {\n\t\t\tparseError('forbidden code point');\n\t\t}\n\t\tvar encodeEverything = options.encodeEverything;\n\t\tvar useNamedReferences = options.useNamedReferences;\n\t\tvar allowUnsafeSymbols = options.allowUnsafeSymbols;\n\t\tvar escapeCodePoint = options.decimal ? decEscape : hexEscape;\n\n\t\tvar escapeBmpSymbol = function(symbol) {\n\t\t\treturn escapeCodePoint(symbol.charCodeAt(0));\n\t\t};\n\n\t\tif (encodeEverything) {\n\t\t\t// Encode ASCII symbols.\n\t\t\tstring = string.replace(regexAsciiWhitelist, function(symbol) {\n\t\t\t\t// Use named references if requested & possible.\n\t\t\t\tif (useNamedReferences && has(encodeMap, symbol)) {\n\t\t\t\t\treturn '&' + encodeMap[symbol] + ';';\n\t\t\t\t}\n\t\t\t\treturn escapeBmpSymbol(symbol);\n\t\t\t});\n\t\t\t// Shorten a few escapes that represent two symbols, of which at least one\n\t\t\t// is within the ASCII range.\n\t\t\tif (useNamedReferences) {\n\t\t\t\tstring = string\n\t\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\n\t\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;')\n\t\t\t\t\t.replace(/&#x66;&#x6A;/g, '&fjlig;');\n\t\t\t}\n\t\t\t// Encode non-ASCII symbols.\n\t\t\tif (useNamedReferences) {\n\t\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\n\t\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\n\t\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\n\t\t\t\t\treturn '&' + encodeMap[string] + ';';\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Note: any remaining non-ASCII symbols are handled outside of the `if`.\n\t\t} else if (useNamedReferences) {\n\t\t\t// Apply named character references.\n\t\t\t// Encode `<>\"'&` using named character references.\n\t\t\tif (!allowUnsafeSymbols) {\n\t\t\t\tstring = string.replace(regexEscape, function(string) {\n\t\t\t\t\treturn '&' + encodeMap[string] + ';'; // no need to check `has()` here\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Shorten escapes that represent two symbols, of which at least one is\n\t\t\t// `<>\"'&`.\n\t\t\tstring = string\n\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\n\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;');\n\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\n\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\n\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\n\t\t\t\treturn '&' + encodeMap[string] + ';';\n\t\t\t});\n\t\t} else if (!allowUnsafeSymbols) {\n\t\t\t// Encode `<>\"'&` using hexadecimal escapes, now that they’re not handled\n\t\t\t// using named character references.\n\t\t\tstring = string.replace(regexEscape, escapeBmpSymbol);\n\t\t}\n\t\treturn string\n\t\t\t// Encode astral symbols.\n\t\t\t.replace(regexAstralSymbols, function($0) {\n\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\tvar high = $0.charCodeAt(0);\n\t\t\t\tvar low = $0.charCodeAt(1);\n\t\t\t\tvar codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;\n\t\t\t\treturn escapeCodePoint(codePoint);\n\t\t\t})\n\t\t\t// Encode any remaining BMP symbols that are not printable ASCII symbols\n\t\t\t// using a hexadecimal escape.\n\t\t\t.replace(regexBmpWhitelist, escapeBmpSymbol);\n\t};\n\t// Expose default options (so they can be overridden globally).\n\tencode.options = {\n\t\t'allowUnsafeSymbols': false,\n\t\t'encodeEverything': false,\n\t\t'strict': false,\n\t\t'useNamedReferences': false,\n\t\t'decimal' : false\n\t};\n\n\tvar decode = function(html, options) {\n\t\toptions = merge(options, decode.options);\n\t\tvar strict = options.strict;\n\t\tif (strict && regexInvalidEntity.test(html)) {\n\t\t\tparseError('malformed character reference');\n\t\t}\n\t\treturn html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7) {\n\t\t\tvar codePoint;\n\t\t\tvar semicolon;\n\t\t\tvar decDigits;\n\t\t\tvar hexDigits;\n\t\t\tvar reference;\n\t\t\tvar next;\n\t\t\tif ($1) {\n\t\t\t\t// Decode decimal escapes, e.g. `&#119558;`.\n\t\t\t\tdecDigits = $1;\n\t\t\t\tsemicolon = $2;\n\t\t\t\tif (strict && !semicolon) {\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\n\t\t\t\t}\n\t\t\t\tcodePoint = parseInt(decDigits, 10);\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\n\t\t\t}\n\t\t\tif ($3) {\n\t\t\t\t// Decode hexadecimal escapes, e.g. `&#x1D306;`.\n\t\t\t\thexDigits = $3;\n\t\t\t\tsemicolon = $4;\n\t\t\t\tif (strict && !semicolon) {\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\n\t\t\t\t}\n\t\t\t\tcodePoint = parseInt(hexDigits, 16);\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\n\t\t\t}\n\t\t\tif ($5) {\n\t\t\t\t// Decode named character references with trailing `;`, e.g. `&copy;`.\n\t\t\t\treference = $5;\n\t\t\t\tif (has(decodeMap, reference)) {\n\t\t\t\t\treturn decodeMap[reference];\n\t\t\t\t} else {\n\t\t\t\t\t// Ambiguous ampersand. https://mths.be/notes/ambiguous-ampersands\n\t\t\t\t\tif (strict) {\n\t\t\t\t\t\tparseError(\n\t\t\t\t\t\t\t'named character reference was not terminated by a semicolon'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn $0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If we’re still here, it’s a legacy reference for sure. No need for an\n\t\t\t// extra `if` check.\n\t\t\t// Decode named character references without trailing `;`, e.g. `&amp`\n\t\t\t// This is only a parse error if it gets converted to `&`, or if it is\n\t\t\t// followed by `=` in an attribute context.\n\t\t\treference = $6;\n\t\t\tnext = $7;\n\t\t\tif (next && options.isAttributeValue) {\n\t\t\t\tif (strict && next == '=') {\n\t\t\t\t\tparseError('`&` did not start a character reference');\n\t\t\t\t}\n\t\t\t\treturn $0;\n\t\t\t} else {\n\t\t\t\tif (strict) {\n\t\t\t\t\tparseError(\n\t\t\t\t\t\t'named character reference was not terminated by a semicolon'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t// Note: there is no need to check `has(decodeMapLegacy, reference)`.\n\t\t\t\treturn decodeMapLegacy[reference] + (next || '');\n\t\t\t}\n\t\t});\n\t};\n\t// Expose default options (so they can be overridden globally).\n\tdecode.options = {\n\t\t'isAttributeValue': false,\n\t\t'strict': false\n\t};\n\n\tvar escape = function(string) {\n\t\treturn string.replace(regexEscape, function($0) {\n\t\t\t// Note: there is no need to check `has(escapeMap, $0)` here.\n\t\t\treturn escapeMap[$0];\n\t\t});\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar he = {\n\t\t'version': '1.1.1',\n\t\t'encode': encode,\n\t\t'decode': decode,\n\t\t'escape': escape,\n\t\t'unescape': decode\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\tfalse\n\t) {\n\t\tdefine(function() {\n\t\t\treturn he;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = he;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (var key in he) {\n\t\t\t\thas(he, key) && (freeExports[key] = he[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.he = he;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],49:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],50:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],51:[function(require,module,exports){\n/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n},{}],52:[function(require,module,exports){\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n},{}],53:[function(require,module,exports){\n(function (process){\nvar path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n\n}).call(this,require('_process'))\n},{\"_process\":56,\"fs\":40,\"path\":40}],54:[function(require,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}],55:[function(require,module,exports){\n(function (process){\n'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n}).call(this,require('_process'))\n},{\"_process\":56}],56:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],57:[function(require,module,exports){\nmodule.exports = require('./lib/_stream_duplex.js');\n\n},{\"./lib/_stream_duplex.js\":58}],58:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};\n},{\"./_stream_readable\":60,\"./_stream_writable\":62,\"core-util-is\":42,\"inherits\":50,\"process-nextick-args\":55}],59:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n},{\"./_stream_transform\":61,\"core-util-is\":42,\"inherits\":50}],60:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./_stream_duplex\":58,\"./internal/streams/BufferList\":63,\"./internal/streams/destroy\":64,\"./internal/streams/stream\":65,\"_process\":56,\"core-util-is\":42,\"events\":47,\"inherits\":50,\"isarray\":52,\"process-nextick-args\":55,\"safe-buffer\":70,\"string_decoder/\":72,\"util\":38}],61:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n},{\"./_stream_duplex\":58,\"core-util-is\":42,\"inherits\":50}],62:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./_stream_duplex\":58,\"./internal/streams/destroy\":64,\"./internal/streams/stream\":65,\"_process\":56,\"core-util-is\":42,\"inherits\":50,\"process-nextick-args\":55,\"safe-buffer\":70,\"util-deprecate\":73}],63:[function(require,module,exports){\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}\n},{\"safe-buffer\":70,\"util\":38}],64:[function(require,module,exports){\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};\n},{\"process-nextick-args\":55}],65:[function(require,module,exports){\nmodule.exports = require('events').EventEmitter;\n\n},{\"events\":47}],66:[function(require,module,exports){\nmodule.exports = require('./readable').PassThrough\n\n},{\"./readable\":67}],67:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":58,\"./lib/_stream_passthrough.js\":59,\"./lib/_stream_readable.js\":60,\"./lib/_stream_transform.js\":61,\"./lib/_stream_writable.js\":62}],68:[function(require,module,exports){\nmodule.exports = require('./readable').Transform\n\n},{\"./readable\":67}],69:[function(require,module,exports){\nmodule.exports = require('./lib/_stream_writable.js');\n\n},{\"./lib/_stream_writable.js\":62}],70:[function(require,module,exports){\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n},{\"buffer\":41}],71:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":47,\"inherits\":50,\"readable-stream/duplex.js\":57,\"readable-stream/passthrough.js\":66,\"readable-stream/readable.js\":67,\"readable-stream/transform.js\":68,\"readable-stream/writable.js\":69}],72:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n},{\"safe-buffer\":70}],73:[function(require,module,exports){\n(function (global){\n\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],74:[function(require,module,exports){\narguments[4][50][0].apply(exports,arguments)\n},{\"dup\":50}],75:[function(require,module,exports){\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n},{}],76:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./support/isBuffer\":75,\"_process\":56,\"inherits\":74}]},{},[1]);\n"

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),

/***/ "./node_modules/script-loader/index.js!./node_modules/mocha/mocha.js":
/*!******************************************************************!*\
  !*** ./node_modules/script-loader!./node_modules/mocha/mocha.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/mocha/mocha.js */ "./node_modules/raw-loader/index.js!./node_modules/mocha/mocha.js"))

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbW9jaGEuY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9tb2NoYS5jc3M/ZDZlNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhLWxvYWRlci9zdGFydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL3dlYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9tb2NoYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL21vY2hhLmpzPzNmNjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQTBDLGdD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QUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FB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LG1DQUFtQyxHQUFHLDhCQUE4Qiw0QkFBNEIsbUNBQW1DLEdBQUcsOEJBQThCLDRCQUE0QixtQ0FBbUMsR0FBRyw4QkFBOEIsK0JBQStCLDBCQUEwQixHQUFHLG9DQUFvQywyQkFBMkIsb0VBQW9FLEdBQUcsOEJBQThCLDRCQUE0QixtREFBbUQsR0FBRyw4QkFBOEIsd0JBQXdCLGdFQUFnRSxHQUFHLDBCQUEwQix5QkFBeUIsZ0dBQWdHLEdBQUcsNEJBQTRCLDhCQUE4QixxQ0FBcUMsR0FBRyxrQ0FBa0MsK0JBQStCLG9PQUFvTyxHQUFHLG9DQUFvQyxxREFBcUQsZ0NBQWdDLDZDQUE2QyxHQUFHLHVCQUF1QiwwREFBMEQsR0FBRyx1SEFBdUgsOENBQThDLHVCQUF1QixxSEFBcUgsK0RBQStELEdBQUcsd0dBQXdHLGtGQUFrRixJQUFJLGtkQUFrZCxTQUFTLHFGQUFxRixTQUFTLHdHQUF3Ryw2Q0FBNkMsNkZBQTZGLGtDQUFrQyx3QkFBd0IsaUJBQWlCLHFDQUFxQyxLQUFLLGtCQUFrQixJQUFJLHdDQUF3QywyREFBMkQsR0FBRyxLQUFLLCtKQUErSixJQUFJLEVBQUUsMERBQTBELEVBQUUsR0FBRyxNQUFNLEc7Ozs7Ozs7Ozs7O0FDQTlzamdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzFCQSwyUSIsImZpbGUiOiJ0ZXN0LmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vbm9kZV9tb2R1bGVzL21vY2hhLWxvYWRlci9pbmRleC5qcyEuL3Rlc3QvaW5kZXguanNcIik7XG4iLCJyZXF1aXJlKFwiISEvVXNlcnMvcGtpbS9Eb2N1bWVudHMvVHVyaW5nIE1haW4vTW9kMi9nYW1lLXRpbWUvbm9kZV9tb2R1bGVzL21vY2hhLWxvYWRlci93ZWIuanNcIik7XG5pZih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaW5pdE1vY2hhUGhhbnRvbUpTKSB7IHdpbmRvdy5pbml0TW9jaGFQaGFudG9tSlMoKTsgfVxubW9jaGEuc2V0dXAoe1widWlcIjpcImJkZFwifSk7XG5yZXF1aXJlKFwiISEvVXNlcnMvcGtpbS9Eb2N1bWVudHMvVHVyaW5nIE1haW4vTW9kMi9nYW1lLXRpbWUvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhL1VzZXJzL3BraW0vRG9jdW1lbnRzL1R1cmluZyBNYWluL01vZDIvZ2FtZS10aW1lL3Rlc3QvaW5kZXguanNcIilcbnJlcXVpcmUoXCIhIS9Vc2Vycy9wa2ltL0RvY3VtZW50cy9UdXJpbmcgTWFpbi9Nb2QyL2dhbWUtdGltZS9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL3N0YXJ0LmpzXCIpO1xuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdCgpO1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG5cdFx0bW9jaGEuc3VpdGUuc3VpdGVzLmxlbmd0aCA9IDA7XG5cdFx0dmFyIHN0YXRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhLXN0YXRzJyk7XG5cdFx0dmFyIHJlcG9ydCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYS1yZXBvcnQnKTtcblx0XHRzdGF0cyAmJiBzdGF0cy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0YXRzKTtcblx0XHRyZXBvcnQgJiYgcmVwb3J0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocmVwb3J0KTtcblx0fSk7XG59IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL21vY2hhLWxvYWRlci9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcInV0Zi04XFxcIjtcXG5cXG5ib2R5IHtcXG4gIG1hcmdpbjowO1xcbn1cXG5cXG4jbW9jaGEge1xcbiAgZm9udDogMjBweC8xLjUgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcXG4gIG1hcmdpbjogNjBweCA1MHB4O1xcbn1cXG5cXG4jbW9jaGEgdWwsXFxuI21vY2hhIGxpIHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbiNtb2NoYSB1bCB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbn1cXG5cXG4jbW9jaGEgaDEsXFxuI21vY2hhIGgyIHtcXG4gIG1hcmdpbjogMDtcXG59XFxuXFxuI21vY2hhIGgxIHtcXG4gIG1hcmdpbi10b3A6IDE1cHg7XFxuICBmb250LXNpemU6IDFlbTtcXG4gIGZvbnQtd2VpZ2h0OiAyMDA7XFxufVxcblxcbiNtb2NoYSBoMSBhIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbn1cXG5cXG4jbW9jaGEgaDEgYTpob3ZlciB7XFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG59XFxuXFxuI21vY2hhIC5zdWl0ZSAuc3VpdGUgaDEge1xcbiAgbWFyZ2luLXRvcDogMDtcXG4gIGZvbnQtc2l6ZTogLjhlbTtcXG59XFxuXFxuI21vY2hhIC5oaWRkZW4ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuI21vY2hhIGgyIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbiNtb2NoYSAuc3VpdGUge1xcbiAgbWFyZ2luLWxlZnQ6IDE1cHg7XFxufVxcblxcbiNtb2NoYSAudGVzdCB7XFxuICBtYXJnaW4tbGVmdDogMTVweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbiNtb2NoYSAudGVzdC5wZW5kaW5nOmhvdmVyIGgyOjphZnRlciB7XFxuICBjb250ZW50OiAnKHBlbmRpbmcpJztcXG4gIGZvbnQtZmFtaWx5OiBhcmlhbCwgc2Fucy1zZXJpZjtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBhc3MubWVkaXVtIC5kdXJhdGlvbiB7XFxuICBiYWNrZ3JvdW5kOiAjYzA5ODUzO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzcy5zbG93IC5kdXJhdGlvbiB7XFxuICBiYWNrZ3JvdW5kOiAjYjk0YTQ4O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzczo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6ICdcXFxcMjcxMyc7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICBjb2xvcjogIzAwZDZiMjtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBhc3MgLmR1cmF0aW9uIHtcXG4gIGZvbnQtc2l6ZTogOXB4O1xcbiAgbWFyZ2luLWxlZnQ6IDVweDtcXG4gIHBhZGRpbmc6IDJweCA1cHg7XFxuICBjb2xvcjogI2ZmZjtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogaW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjIpO1xcbiAgLW1vei1ib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwuMik7XFxuICBib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwuMik7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDVweDtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgLW1zLWJvcmRlci1yYWRpdXM6IDVweDtcXG4gIC1vLWJvcmRlci1yYWRpdXM6IDVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBhc3MuZmFzdCAuZHVyYXRpb24ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBlbmRpbmcge1xcbiAgY29sb3I6ICMwYjk3YzQ7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wZW5kaW5nOjpiZWZvcmUge1xcbiAgY29udGVudDogJ1xcXFwyNUU2JztcXG4gIGNvbG9yOiAjMGI5N2M0O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QuZmFpbCB7XFxuICBjb2xvcjogI2MwMDtcXG59XFxuXFxuI21vY2hhIC50ZXN0LmZhaWwgcHJlIHtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuI21vY2hhIC50ZXN0LmZhaWw6OmJlZm9yZSB7XFxuICBjb250ZW50OiAnXFxcXDI3MTYnO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmbG9hdDogbGVmdDtcXG4gIG1hcmdpbi1yaWdodDogNXB4O1xcbiAgY29sb3I6ICNjMDA7XFxufVxcblxcbiNtb2NoYSAudGVzdCBwcmUuZXJyb3Ige1xcbiAgY29sb3I6ICNjMDA7XFxuICBtYXgtaGVpZ2h0OiAzMDBweDtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QgLmh0bWwtZXJyb3Ige1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxuICBjb2xvcjogYmxhY2s7XFxuICBsaW5lLWhlaWdodDogMS41O1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmbG9hdDogbGVmdDtcXG4gIGNsZWFyOiBsZWZ0O1xcbiAgZm9udDogMTJweC8xLjUgbW9uYWNvLCBtb25vc3BhY2U7XFxuICBtYXJnaW46IDVweDtcXG4gIHBhZGRpbmc6IDE1cHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZWVlO1xcbiAgbWF4LXdpZHRoOiA4NSU7IC8qKDEpKi9cXG4gIG1heC13aWR0aDogLXdlYmtpdC1jYWxjKDEwMCUgLSA0MnB4KTtcXG4gIG1heC13aWR0aDogLW1vei1jYWxjKDEwMCUgLSA0MnB4KTtcXG4gIG1heC13aWR0aDogY2FsYygxMDAlIC0gNDJweCk7IC8qKDIpKi9cXG4gIG1heC1oZWlnaHQ6IDMwMHB4O1xcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogI2RkZDtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICAtbW96LWJveC1zaGFkb3c6IDAgMXB4IDNweCAjZWVlO1xcbiAgYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDNweDtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QgLmh0bWwtZXJyb3IgcHJlLmVycm9yIHtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogMDtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogMDtcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDA7XFxuICAtbW96LWJveC1zaGFkb3c6IDA7XFxuICBib3gtc2hhZG93OiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG4gIG1hcmdpbi10b3A6IDE4cHg7XFxuICBtYXgtaGVpZ2h0OiBub25lO1xcbn1cXG5cXG4vKipcXG4gKiAoMSk6IGFwcHJveGltYXRlIGZvciBicm93c2VycyBub3Qgc3VwcG9ydGluZyBjYWxjXFxuICogKDIpOiA0MiA9IDIqMTUgKyAyKjEwICsgMioxIChwYWRkaW5nICsgbWFyZ2luICsgYm9yZGVyKVxcbiAqICAgICAgXl4gc2VyaW91c2x5XFxuICovXFxuI21vY2hhIC50ZXN0IHByZSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgY2xlYXI6IGxlZnQ7XFxuICBmb250OiAxMnB4LzEuNSBtb25hY28sIG1vbm9zcGFjZTtcXG4gIG1hcmdpbjogNXB4O1xcbiAgcGFkZGluZzogMTVweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XFxuICBtYXgtd2lkdGg6IDg1JTsgLyooMSkqL1xcbiAgbWF4LXdpZHRoOiAtd2Via2l0LWNhbGMoMTAwJSAtIDQycHgpO1xcbiAgbWF4LXdpZHRoOiAtbW96LWNhbGMoMTAwJSAtIDQycHgpO1xcbiAgbWF4LXdpZHRoOiBjYWxjKDEwMCUgLSA0MnB4KTsgLyooMikqL1xcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogI2RkZDtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICAtbW96LWJveC1zaGFkb3c6IDAgMXB4IDNweCAjZWVlO1xcbiAgYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDNweDtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QgaDIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QgYS5yZXBsYXkge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAzcHg7XFxuICByaWdodDogMDtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAxNXB4O1xcbiAgaGVpZ2h0OiAxNXB4O1xcbiAgbGluZS1oZWlnaHQ6IDE1cHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBiYWNrZ3JvdW5kOiAjZWVlO1xcbiAgZm9udC1zaXplOiAxNXB4O1xcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogMTVweDtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IDIwMG1zO1xcbiAgLW1vei10cmFuc2l0aW9uOm9wYWNpdHkgMjAwbXM7XFxuICAtby10cmFuc2l0aW9uOm9wYWNpdHkgMjAwbXM7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDIwMG1zO1xcbiAgb3BhY2l0eTogMC4zO1xcbiAgY29sb3I6ICM4ODg7XFxufVxcblxcbiNtb2NoYSAudGVzdDpob3ZlciBhLnJlcGxheSB7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG5cXG4jbW9jaGEtcmVwb3J0LnBhc3MgLnRlc3QuZmFpbCB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4jbW9jaGEtcmVwb3J0LmZhaWwgLnRlc3QucGFzcyB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4jbW9jaGEtcmVwb3J0LnBlbmRpbmcgLnRlc3QucGFzcyxcXG4jbW9jaGEtcmVwb3J0LnBlbmRpbmcgLnRlc3QuZmFpbCB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4jbW9jaGEtcmVwb3J0LnBlbmRpbmcgLnRlc3QucGFzcy5wZW5kaW5nIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG4jbW9jaGEtZXJyb3Ige1xcbiAgY29sb3I6ICNjMDA7XFxuICBmb250LXNpemU6IDEuNWVtO1xcbiAgZm9udC13ZWlnaHQ6IDEwMDtcXG4gIGxldHRlci1zcGFjaW5nOiAxcHg7XFxufVxcblxcbiNtb2NoYS1zdGF0cyB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDE1cHg7XFxuICByaWdodDogMTBweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIG1hcmdpbjogMDtcXG4gIGNvbG9yOiAjODg4O1xcbiAgei1pbmRleDogMTtcXG59XFxuXFxuI21vY2hhLXN0YXRzIC5wcm9ncmVzcyB7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBwYWRkaW5nLXRvcDogMDtcXG5cXG4gIC8qKlxcbiAgICogU2V0IHNhZmUgaW5pdGlhbCB2YWx1ZXMsIHNvIG1vY2hhcyAucHJvZ3Jlc3MgZG9lcyBub3QgaW5oZXJpdCB0aGVzZVxcbiAgICogcHJvcGVydGllcyBmcm9tIEJvb3RzdHJhcCAucHJvZ3Jlc3MgKHdoaWNoIGNhdXNlcyAucHJvZ3Jlc3MgaGVpZ2h0IHRvXFxuICAgKiBlcXVhbCBsaW5lIGhlaWdodCBzZXQgaW4gQm9vdHN0cmFwKS5cXG4gICAqL1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgLW1vei1ib3gtc2hhZG93OiBub25lO1xcbiAgYm94LXNoYWRvdzogbm9uZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IGluaXRpYWw7XFxufVxcblxcbiNtb2NoYS1zdGF0cyBlbSB7XFxuICBjb2xvcjogYmxhY2s7XFxufVxcblxcbiNtb2NoYS1zdGF0cyBhIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbn1cXG5cXG4jbW9jaGEtc3RhdHMgYTpob3ZlciB7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZTtcXG59XFxuXFxuI21vY2hhLXN0YXRzIGxpIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG1hcmdpbjogMCA1cHg7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgcGFkZGluZy10b3A6IDExcHg7XFxufVxcblxcbiNtb2NoYS1zdGF0cyBjYW52YXMge1xcbiAgd2lkdGg6IDQwcHg7XFxuICBoZWlnaHQ6IDQwcHg7XFxufVxcblxcbiNtb2NoYSBjb2RlIC5jb21tZW50IHsgY29sb3I6ICNkZGQ7IH1cXG4jbW9jaGEgY29kZSAuaW5pdCB7IGNvbG9yOiAjMmY2ZmFkOyB9XFxuI21vY2hhIGNvZGUgLnN0cmluZyB7IGNvbG9yOiAjNTg5MGFkOyB9XFxuI21vY2hhIGNvZGUgLmtleXdvcmQgeyBjb2xvcjogIzhhNjM0MzsgfVxcbiNtb2NoYSBjb2RlIC5udW1iZXIgeyBjb2xvcjogIzJmNmZhZDsgfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtZGV2aWNlLXdpZHRoOiA0ODBweCkge1xcbiAgI21vY2hhIHtcXG4gICAgbWFyZ2luOiA2MHB4IDBweDtcXG4gIH1cXG5cXG4gICNtb2NoYSAjc3RhdHMge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB9XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cbiIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9tb2NoYS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9tb2NoYS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL21vY2hhLWxvYWRlci9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL21vY2hhLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50byArIFwiIFwiICsgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iLCJwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRkZWxldGUgcmVxdWlyZS5jYWNoZVttb2R1bGUuaWRdO1xuXHRpZih0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5tb2NoYVBoYW50b21KUylcblx0XHRtb2NoYVBoYW50b21KUy5ydW4oKTtcblx0ZWxzZVxuXHRcdG1vY2hhLnJ1bigpO1xufSk7XG4iLCJpZiAoISBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1vY2hhXCIpKSB7IGRvY3VtZW50LndyaXRlKFwiPGRpdiBpZD1cXFwibW9jaGFcXFwiPjwvZGl2PlwiKTsgfVxuXG5yZXF1aXJlKFwiIXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyIW1vY2hhL21vY2hhLmNzc1wiKTtcbnJlcXVpcmUoXCIhc2NyaXB0LWxvYWRlciFtb2NoYS9tb2NoYS5qc1wiKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXFxcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXFxcIitpK1xcXCInXFxcIik7dGhyb3cgYS5jb2RlPVxcXCJNT0RVTEVfTk9UX0ZPVU5EXFxcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBvZmYgKi9cXG4vKiBlc2xpbnQtZW52IGNvbW1vbmpzICovXFxuXFxuLyoqXFxuICogU2hpbSBwcm9jZXNzLnN0ZG91dC5cXG4gKi9cXG5cXG5wcm9jZXNzLnN0ZG91dCA9IHJlcXVpcmUoJ2Jyb3dzZXItc3Rkb3V0Jykoe2xldmVsOiBmYWxzZX0pO1xcblxcbnZhciBNb2NoYSA9IHJlcXVpcmUoJy4vbGliL21vY2hhJyk7XFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgTW9jaGEgaW5zdGFuY2UuXFxuICpcXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XFxuICovXFxuXFxudmFyIG1vY2hhID0gbmV3IE1vY2hhKHtyZXBvcnRlcjogJ2h0bWwnfSk7XFxuXFxuLyoqXFxuICogU2F2ZSB0aW1lciByZWZlcmVuY2VzIHRvIGF2b2lkIFNpbm9uIGludGVyZmVyaW5nIChzZWUgR0gtMjM3KS5cXG4gKi9cXG5cXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XFxudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XFxuXFxudmFyIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMgPSBbXTtcXG5cXG52YXIgb3JpZ2luYWxPbmVycm9ySGFuZGxlciA9IGdsb2JhbC5vbmVycm9yO1xcblxcbi8qKlxcbiAqIFJlbW92ZSB1bmNhdWdodEV4Y2VwdGlvbiBsaXN0ZW5lci5cXG4gKiBSZXZlcnQgdG8gb3JpZ2luYWwgb25lcnJvciBoYW5kbGVyIGlmIHByZXZpb3VzbHkgZGVmaW5lZC5cXG4gKi9cXG5cXG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZSwgZm4pIHtcXG4gIGlmIChlID09PSAndW5jYXVnaHRFeGNlcHRpb24nKSB7XFxuICAgIGlmIChvcmlnaW5hbE9uZXJyb3JIYW5kbGVyKSB7XFxuICAgICAgZ2xvYmFsLm9uZXJyb3IgPSBvcmlnaW5hbE9uZXJyb3JIYW5kbGVyO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGdsb2JhbC5vbmVycm9yID0gZnVuY3Rpb24oKSB7fTtcXG4gICAgfVxcbiAgICB2YXIgaSA9IHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMuaW5kZXhPZihmbik7XFxuICAgIGlmIChpICE9PSAtMSkge1xcbiAgICAgIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMuc3BsaWNlKGksIDEpO1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBJbXBsZW1lbnRzIHVuY2F1Z2h0RXhjZXB0aW9uIGxpc3RlbmVyLlxcbiAqL1xcblxcbnByb2Nlc3Mub24gPSBmdW5jdGlvbihlLCBmbikge1xcbiAgaWYgKGUgPT09ICd1bmNhdWdodEV4Y2VwdGlvbicpIHtcXG4gICAgZ2xvYmFsLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIsIHVybCwgbGluZSkge1xcbiAgICAgIGZuKG5ldyBFcnJvcihlcnIgKyAnICgnICsgdXJsICsgJzonICsgbGluZSArICcpJykpO1xcbiAgICAgIHJldHVybiAhbW9jaGEuYWxsb3dVbmNhdWdodDtcXG4gICAgfTtcXG4gICAgdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycy5wdXNoKGZuKTtcXG4gIH1cXG59O1xcblxcbi8vIFRoZSBCREQgVUkgaXMgcmVnaXN0ZXJlZCBieSBkZWZhdWx0LCBidXQgbm8gVUkgd2lsbCBiZSBmdW5jdGlvbmFsIGluIHRoZVxcbi8vIGJyb3dzZXIgd2l0aG91dCBhbiBleHBsaWNpdCBjYWxsIHRvIHRoZSBvdmVycmlkZGVuIGBtb2NoYS51aWAgKHNlZSBiZWxvdykuXFxuLy8gRW5zdXJlIHRoYXQgdGhpcyBkZWZhdWx0IFVJIGRvZXMgbm90IGV4cG9zZSBpdHMgbWV0aG9kcyB0byB0aGUgZ2xvYmFsIHNjb3BlLlxcbm1vY2hhLnN1aXRlLnJlbW92ZUFsbExpc3RlbmVycygncHJlLXJlcXVpcmUnKTtcXG5cXG52YXIgaW1tZWRpYXRlUXVldWUgPSBbXTtcXG52YXIgaW1tZWRpYXRlVGltZW91dDtcXG5cXG5mdW5jdGlvbiB0aW1lc2xpY2UoKSB7XFxuICB2YXIgaW1tZWRpYXRlU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG4gIHdoaWxlIChpbW1lZGlhdGVRdWV1ZS5sZW5ndGggJiYgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBpbW1lZGlhdGVTdGFydCA8IDEwMCkge1xcbiAgICBpbW1lZGlhdGVRdWV1ZS5zaGlmdCgpKCk7XFxuICB9XFxuICBpZiAoaW1tZWRpYXRlUXVldWUubGVuZ3RoKSB7XFxuICAgIGltbWVkaWF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHRpbWVzbGljZSwgMCk7XFxuICB9IGVsc2Uge1xcbiAgICBpbW1lZGlhdGVUaW1lb3V0ID0gbnVsbDtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogSGlnaC1wZXJmb3JtYW5jZSBvdmVycmlkZSBvZiBSdW5uZXIuaW1tZWRpYXRlbHkuXFxuICovXFxuXFxuTW9jaGEuUnVubmVyLmltbWVkaWF0ZWx5ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcXG4gIGltbWVkaWF0ZVF1ZXVlLnB1c2goY2FsbGJhY2spO1xcbiAgaWYgKCFpbW1lZGlhdGVUaW1lb3V0KSB7XFxuICAgIGltbWVkaWF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHRpbWVzbGljZSwgMCk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBGdW5jdGlvbiB0byBhbGxvdyBhc3NlcnRpb24gbGlicmFyaWVzIHRvIHRocm93IGVycm9ycyBkaXJlY3RseSBpbnRvIG1vY2hhLlxcbiAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gcnVubmluZyB0ZXN0cyBpbiBhIGJyb3dzZXIgYmVjYXVzZSB3aW5kb3cub25lcnJvciB3aWxsXFxuICogb25seSByZWNlaXZlIHRoZSAnbWVzc2FnZScgYXR0cmlidXRlIG9mIHRoZSBFcnJvci5cXG4gKi9cXG5tb2NoYS50aHJvd0Vycm9yID0gZnVuY3Rpb24oZXJyKSB7XFxuICB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oZm4pIHtcXG4gICAgZm4oZXJyKTtcXG4gIH0pO1xcbiAgdGhyb3cgZXJyO1xcbn07XFxuXFxuLyoqXFxuICogT3ZlcnJpZGUgdWkgdG8gZW5zdXJlIHRoYXQgdGhlIHVpIGZ1bmN0aW9ucyBhcmUgaW5pdGlhbGl6ZWQuXFxuICogTm9ybWFsbHkgdGhpcyB3b3VsZCBoYXBwZW4gaW4gTW9jaGEucHJvdG90eXBlLmxvYWRGaWxlcy5cXG4gKi9cXG5cXG5tb2NoYS51aSA9IGZ1bmN0aW9uKHVpKSB7XFxuICBNb2NoYS5wcm90b3R5cGUudWkuY2FsbCh0aGlzLCB1aSk7XFxuICB0aGlzLnN1aXRlLmVtaXQoJ3ByZS1yZXF1aXJlJywgZ2xvYmFsLCBudWxsLCB0aGlzKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0dXAgbW9jaGEgd2l0aCB0aGUgZ2l2ZW4gc2V0dGluZyBvcHRpb25zLlxcbiAqL1xcblxcbm1vY2hhLnNldHVwID0gZnVuY3Rpb24ob3B0cykge1xcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xcbiAgICBvcHRzID0ge3VpOiBvcHRzfTtcXG4gIH1cXG4gIGZvciAodmFyIG9wdCBpbiBvcHRzKSB7XFxuICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KG9wdCkpIHtcXG4gICAgICB0aGlzW29wdF0ob3B0c1tvcHRdKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gbW9jaGEsIHJldHVybmluZyB0aGUgUnVubmVyLlxcbiAqL1xcblxcbm1vY2hhLnJ1biA9IGZ1bmN0aW9uKGZuKSB7XFxuICB2YXIgb3B0aW9ucyA9IG1vY2hhLm9wdGlvbnM7XFxuICBtb2NoYS5nbG9iYWxzKCdsb2NhdGlvbicpO1xcblxcbiAgdmFyIHF1ZXJ5ID0gTW9jaGEudXRpbHMucGFyc2VRdWVyeShnbG9iYWwubG9jYXRpb24uc2VhcmNoIHx8ICcnKTtcXG4gIGlmIChxdWVyeS5ncmVwKSB7XFxuICAgIG1vY2hhLmdyZXAocXVlcnkuZ3JlcCk7XFxuICB9XFxuICBpZiAocXVlcnkuZmdyZXApIHtcXG4gICAgbW9jaGEuZmdyZXAocXVlcnkuZmdyZXApO1xcbiAgfVxcbiAgaWYgKHF1ZXJ5LmludmVydCkge1xcbiAgICBtb2NoYS5pbnZlcnQoKTtcXG4gIH1cXG5cXG4gIHJldHVybiBNb2NoYS5wcm90b3R5cGUucnVuLmNhbGwobW9jaGEsIGZ1bmN0aW9uKGVycikge1xcbiAgICAvLyBUaGUgRE9NIERvY3VtZW50IGlzIG5vdCBhdmFpbGFibGUgaW4gV2ViIFdvcmtlcnMuXFxuICAgIHZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcXG4gICAgaWYgKFxcbiAgICAgIGRvY3VtZW50ICYmXFxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhJykgJiZcXG4gICAgICBvcHRpb25zLm5vSGlnaGxpZ2h0aW5nICE9PSB0cnVlXFxuICAgICkge1xcbiAgICAgIE1vY2hhLnV0aWxzLmhpZ2hsaWdodFRhZ3MoJ2NvZGUnKTtcXG4gICAgfVxcbiAgICBpZiAoZm4pIHtcXG4gICAgICBmbihlcnIpO1xcbiAgICB9XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEV4cG9zZSB0aGUgcHJvY2VzcyBzaGltLlxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2NoYWpzL21vY2hhL3B1bGwvOTE2XFxuICovXFxuXFxuTW9jaGEucHJvY2VzcyA9IHByb2Nlc3M7XFxuXFxuLyoqXFxuICogRXhwb3NlIG1vY2hhLlxcbiAqL1xcblxcbmdsb2JhbC5Nb2NoYSA9IE1vY2hhO1xcbmdsb2JhbC5tb2NoYSA9IG1vY2hhO1xcblxcbi8vIHRoaXMgYWxsb3dzIHRlc3QvYWNjZXB0YW5jZS9yZXF1aXJlZC10b2tlbnMuanMgdG8gcGFzczsgdGh1cyxcXG4vLyB5b3UgY2FuIG5vdyBkbyBgY29uc3QgZGVzY3JpYmUgPSByZXF1aXJlKCdtb2NoYScpLmRlc2NyaWJlYCBpbiBhXFxuLy8gYnJvd3NlciBjb250ZXh0IChhc3N1bWluZyBicm93c2VyaWZpY2F0aW9uKS4gIHNob3VsZCBmaXggIzg4MFxcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4vbGliL21vY2hhXFxcIjoxMyxcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJicm93c2VyLXN0ZG91dFxcXCI6Mzl9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLy8ganVzdCBzdHViIG91dCBncm93bFxcblxcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5ub29wO1xcblxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzZ9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBQcm9ncmVzc2AuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBQcm9ncmVzcztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBQcm9ncmVzc2AgaW5kaWNhdG9yLlxcbiAqL1xcbmZ1bmN0aW9uIFByb2dyZXNzKCkge1xcbiAgdGhpcy5wZXJjZW50ID0gMDtcXG4gIHRoaXMuc2l6ZSgwKTtcXG4gIHRoaXMuZm9udFNpemUoMTEpO1xcbiAgdGhpcy5mb250KCdoZWx2ZXRpY2EsIGFyaWFsLCBzYW5zLXNlcmlmJyk7XFxufVxcblxcbi8qKlxcbiAqIFNldCBwcm9ncmVzcyBzaXplIHRvIGBzaXplYC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbihzaXplKSB7XFxuICB0aGlzLl9zaXplID0gc2l6ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRleHQgdG8gYHRleHRgLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcXG4gIHRoaXMuX3RleHQgPSB0ZXh0O1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgZm9udCBzaXplIHRvIGBzaXplYC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLmZvbnRTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xcbiAgdGhpcy5fZm9udFNpemUgPSBzaXplO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgZm9udCB0byBgZmFtaWx5YC5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBmYW1pbHlcXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLmZvbnQgPSBmdW5jdGlvbihmYW1pbHkpIHtcXG4gIHRoaXMuX2ZvbnQgPSBmYW1pbHk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFVwZGF0ZSBwZXJjZW50YWdlIHRvIGBuYC5cXG4gKlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHJldHVybiB7UHJvZ3Jlc3N9IFByb2dyZXNzIGluc3RhbmNlLlxcbiAqL1xcblByb2dyZXNzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihuKSB7XFxuICB0aGlzLnBlcmNlbnQgPSBuO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBEcmF3IG9uIGBjdHhgLlxcbiAqXFxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MmR9IGN0eFxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCkge1xcbiAgdHJ5IHtcXG4gICAgdmFyIHBlcmNlbnQgPSBNYXRoLm1pbih0aGlzLnBlcmNlbnQsIDEwMCk7XFxuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcXG4gICAgdmFyIGhhbGYgPSBzaXplIC8gMjtcXG4gICAgdmFyIHggPSBoYWxmO1xcbiAgICB2YXIgeSA9IGhhbGY7XFxuICAgIHZhciByYWQgPSBoYWxmIC0gMTtcXG4gICAgdmFyIGZvbnRTaXplID0gdGhpcy5fZm9udFNpemU7XFxuXFxuICAgIGN0eC5mb250ID0gZm9udFNpemUgKyAncHggJyArIHRoaXMuX2ZvbnQ7XFxuXFxuICAgIHZhciBhbmdsZSA9IE1hdGguUEkgKiAyICogKHBlcmNlbnQgLyAxMDApO1xcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHNpemUsIHNpemUpO1xcblxcbiAgICAvLyBvdXRlciBjaXJjbGVcXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJyM5ZjlmOWYnO1xcbiAgICBjdHguYmVnaW5QYXRoKCk7XFxuICAgIGN0eC5hcmMoeCwgeSwgcmFkLCAwLCBhbmdsZSwgZmFsc2UpO1xcbiAgICBjdHguc3Ryb2tlKCk7XFxuXFxuICAgIC8vIGlubmVyIGNpcmNsZVxcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnI2VlZSc7XFxuICAgIGN0eC5iZWdpblBhdGgoKTtcXG4gICAgY3R4LmFyYyh4LCB5LCByYWQgLSAxLCAwLCBhbmdsZSwgdHJ1ZSk7XFxuICAgIGN0eC5zdHJva2UoKTtcXG5cXG4gICAgLy8gdGV4dFxcbiAgICB2YXIgdGV4dCA9IHRoaXMuX3RleHQgfHwgKHBlcmNlbnQgfCAwKSArICclJztcXG4gICAgdmFyIHcgPSBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XFxuXFxuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCB4IC0gdyAvIDIgKyAxLCB5ICsgZm9udFNpemUgLyAyIC0gMSk7XFxuICB9IGNhdGNoIChpZ25vcmUpIHtcXG4gICAgLy8gZG9uJ3QgZmFpbCBpZiB3ZSBjYW4ndCByZW5kZXIgcHJvZ3Jlc3NcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxufSx7fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG5leHBvcnRzLmlzYXR0eSA9IGZ1bmN0aW9uIGlzYXR0eSgpIHtcXG4gIHJldHVybiB0cnVlO1xcbn07XFxuXFxuZXhwb3J0cy5nZXRXaW5kb3dTaXplID0gZnVuY3Rpb24gZ2V0V2luZG93U2l6ZSgpIHtcXG4gIGlmICgnaW5uZXJIZWlnaHQnIGluIGdsb2JhbCkge1xcbiAgICByZXR1cm4gW2dsb2JhbC5pbm5lckhlaWdodCwgZ2xvYmFsLmlubmVyV2lkdGhdO1xcbiAgfVxcbiAgLy8gSW4gYSBXZWIgV29ya2VyLCB0aGUgRE9NIFdpbmRvdyBpcyBub3QgYXZhaWxhYmxlLlxcbiAgcmV0dXJuIFs2NDAsIDQ4MF07XFxufTtcXG5cXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBDb250ZXh0XFxuICovXFxuLyoqXFxuICogRXhwb3NlIGBDb250ZXh0YC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRleHQ7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgQ29udGV4dGAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5mdW5jdGlvbiBDb250ZXh0KCkge31cXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IHRoZSBjb250ZXh0IGBSdW5uYWJsZWAgdG8gYHJ1bm5hYmxlYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7UnVubmFibGV9IHJ1bm5hYmxlXFxuICogQHJldHVybiB7Q29udGV4dH0gY29udGV4dFxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnJ1bm5hYmxlID0gZnVuY3Rpb24ocnVubmFibGUpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fcnVubmFibGU7XFxuICB9XFxuICB0aGlzLnRlc3QgPSB0aGlzLl9ydW5uYWJsZSA9IHJ1bm5hYmxlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IHRlc3QgdGltZW91dCBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG1zXFxuICogQHJldHVybiB7Q29udGV4dH0gc2VsZlxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbihtcykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLnJ1bm5hYmxlKCkudGltZW91dCgpO1xcbiAgfVxcbiAgdGhpcy5ydW5uYWJsZSgpLnRpbWVvdXQobXMpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGVzdCB0aW1lb3V0IGBlbmFibGVkYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxcbiAqIEByZXR1cm4ge0NvbnRleHR9IHNlbGZcXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS5lbmFibGVUaW1lb3V0cyA9IGZ1bmN0aW9uKGVuYWJsZWQpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5ydW5uYWJsZSgpLmVuYWJsZVRpbWVvdXRzKCk7XFxuICB9XFxuICB0aGlzLnJ1bm5hYmxlKCkuZW5hYmxlVGltZW91dHMoZW5hYmxlZCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgdGVzdCBzbG93bmVzcyB0aHJlc2hvbGQgYG1zYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc1xcbiAqIEByZXR1cm4ge0NvbnRleHR9IHNlbGZcXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS5zbG93ID0gZnVuY3Rpb24obXMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5ydW5uYWJsZSgpLnNsb3coKTtcXG4gIH1cXG4gIHRoaXMucnVubmFibGUoKS5zbG93KG1zKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogTWFyayBhIHRlc3QgYXMgc2tpcHBlZC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEB0aHJvd3MgUGVuZGluZ1xcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbigpIHtcXG4gIHRoaXMucnVubmFibGUoKS5za2lwKCk7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IGEgbnVtYmVyIG9mIGFsbG93ZWQgcmV0cmllcyBvbiBmYWlsZWQgdGVzdHNcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHJldHVybiB7Q29udGV4dH0gc2VsZlxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbihuKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMucnVubmFibGUoKS5yZXRyaWVzKCk7XFxuICB9XFxuICB0aGlzLnJ1bm5hYmxlKCkucmV0cmllcyhuKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxufSx7fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBSdW5uYWJsZSA9IHJlcXVpcmUoJy4vcnVubmFibGUnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuL3V0aWxzJykuaW5oZXJpdHM7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBIb29rYC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IEhvb2s7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgSG9va2Agd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYFxcbiAqXFxuICogQGNsYXNzXFxuICogQGV4dGVuZHMgUnVubmFibGVcXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcbmZ1bmN0aW9uIEhvb2sodGl0bGUsIGZuKSB7XFxuICBSdW5uYWJsZS5jYWxsKHRoaXMsIHRpdGxlLCBmbik7XFxuICB0aGlzLnR5cGUgPSAnaG9vayc7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgUnVubmFibGUucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhIb29rLCBSdW5uYWJsZSk7XFxuXFxuLyoqXFxuICogR2V0IG9yIHNldCB0aGUgdGVzdCBgZXJyYC5cXG4gKlxcbiAqIEBtZW1iZXJvZiBIb29rXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqIEByZXR1cm4ge0Vycm9yfVxcbiAqL1xcbkhvb2sucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgZXJyID0gdGhpcy5fZXJyb3I7XFxuICAgIHRoaXMuX2Vycm9yID0gbnVsbDtcXG4gICAgcmV0dXJuIGVycjtcXG4gIH1cXG5cXG4gIHRoaXMuX2Vycm9yID0gZXJyO1xcbn07XFxuXFxufSx7XFxcIi4vcnVubmFibGVcXFwiOjMyLFxcXCIuL3V0aWxzXFxcIjozNn1dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcXG5cXG4vKipcXG4gKiBCREQtc3R5bGUgaW50ZXJmYWNlOlxcbiAqXFxuICogICAgICBkZXNjcmliZSgnQXJyYXknLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICAgZGVzY3JpYmUoJyNpbmRleE9mKCknLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiAtMSB3aGVuIG5vdCBwcmVzZW50JywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgICAgICAvLyAuLi5cXG4gKiAgICAgICAgICB9KTtcXG4gKlxcbiAqICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIHRoZSBpbmRleCB3aGVuIHByZXNlbnQnLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICAgICAgIC8vIC4uLlxcbiAqICAgICAgICAgIH0pO1xcbiAqICAgICAgICB9KTtcXG4gKiAgICAgIH0pO1xcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgUm9vdCBzdWl0ZS5cXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJkZEludGVyZmFjZShzdWl0ZSkge1xcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XFxuXFxuICBzdWl0ZS5vbigncHJlLXJlcXVpcmUnLCBmdW5jdGlvbihjb250ZXh0LCBmaWxlLCBtb2NoYSkge1xcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKShzdWl0ZXMsIGNvbnRleHQsIG1vY2hhKTtcXG5cXG4gICAgY29udGV4dC5iZWZvcmUgPSBjb21tb24uYmVmb3JlO1xcbiAgICBjb250ZXh0LmFmdGVyID0gY29tbW9uLmFmdGVyO1xcbiAgICBjb250ZXh0LmJlZm9yZUVhY2ggPSBjb21tb24uYmVmb3JlRWFjaDtcXG4gICAgY29udGV4dC5hZnRlckVhY2ggPSBjb21tb24uYWZ0ZXJFYWNoO1xcbiAgICBjb250ZXh0LnJ1biA9IG1vY2hhLm9wdGlvbnMuZGVsYXkgJiYgY29tbW9uLnJ1bldpdGhTdWl0ZShzdWl0ZSk7XFxuICAgIC8qKlxcbiAgICAgKiBEZXNjcmliZSBhIFxcXCJzdWl0ZVxcXCIgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYFxcbiAgICAgKiBhbmQgY2FsbGJhY2sgYGZuYCBjb250YWluaW5nIG5lc3RlZCBzdWl0ZXNcXG4gICAgICogYW5kL29yIHRlc3RzLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5kZXNjcmliZSA9IGNvbnRleHQuY29udGV4dCA9IGZ1bmN0aW9uKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUuY3JlYXRlKHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZm5cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFBlbmRpbmcgZGVzY3JpYmUuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LnhkZXNjcmliZSA9IGNvbnRleHQueGNvbnRleHQgPSBjb250ZXh0LmRlc2NyaWJlLnNraXAgPSBmdW5jdGlvbihcXG4gICAgICB0aXRsZSxcXG4gICAgICBmblxcbiAgICApIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLnNraXAoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmblxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIHN1aXRlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5kZXNjcmliZS5vbmx5ID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5vbmx5KHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZm5cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgc3BlY2lmaWNhdGlvbiBvciB0ZXN0LWNhc2VcXG4gICAgICogd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYFxcbiAgICAgKiBhY3RpbmcgYXMgYSB0aHVuay5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQuaXQgPSBjb250ZXh0LnNwZWNpZnkgPSBmdW5jdGlvbih0aXRsZSwgZm4pIHtcXG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZXNbMF07XFxuICAgICAgaWYgKHN1aXRlLmlzUGVuZGluZygpKSB7XFxuICAgICAgICBmbiA9IG51bGw7XFxuICAgICAgfVxcbiAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3QodGl0bGUsIGZuKTtcXG4gICAgICB0ZXN0LmZpbGUgPSBmaWxlO1xcbiAgICAgIHN1aXRlLmFkZFRlc3QodGVzdCk7XFxuICAgICAgcmV0dXJuIHRlc3Q7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5pdC5vbmx5ID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi50ZXN0Lm9ubHkobW9jaGEsIGNvbnRleHQuaXQodGl0bGUsIGZuKSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBQZW5kaW5nIHRlc3QgY2FzZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQueGl0ID0gY29udGV4dC54c3BlY2lmeSA9IGNvbnRleHQuaXQuc2tpcCA9IGZ1bmN0aW9uKHRpdGxlKSB7XFxuICAgICAgcmV0dXJuIGNvbnRleHQuaXQodGl0bGUpO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogTnVtYmVyIG9mIGF0dGVtcHRzIHRvIHJldHJ5LlxcbiAgICAgKi9cXG4gICAgY29udGV4dC5pdC5yZXRyaWVzID0gZnVuY3Rpb24obikge1xcbiAgICAgIGNvbnRleHQucmV0cmllcyhuKTtcXG4gICAgfTtcXG4gIH0pO1xcbn07XFxuXFxufSx7XFxcIi4uL3Rlc3RcXFwiOjM1LFxcXCIuL2NvbW1vblxcXCI6OH1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG52YXIgU3VpdGUgPSByZXF1aXJlKCcuLi9zdWl0ZScpO1xcblxcbi8qKlxcbiAqIEZ1bmN0aW9ucyBjb21tb24gdG8gbW9yZSB0aGFuIG9uZSBpbnRlcmZhY2UuXFxuICpcXG4gKiBAcGFyYW0ge1N1aXRlW119IHN1aXRlc1xcbiAqIEBwYXJhbSB7Q29udGV4dH0gY29udGV4dFxcbiAqIEBwYXJhbSB7TW9jaGF9IG1vY2hhXFxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBjb21tb24gZnVuY3Rpb25zLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3VpdGVzLCBjb250ZXh0LCBtb2NoYSkge1xcbiAgcmV0dXJuIHtcXG4gICAgLyoqXFxuICAgICAqIFRoaXMgaXMgb25seSBwcmVzZW50IGlmIGZsYWcgLS1kZWxheSBpcyBwYXNzZWQgaW50byBNb2NoYS4gSXQgdHJpZ2dlcnNcXG4gICAgICogcm9vdCBzdWl0ZSBleGVjdXRpb24uXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFRoZSByb290IHN1aXRlLlxcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB3aGljaCBydW5zIHRoZSByb290IHN1aXRlXFxuICAgICAqL1xcbiAgICBydW5XaXRoU3VpdGU6IGZ1bmN0aW9uIHJ1bldpdGhTdWl0ZShzdWl0ZSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiBydW4oKSB7XFxuICAgICAgICBzdWl0ZS5ydW4oKTtcXG4gICAgICB9O1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogRXhlY3V0ZSBiZWZvcmUgcnVubmluZyB0ZXN0cy5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gICAgICovXFxuICAgIGJlZm9yZTogZnVuY3Rpb24obmFtZSwgZm4pIHtcXG4gICAgICBzdWl0ZXNbMF0uYmVmb3JlQWxsKG5hbWUsIGZuKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4ZWN1dGUgYWZ0ZXIgcnVubmluZyB0ZXN0cy5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gICAgICovXFxuICAgIGFmdGVyOiBmdW5jdGlvbihuYW1lLCBmbikge1xcbiAgICAgIHN1aXRlc1swXS5hZnRlckFsbChuYW1lLCBmbik7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGVjdXRlIGJlZm9yZSBlYWNoIHRlc3QgY2FzZS5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gICAgICovXFxuICAgIGJlZm9yZUVhY2g6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XFxuICAgICAgc3VpdGVzWzBdLmJlZm9yZUVhY2gobmFtZSwgZm4pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogRXhlY3V0ZSBhZnRlciBlYWNoIHRlc3QgY2FzZS5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gICAgICovXFxuICAgIGFmdGVyRWFjaDogZnVuY3Rpb24obmFtZSwgZm4pIHtcXG4gICAgICBzdWl0ZXNbMF0uYWZ0ZXJFYWNoKG5hbWUsIGZuKTtcXG4gICAgfSxcXG5cXG4gICAgc3VpdGU6IHtcXG4gICAgICAvKipcXG4gICAgICAgKiBDcmVhdGUgYW4gZXhjbHVzaXZlIFN1aXRlOyBjb252ZW5pZW5jZSBmdW5jdGlvblxcbiAgICAgICAqIFNlZSBkb2NzdHJpbmcgZm9yIGNyZWF0ZSgpIGJlbG93LlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcXG4gICAgICAgKiBAcmV0dXJucyB7U3VpdGV9XFxuICAgICAgICovXFxuICAgICAgb25seTogZnVuY3Rpb24gb25seShvcHRzKSB7XFxuICAgICAgICBvcHRzLmlzT25seSA9IHRydWU7XFxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUob3B0cyk7XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBDcmVhdGUgYSBTdWl0ZSwgYnV0IHNraXAgaXQ7IGNvbnZlbmllbmNlIGZ1bmN0aW9uXFxuICAgICAgICogU2VlIGRvY3N0cmluZyBmb3IgY3JlYXRlKCkgYmVsb3cuXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xcbiAgICAgICAqIEByZXR1cm5zIHtTdWl0ZX1cXG4gICAgICAgKi9cXG4gICAgICBza2lwOiBmdW5jdGlvbiBza2lwKG9wdHMpIHtcXG4gICAgICAgIG9wdHMucGVuZGluZyA9IHRydWU7XFxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUob3B0cyk7XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBDcmVhdGVzIGEgc3VpdGUuXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uc1xcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnRpdGxlIFRpdGxlIG9mIFN1aXRlXFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMuZm5dIFN1aXRlIEZ1bmN0aW9uIChub3QgYWx3YXlzIGFwcGxpY2FibGUpXFxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5wZW5kaW5nXSBJcyBTdWl0ZSBwZW5kaW5nP1xcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5maWxlXSBGaWxlcGF0aCB3aGVyZSB0aGlzIFN1aXRlIHJlc2lkZXNcXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmlzT25seV0gSXMgU3VpdGUgZXhjbHVzaXZlP1xcbiAgICAgICAqIEByZXR1cm5zIHtTdWl0ZX1cXG4gICAgICAgKi9cXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShvcHRzKSB7XFxuICAgICAgICB2YXIgc3VpdGUgPSBTdWl0ZS5jcmVhdGUoc3VpdGVzWzBdLCBvcHRzLnRpdGxlKTtcXG4gICAgICAgIHN1aXRlLnBlbmRpbmcgPSBCb29sZWFuKG9wdHMucGVuZGluZyk7XFxuICAgICAgICBzdWl0ZS5maWxlID0gb3B0cy5maWxlO1xcbiAgICAgICAgc3VpdGVzLnVuc2hpZnQoc3VpdGUpO1xcbiAgICAgICAgaWYgKG9wdHMuaXNPbmx5KSB7XFxuICAgICAgICAgIHN1aXRlLnBhcmVudC5fb25seVN1aXRlcyA9IHN1aXRlLnBhcmVudC5fb25seVN1aXRlcy5jb25jYXQoc3VpdGUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmZuID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgIG9wdHMuZm4uY2FsbChzdWl0ZSk7XFxuICAgICAgICAgIHN1aXRlcy5zaGlmdCgpO1xcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5mbiA9PT0gJ3VuZGVmaW5lZCcgJiYgIXN1aXRlLnBlbmRpbmcpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcbiAgICAgICAgICAgICdTdWl0ZSBcXFwiJyArXFxuICAgICAgICAgICAgICBzdWl0ZS5mdWxsVGl0bGUoKSArXFxuICAgICAgICAgICAgICAnXFxcIiB3YXMgZGVmaW5lZCBidXQgbm8gY2FsbGJhY2sgd2FzIHN1cHBsaWVkLiBTdXBwbHkgYSBjYWxsYmFjayBvciBleHBsaWNpdGx5IHNraXAgdGhlIHN1aXRlLidcXG4gICAgICAgICAgKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdHMuZm4gJiYgc3VpdGUucGVuZGluZykge1xcbiAgICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBzdWl0ZTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIHRlc3Q6IHtcXG4gICAgICAvKipcXG4gICAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vY2hhXFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdGVzdFxcbiAgICAgICAqIEByZXR1cm5zIHsqfVxcbiAgICAgICAqL1xcbiAgICAgIG9ubHk6IGZ1bmN0aW9uKG1vY2hhLCB0ZXN0KSB7XFxuICAgICAgICB0ZXN0LnBhcmVudC5fb25seVRlc3RzID0gdGVzdC5wYXJlbnQuX29ubHlUZXN0cy5jb25jYXQodGVzdCk7XFxuICAgICAgICByZXR1cm4gdGVzdDtcXG4gICAgICB9LFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIFBlbmRpbmcgdGVzdCBjYXNlLlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICAgICAgICovXFxuICAgICAgc2tpcDogZnVuY3Rpb24odGl0bGUpIHtcXG4gICAgICAgIGNvbnRleHQudGVzdCh0aXRsZSk7XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBOdW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHNcXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICAgICAgICovXFxuICAgICAgcmV0cmllczogZnVuY3Rpb24obikge1xcbiAgICAgICAgY29udGV4dC5yZXRyaWVzKG4pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG59O1xcblxcbn0se1xcXCIuLi9zdWl0ZVxcXCI6MzR9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxudmFyIFN1aXRlID0gcmVxdWlyZSgnLi4vc3VpdGUnKTtcXG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcXG5cXG4vKipcXG4gKiBFeHBvcnRzLXN0eWxlIChhcyBOb2RlLmpzIG1vZHVsZSkgaW50ZXJmYWNlOlxcbiAqXFxuICogICAgIGV4cG9ydHMuQXJyYXkgPSB7XFxuICogICAgICAgJyNpbmRleE9mKCknOiB7XFxuICogICAgICAgICAnc2hvdWxkIHJldHVybiAtMSB3aGVuIHRoZSB2YWx1ZSBpcyBub3QgcHJlc2VudCc6IGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICB9LFxcbiAqXFxuICogICAgICAgICAnc2hvdWxkIHJldHVybiB0aGUgY29ycmVjdCBpbmRleCB3aGVuIHRoZSB2YWx1ZSBpcyBwcmVzZW50JzogZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgIH1cXG4gKiAgICAgICB9XFxuICogICAgIH07XFxuICpcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3VpdGUpIHtcXG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xcblxcbiAgc3VpdGUub24oJ3JlcXVpcmUnLCB2aXNpdCk7XFxuXFxuICBmdW5jdGlvbiB2aXNpdChvYmosIGZpbGUpIHtcXG4gICAgdmFyIHN1aXRlO1xcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XFxuICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgdmFyIGZuID0gb2JqW2tleV07XFxuICAgICAgICBzd2l0Y2ggKGtleSkge1xcbiAgICAgICAgICBjYXNlICdiZWZvcmUnOlxcbiAgICAgICAgICAgIHN1aXRlc1swXS5iZWZvcmVBbGwoZm4pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlICdhZnRlcic6XFxuICAgICAgICAgICAgc3VpdGVzWzBdLmFmdGVyQWxsKGZuKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSAnYmVmb3JlRWFjaCc6XFxuICAgICAgICAgICAgc3VpdGVzWzBdLmJlZm9yZUVhY2goZm4pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlICdhZnRlckVhY2gnOlxcbiAgICAgICAgICAgIHN1aXRlc1swXS5hZnRlckVhY2goZm4pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3Qoa2V5LCBmbik7XFxuICAgICAgICAgICAgdGVzdC5maWxlID0gZmlsZTtcXG4gICAgICAgICAgICBzdWl0ZXNbMF0uYWRkVGVzdCh0ZXN0KTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3VpdGUgPSBTdWl0ZS5jcmVhdGUoc3VpdGVzWzBdLCBrZXkpO1xcbiAgICAgICAgc3VpdGVzLnVuc2hpZnQoc3VpdGUpO1xcbiAgICAgICAgdmlzaXQob2JqW2tleV0sIGZpbGUpO1xcbiAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufTtcXG5cXG59LHtcXFwiLi4vc3VpdGVcXFwiOjM0LFxcXCIuLi90ZXN0XFxcIjozNX1dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5iZGQgPSByZXF1aXJlKCcuL2JkZCcpO1xcbmV4cG9ydHMudGRkID0gcmVxdWlyZSgnLi90ZGQnKTtcXG5leHBvcnRzLnF1bml0ID0gcmVxdWlyZSgnLi9xdW5pdCcpO1xcbmV4cG9ydHMuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZXhwb3J0cycpO1xcblxcbn0se1xcXCIuL2JkZFxcXCI6NyxcXFwiLi9leHBvcnRzXFxcIjo5LFxcXCIuL3F1bml0XFxcIjoxMSxcXFwiLi90ZGRcXFwiOjEyfV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcXG5cXG4vKipcXG4gKiBRVW5pdC1zdHlsZSBpbnRlcmZhY2U6XFxuICpcXG4gKiAgICAgc3VpdGUoJ0FycmF5Jyk7XFxuICpcXG4gKiAgICAgdGVzdCgnI2xlbmd0aCcsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgIHZhciBhcnIgPSBbMSwyLDNdO1xcbiAqICAgICAgIG9rKGFyci5sZW5ndGggPT0gMyk7XFxuICogICAgIH0pO1xcbiAqXFxuICogICAgIHRlc3QoJyNpbmRleE9mKCknLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICB2YXIgYXJyID0gWzEsMiwzXTtcXG4gKiAgICAgICBvayhhcnIuaW5kZXhPZigxKSA9PSAwKTtcXG4gKiAgICAgICBvayhhcnIuaW5kZXhPZigyKSA9PSAxKTtcXG4gKiAgICAgICBvayhhcnIuaW5kZXhPZigzKSA9PSAyKTtcXG4gKiAgICAgfSk7XFxuICpcXG4gKiAgICAgc3VpdGUoJ1N0cmluZycpO1xcbiAqXFxuICogICAgIHRlc3QoJyNsZW5ndGgnLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICBvaygnZm9vJy5sZW5ndGggPT0gMyk7XFxuICogICAgIH0pO1xcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgUm9vdCBzdWl0ZS5cXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHFVbml0SW50ZXJmYWNlKHN1aXRlKSB7XFxuICB2YXIgc3VpdGVzID0gW3N1aXRlXTtcXG5cXG4gIHN1aXRlLm9uKCdwcmUtcmVxdWlyZScsIGZ1bmN0aW9uKGNvbnRleHQsIGZpbGUsIG1vY2hhKSB7XFxuICAgIHZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpKHN1aXRlcywgY29udGV4dCwgbW9jaGEpO1xcblxcbiAgICBjb250ZXh0LmJlZm9yZSA9IGNvbW1vbi5iZWZvcmU7XFxuICAgIGNvbnRleHQuYWZ0ZXIgPSBjb21tb24uYWZ0ZXI7XFxuICAgIGNvbnRleHQuYmVmb3JlRWFjaCA9IGNvbW1vbi5iZWZvcmVFYWNoO1xcbiAgICBjb250ZXh0LmFmdGVyRWFjaCA9IGNvbW1vbi5hZnRlckVhY2g7XFxuICAgIGNvbnRleHQucnVuID0gbW9jaGEub3B0aW9ucy5kZWxheSAmJiBjb21tb24ucnVuV2l0aFN1aXRlKHN1aXRlKTtcXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgXFxcInN1aXRlXFxcIiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5zdWl0ZSA9IGZ1bmN0aW9uKHRpdGxlKSB7XFxuICAgICAgaWYgKHN1aXRlcy5sZW5ndGggPiAxKSB7XFxuICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5jcmVhdGUoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmYWxzZVxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIFN1aXRlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5zdWl0ZS5vbmx5ID0gZnVuY3Rpb24odGl0bGUpIHtcXG4gICAgICBpZiAoc3VpdGVzLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgIHN1aXRlcy5zaGlmdCgpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLm9ubHkoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmYWxzZVxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBzcGVjaWZpY2F0aW9uIG9yIHRlc3QtY2FzZVxcbiAgICAgKiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gXFxuICAgICAqIGFjdGluZyBhcyBhIHRodW5rLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC50ZXN0ID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHRlc3QgPSBuZXcgVGVzdCh0aXRsZSwgZm4pO1xcbiAgICAgIHRlc3QuZmlsZSA9IGZpbGU7XFxuICAgICAgc3VpdGVzWzBdLmFkZFRlc3QodGVzdCk7XFxuICAgICAgcmV0dXJuIHRlc3Q7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC50ZXN0Lm9ubHkgPSBmdW5jdGlvbih0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnRlc3Qub25seShtb2NoYSwgY29udGV4dC50ZXN0KHRpdGxlLCBmbikpO1xcbiAgICB9O1xcblxcbiAgICBjb250ZXh0LnRlc3Quc2tpcCA9IGNvbW1vbi50ZXN0LnNraXA7XFxuICAgIGNvbnRleHQudGVzdC5yZXRyaWVzID0gY29tbW9uLnRlc3QucmV0cmllcztcXG4gIH0pO1xcbn07XFxuXFxufSx7XFxcIi4uL3Rlc3RcXFwiOjM1LFxcXCIuL2NvbW1vblxcXCI6OH1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIFRlc3QgPSByZXF1aXJlKCcuLi90ZXN0Jyk7XFxuXFxuLyoqXFxuICogVERELXN0eWxlIGludGVyZmFjZTpcXG4gKlxcbiAqICAgICAgc3VpdGUoJ0FycmF5JywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgIHN1aXRlKCcjaW5kZXhPZigpJywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgICAgc3VpdGVTZXR1cChmdW5jdGlvbigpIHtcXG4gKlxcbiAqICAgICAgICAgIH0pO1xcbiAqXFxuICogICAgICAgICAgdGVzdCgnc2hvdWxkIHJldHVybiAtMSB3aGVuIG5vdCBwcmVzZW50JywgZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgICB9KTtcXG4gKlxcbiAqICAgICAgICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdGhlIGluZGV4IHdoZW4gcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICAgfSk7XFxuICpcXG4gKiAgICAgICAgICBzdWl0ZVRlYXJkb3duKGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICAgfSk7XFxuICogICAgICAgIH0pO1xcbiAqICAgICAgfSk7XFxuICpcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3VpdGUpIHtcXG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xcblxcbiAgc3VpdGUub24oJ3ByZS1yZXF1aXJlJywgZnVuY3Rpb24oY29udGV4dCwgZmlsZSwgbW9jaGEpIHtcXG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykoc3VpdGVzLCBjb250ZXh0LCBtb2NoYSk7XFxuXFxuICAgIGNvbnRleHQuc2V0dXAgPSBjb21tb24uYmVmb3JlRWFjaDtcXG4gICAgY29udGV4dC50ZWFyZG93biA9IGNvbW1vbi5hZnRlckVhY2g7XFxuICAgIGNvbnRleHQuc3VpdGVTZXR1cCA9IGNvbW1vbi5iZWZvcmU7XFxuICAgIGNvbnRleHQuc3VpdGVUZWFyZG93biA9IGNvbW1vbi5hZnRlcjtcXG4gICAgY29udGV4dC5ydW4gPSBtb2NoYS5vcHRpb25zLmRlbGF5ICYmIGNvbW1vbi5ydW5XaXRoU3VpdGUoc3VpdGUpO1xcblxcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBcXFwic3VpdGVcXFwiIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAgY29udGFpbmluZ1xcbiAgICAgKiBuZXN0ZWQgc3VpdGVzIGFuZC9vciB0ZXN0cy5cXG4gICAgICovXFxuICAgIGNvbnRleHQuc3VpdGUgPSBmdW5jdGlvbih0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLmNyZWF0ZSh7XFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICBmaWxlOiBmaWxlLFxcbiAgICAgICAgZm46IGZuXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBQZW5kaW5nIHN1aXRlLlxcbiAgICAgKi9cXG4gICAgY29udGV4dC5zdWl0ZS5za2lwID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5za2lwKHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZm5cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXFxuICAgICAqL1xcbiAgICBjb250ZXh0LnN1aXRlLm9ubHkgPSBmdW5jdGlvbih0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLm9ubHkoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmblxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBzcGVjaWZpY2F0aW9uIG9yIHRlc3QtY2FzZSB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZFxcbiAgICAgKiBjYWxsYmFjayBgZm5gIGFjdGluZyBhcyBhIHRodW5rLlxcbiAgICAgKi9cXG4gICAgY29udGV4dC50ZXN0ID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHN1aXRlID0gc3VpdGVzWzBdO1xcbiAgICAgIGlmIChzdWl0ZS5pc1BlbmRpbmcoKSkge1xcbiAgICAgICAgZm4gPSBudWxsO1xcbiAgICAgIH1cXG4gICAgICB2YXIgdGVzdCA9IG5ldyBUZXN0KHRpdGxlLCBmbik7XFxuICAgICAgdGVzdC5maWxlID0gZmlsZTtcXG4gICAgICBzdWl0ZS5hZGRUZXN0KHRlc3QpO1xcbiAgICAgIHJldHVybiB0ZXN0O1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQudGVzdC5vbmx5ID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi50ZXN0Lm9ubHkobW9jaGEsIGNvbnRleHQudGVzdCh0aXRsZSwgZm4pKTtcXG4gICAgfTtcXG5cXG4gICAgY29udGV4dC50ZXN0LnNraXAgPSBjb21tb24udGVzdC5za2lwO1xcbiAgICBjb250ZXh0LnRlc3QucmV0cmllcyA9IGNvbW1vbi50ZXN0LnJldHJpZXM7XFxuICB9KTtcXG59O1xcblxcbn0se1xcXCIuLi90ZXN0XFxcIjozNSxcXFwiLi9jb21tb25cXFwiOjh9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxfX2Rpcm5hbWUpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKiFcXG4gKiBtb2NoYVxcbiAqIENvcHlyaWdodChjKSAyMDExIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XFxuICogTUlUIExpY2Vuc2VkXFxuICovXFxuXFxudmFyIGVzY2FwZVJlID0gcmVxdWlyZSgnZXNjYXBlLXN0cmluZy1yZWdleHAnKTtcXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcXG52YXIgcmVwb3J0ZXJzID0gcmVxdWlyZSgnLi9yZXBvcnRlcnMnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTW9jaGE7XFxuXFxuLyoqXFxuICogVG8gcmVxdWlyZSBsb2NhbCBVSXMgYW5kIHJlcG9ydGVycyB3aGVuIHJ1bm5pbmcgaW4gbm9kZS5cXG4gKi9cXG5cXG5pZiAoIXByb2Nlc3MuYnJvd3Nlcikge1xcbiAgdmFyIGN3ZCA9IHByb2Nlc3MuY3dkKCk7XFxuICBtb2R1bGUucGF0aHMucHVzaChjd2QsIHBhdGguam9pbihjd2QsICdub2RlX21vZHVsZXMnKSk7XFxufVxcblxcbi8qKlxcbiAqIEV4cG9zZSBpbnRlcm5hbHMuXFxuICovXFxuXFxuLyoqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzcyB1dGlsc1xcbiAqIEBtZW1iZXJvZiBNb2NoYVxcbiAqL1xcbmV4cG9ydHMudXRpbHMgPSB1dGlscztcXG5leHBvcnRzLmludGVyZmFjZXMgPSByZXF1aXJlKCcuL2ludGVyZmFjZXMnKTtcXG4vKipcXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYVxcbiAqIEBwdWJsaWNcXG4gKi9cXG5leHBvcnRzLnJlcG9ydGVycyA9IHJlcG9ydGVycztcXG5leHBvcnRzLlJ1bm5hYmxlID0gcmVxdWlyZSgnLi9ydW5uYWJsZScpO1xcbmV4cG9ydHMuQ29udGV4dCA9IHJlcXVpcmUoJy4vY29udGV4dCcpO1xcbi8qKlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhXFxuICovXFxuZXhwb3J0cy5SdW5uZXIgPSByZXF1aXJlKCcuL3J1bm5lcicpO1xcbmV4cG9ydHMuU3VpdGUgPSByZXF1aXJlKCcuL3N1aXRlJyk7XFxuZXhwb3J0cy5Ib29rID0gcmVxdWlyZSgnLi9ob29rJyk7XFxuZXhwb3J0cy5UZXN0ID0gcmVxdWlyZSgnLi90ZXN0Jyk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGltYWdlIGBuYW1lYCBwYXRoLlxcbiAqXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBpbWFnZShuYW1lKSB7XFxuICByZXR1cm4gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uJywgJ2Fzc2V0cycsICdncm93bCcsIG5hbWUgKyAnLnBuZycpO1xcbn1cXG5cXG4vKipcXG4gKiBTZXQgdXAgbW9jaGEgd2l0aCBgb3B0aW9uc2AuXFxuICpcXG4gKiBPcHRpb25zOlxcbiAqXFxuICogICAtIGB1aWAgbmFtZSBcXFwiYmRkXFxcIiwgXFxcInRkZFxcXCIsIFxcXCJleHBvcnRzXFxcIiBldGNcXG4gKiAgIC0gYHJlcG9ydGVyYCByZXBvcnRlciBpbnN0YW5jZSwgZGVmYXVsdHMgdG8gYG1vY2hhLnJlcG9ydGVycy5zcGVjYFxcbiAqICAgLSBgZ2xvYmFsc2AgYXJyYXkgb2YgYWNjZXB0ZWQgZ2xvYmFsc1xcbiAqICAgLSBgdGltZW91dGAgdGltZW91dCBpbiBtaWxsaXNlY29uZHNcXG4gKiAgIC0gYHJldHJpZXNgIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSBmYWlsZWQgdGVzdHNcXG4gKiAgIC0gYGJhaWxgIGJhaWwgb24gdGhlIGZpcnN0IHRlc3QgZmFpbHVyZVxcbiAqICAgLSBgc2xvd2AgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGNvbnNpZGVyaW5nIGEgdGVzdCBzbG93XFxuICogICAtIGBpZ25vcmVMZWFrc2AgaWdub3JlIGdsb2JhbCBsZWFrc1xcbiAqICAgLSBgZnVsbFRyYWNlYCBkaXNwbGF5IHRoZSBmdWxsIHN0YWNrLXRyYWNlIG9uIGZhaWxpbmdcXG4gKiAgIC0gYGdyZXBgIHN0cmluZyBvciByZWdleHAgdG8gZmlsdGVyIHRlc3RzIHdpdGhcXG4gKlxcbiAqIEBjbGFzcyBNb2NoYVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXFxuICovXFxuZnVuY3Rpb24gTW9jaGEob3B0aW9ucykge1xcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICB0aGlzLmZpbGVzID0gW107XFxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcbiAgaWYgKG9wdGlvbnMuZ3JlcCkge1xcbiAgICB0aGlzLmdyZXAobmV3IFJlZ0V4cChvcHRpb25zLmdyZXApKTtcXG4gIH1cXG4gIGlmIChvcHRpb25zLmZncmVwKSB7XFxuICAgIHRoaXMuZmdyZXAob3B0aW9ucy5mZ3JlcCk7XFxuICB9XFxuICB0aGlzLnN1aXRlID0gbmV3IGV4cG9ydHMuU3VpdGUoJycsIG5ldyBleHBvcnRzLkNvbnRleHQoKSk7XFxuICB0aGlzLnVpKG9wdGlvbnMudWkpO1xcbiAgdGhpcy5iYWlsKG9wdGlvbnMuYmFpbCk7XFxuICB0aGlzLnJlcG9ydGVyKG9wdGlvbnMucmVwb3J0ZXIsIG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zKTtcXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy50aW1lb3V0ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRpb25zLnRpbWVvdXQgIT09IG51bGwpIHtcXG4gICAgdGhpcy50aW1lb3V0KG9wdGlvbnMudGltZW91dCk7XFxuICB9XFxuICBpZiAodHlwZW9mIG9wdGlvbnMucmV0cmllcyAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0aW9ucy5yZXRyaWVzICE9PSBudWxsKSB7XFxuICAgIHRoaXMucmV0cmllcyhvcHRpb25zLnJldHJpZXMpO1xcbiAgfVxcbiAgdGhpcy51c2VDb2xvcnMob3B0aW9ucy51c2VDb2xvcnMpO1xcbiAgaWYgKG9wdGlvbnMuZW5hYmxlVGltZW91dHMgIT09IG51bGwpIHtcXG4gICAgdGhpcy5lbmFibGVUaW1lb3V0cyhvcHRpb25zLmVuYWJsZVRpbWVvdXRzKTtcXG4gIH1cXG4gIGlmIChvcHRpb25zLnNsb3cpIHtcXG4gICAgdGhpcy5zbG93KG9wdGlvbnMuc2xvdyk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIEVuYWJsZSBvciBkaXNhYmxlIGJhaWxpbmcgb24gdGhlIGZpcnN0IGZhaWx1cmUuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtiYWlsXVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5iYWlsID0gZnVuY3Rpb24oYmFpbCkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIGJhaWwgPSB0cnVlO1xcbiAgfVxcbiAgdGhpcy5zdWl0ZS5iYWlsKGJhaWwpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBBZGQgdGVzdCBgZmlsZWAuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5hZGRGaWxlID0gZnVuY3Rpb24oZmlsZSkge1xcbiAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgcmVwb3J0ZXIgdG8gYHJlcG9ydGVyYCwgZGVmYXVsdHMgdG8gXFxcInNwZWNcXFwiLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSByZXBvcnRlciBuYW1lIG9yIGNvbnN0cnVjdG9yXFxuICogQHBhcmFtIHtPYmplY3R9IHJlcG9ydGVyT3B0aW9ucyBvcHRpb25hbCBvcHRpb25zXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gcmVwb3J0ZXIgbmFtZSBvciBjb25zdHJ1Y3RvclxcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXBvcnRlck9wdGlvbnMgb3B0aW9uYWwgb3B0aW9uc1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5yZXBvcnRlciA9IGZ1bmN0aW9uKHJlcG9ydGVyLCByZXBvcnRlck9wdGlvbnMpIHtcXG4gIGlmICh0eXBlb2YgcmVwb3J0ZXIgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgdGhpcy5fcmVwb3J0ZXIgPSByZXBvcnRlcjtcXG4gIH0gZWxzZSB7XFxuICAgIHJlcG9ydGVyID0gcmVwb3J0ZXIgfHwgJ3NwZWMnO1xcbiAgICB2YXIgX3JlcG9ydGVyO1xcbiAgICAvLyBUcnkgdG8gbG9hZCBhIGJ1aWx0LWluIHJlcG9ydGVyLlxcbiAgICBpZiAocmVwb3J0ZXJzW3JlcG9ydGVyXSkge1xcbiAgICAgIF9yZXBvcnRlciA9IHJlcG9ydGVyc1tyZXBvcnRlcl07XFxuICAgIH1cXG4gICAgLy8gVHJ5IHRvIGxvYWQgcmVwb3J0ZXJzIGZyb20gcHJvY2Vzcy5jd2QoKSBhbmQgbm9kZV9tb2R1bGVzXFxuICAgIGlmICghX3JlcG9ydGVyKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIF9yZXBvcnRlciA9IHJlcXVpcmUocmVwb3J0ZXIpO1xcbiAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ0Nhbm5vdCBmaW5kIG1vZHVsZScpICE9PSAtMSkge1xcbiAgICAgICAgICAvLyBUcnkgdG8gbG9hZCByZXBvcnRlcnMgZnJvbSBhIHBhdGggKGFic29sdXRlIG9yIHJlbGF0aXZlKVxcbiAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIF9yZXBvcnRlciA9IHJlcXVpcmUocGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlcG9ydGVyKSk7XFxuICAgICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcXG4gICAgICAgICAgICBlcnIubWVzc2FnZS5pbmRleE9mKCdDYW5ub3QgZmluZCBtb2R1bGUnKSAhPT0gLTFcXG4gICAgICAgICAgICAgID8gY29uc29sZS53YXJuKCdcXFwiJyArIHJlcG9ydGVyICsgJ1xcXCIgcmVwb3J0ZXIgbm90IGZvdW5kJylcXG4gICAgICAgICAgICAgIDogY29uc29sZS53YXJuKFxcbiAgICAgICAgICAgICAgICAgICdcXFwiJyArXFxuICAgICAgICAgICAgICAgICAgICByZXBvcnRlciArXFxuICAgICAgICAgICAgICAgICAgICAnXFxcIiByZXBvcnRlciBibGV3IHVwIHdpdGggZXJyb3I6XFxcXG4nICtcXG4gICAgICAgICAgICAgICAgICAgIGVyci5zdGFja1xcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBjb25zb2xlLndhcm4oXFxuICAgICAgICAgICAgJ1xcXCInICsgcmVwb3J0ZXIgKyAnXFxcIiByZXBvcnRlciBibGV3IHVwIHdpdGggZXJyb3I6XFxcXG4nICsgZXJyLnN0YWNrXFxuICAgICAgICAgICk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmICghX3JlcG9ydGVyICYmIHJlcG9ydGVyID09PSAndGVhbWNpdHknKSB7XFxuICAgICAgY29uc29sZS53YXJuKFxcbiAgICAgICAgJ1RoZSBUZWFtY2l0eSByZXBvcnRlciB3YXMgbW92ZWQgdG8gYSBwYWNrYWdlIG5hbWVkICcgK1xcbiAgICAgICAgICAnbW9jaGEtdGVhbWNpdHktcmVwb3J0ZXIgJyArXFxuICAgICAgICAgICcoaHR0cHM6Ly9ucG1qcy5vcmcvcGFja2FnZS9tb2NoYS10ZWFtY2l0eS1yZXBvcnRlcikuJ1xcbiAgICAgICk7XFxuICAgIH1cXG4gICAgaWYgKCFfcmVwb3J0ZXIpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVwb3J0ZXIgXFxcIicgKyByZXBvcnRlciArICdcXFwiJyk7XFxuICAgIH1cXG4gICAgdGhpcy5fcmVwb3J0ZXIgPSBfcmVwb3J0ZXI7XFxuICB9XFxuICB0aGlzLm9wdGlvbnMucmVwb3J0ZXJPcHRpb25zID0gcmVwb3J0ZXJPcHRpb25zO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGVzdCBVSSBgbmFtZWAsIGRlZmF1bHRzIHRvIFxcXCJiZGRcXFwiLlxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBiZGRcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUudWkgPSBmdW5jdGlvbihuYW1lKSB7XFxuICBuYW1lID0gbmFtZSB8fCAnYmRkJztcXG4gIHRoaXMuX3VpID0gZXhwb3J0cy5pbnRlcmZhY2VzW25hbWVdO1xcbiAgaWYgKCF0aGlzLl91aSkge1xcbiAgICB0cnkge1xcbiAgICAgIHRoaXMuX3VpID0gcmVxdWlyZShuYW1lKTtcXG4gICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGludGVyZmFjZSBcXFwiJyArIG5hbWUgKyAnXFxcIicpO1xcbiAgICB9XFxuICB9XFxuICB0aGlzLl91aSA9IHRoaXMuX3VpKHRoaXMuc3VpdGUpO1xcblxcbiAgdGhpcy5zdWl0ZS5vbigncHJlLXJlcXVpcmUnLCBmdW5jdGlvbihjb250ZXh0KSB7XFxuICAgIGV4cG9ydHMuYWZ0ZXJFYWNoID0gY29udGV4dC5hZnRlckVhY2ggfHwgY29udGV4dC50ZWFyZG93bjtcXG4gICAgZXhwb3J0cy5hZnRlciA9IGNvbnRleHQuYWZ0ZXIgfHwgY29udGV4dC5zdWl0ZVRlYXJkb3duO1xcbiAgICBleHBvcnRzLmJlZm9yZUVhY2ggPSBjb250ZXh0LmJlZm9yZUVhY2ggfHwgY29udGV4dC5zZXR1cDtcXG4gICAgZXhwb3J0cy5iZWZvcmUgPSBjb250ZXh0LmJlZm9yZSB8fCBjb250ZXh0LnN1aXRlU2V0dXA7XFxuICAgIGV4cG9ydHMuZGVzY3JpYmUgPSBjb250ZXh0LmRlc2NyaWJlIHx8IGNvbnRleHQuc3VpdGU7XFxuICAgIGV4cG9ydHMuaXQgPSBjb250ZXh0Lml0IHx8IGNvbnRleHQudGVzdDtcXG4gICAgZXhwb3J0cy54aXQgPSBjb250ZXh0LnhpdCB8fCBjb250ZXh0LnRlc3Quc2tpcDtcXG4gICAgZXhwb3J0cy5zZXR1cCA9IGNvbnRleHQuc2V0dXAgfHwgY29udGV4dC5iZWZvcmVFYWNoO1xcbiAgICBleHBvcnRzLnN1aXRlU2V0dXAgPSBjb250ZXh0LnN1aXRlU2V0dXAgfHwgY29udGV4dC5iZWZvcmU7XFxuICAgIGV4cG9ydHMuc3VpdGVUZWFyZG93biA9IGNvbnRleHQuc3VpdGVUZWFyZG93biB8fCBjb250ZXh0LmFmdGVyO1xcbiAgICBleHBvcnRzLnN1aXRlID0gY29udGV4dC5zdWl0ZSB8fCBjb250ZXh0LmRlc2NyaWJlO1xcbiAgICBleHBvcnRzLnRlYXJkb3duID0gY29udGV4dC50ZWFyZG93biB8fCBjb250ZXh0LmFmdGVyRWFjaDtcXG4gICAgZXhwb3J0cy50ZXN0ID0gY29udGV4dC50ZXN0IHx8IGNvbnRleHQuaXQ7XFxuICAgIGV4cG9ydHMucnVuID0gY29udGV4dC5ydW47XFxuICB9KTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogTG9hZCByZWdpc3RlcmVkIGZpbGVzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmxvYWRGaWxlcyA9IGZ1bmN0aW9uKGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xcbiAgdGhpcy5maWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcXG4gICAgZmlsZSA9IHBhdGgucmVzb2x2ZShmaWxlKTtcXG4gICAgc3VpdGUuZW1pdCgncHJlLXJlcXVpcmUnLCBnbG9iYWwsIGZpbGUsIHNlbGYpO1xcbiAgICBzdWl0ZS5lbWl0KCdyZXF1aXJlJywgcmVxdWlyZShmaWxlKSwgZmlsZSwgc2VsZik7XFxuICAgIHN1aXRlLmVtaXQoJ3Bvc3QtcmVxdWlyZScsIGdsb2JhbCwgZmlsZSwgc2VsZik7XFxuICB9KTtcXG4gIGZuICYmIGZuKCk7XFxufTtcXG5cXG4vKipcXG4gKiBFbmFibGUgZ3Jvd2wgc3VwcG9ydC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5fZ3Jvd2wgPSBmdW5jdGlvbihydW5uZXIsIHJlcG9ydGVyKSB7XFxuICB2YXIgbm90aWZ5ID0gcmVxdWlyZSgnZ3Jvd2wnKTtcXG5cXG4gIHJ1bm5lci5vbignZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgIHZhciBzdGF0cyA9IHJlcG9ydGVyLnN0YXRzO1xcbiAgICBpZiAoc3RhdHMuZmFpbHVyZXMpIHtcXG4gICAgICB2YXIgbXNnID0gc3RhdHMuZmFpbHVyZXMgKyAnIG9mICcgKyBydW5uZXIudG90YWwgKyAnIHRlc3RzIGZhaWxlZCc7XFxuICAgICAgbm90aWZ5KG1zZywge25hbWU6ICdtb2NoYScsIHRpdGxlOiAnRmFpbGVkJywgaW1hZ2U6IGltYWdlKCdlcnJvcicpfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbm90aWZ5KHN0YXRzLnBhc3NlcyArICcgdGVzdHMgcGFzc2VkIGluICcgKyBzdGF0cy5kdXJhdGlvbiArICdtcycsIHtcXG4gICAgICAgIG5hbWU6ICdtb2NoYScsXFxuICAgICAgICB0aXRsZTogJ1Bhc3NlZCcsXFxuICAgICAgICBpbWFnZTogaW1hZ2UoJ29rJylcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBFc2NhcGUgc3RyaW5nIGFuZCBhZGQgaXQgdG8gZ3JlcCBhcyBhIHJlZ2V4cC5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSBzdHJcXG4gKiBAcmV0dXJucyB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmZncmVwID0gZnVuY3Rpb24oc3RyKSB7XFxuICByZXR1cm4gdGhpcy5ncmVwKG5ldyBSZWdFeHAoZXNjYXBlUmUoc3RyKSkpO1xcbn07XFxuXFxuLyoqXFxuICogQWRkIHJlZ2V4cCB0byBncmVwLCBpZiBgcmVgIGlzIGEgc3RyaW5nIGl0IGlzIGVzY2FwZWQuXFxuICpcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSByZVxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSByZVxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5ncmVwID0gZnVuY3Rpb24ocmUpIHtcXG4gIGlmICh1dGlscy5pc1N0cmluZyhyZSkpIHtcXG4gICAgLy8gZXh0cmFjdCBhcmdzIGlmIGl0J3MgcmVnZXgtbGlrZSwgaS5lOiBbc3RyaW5nLCBwYXR0ZXJuLCBmbGFnXVxcbiAgICB2YXIgYXJnID0gcmUubWF0Y2goL15cXFxcLyguKilcXFxcLyhnfGl8KSR8LiovKTtcXG4gICAgdGhpcy5vcHRpb25zLmdyZXAgPSBuZXcgUmVnRXhwKGFyZ1sxXSB8fCBhcmdbMF0sIGFyZ1syXSk7XFxuICB9IGVsc2Uge1xcbiAgICB0aGlzLm9wdGlvbnMuZ3JlcCA9IHJlO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG4vKipcXG4gKiBJbnZlcnQgYC5ncmVwKClgIG1hdGNoZXMuXFxuICpcXG4gKiBAcHVibGljXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XFxuICB0aGlzLm9wdGlvbnMuaW52ZXJ0ID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogSWdub3JlIGdsb2JhbCBsZWFrcy5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuaWdub3JlTGVha3MgPSBmdW5jdGlvbihpZ25vcmUpIHtcXG4gIHRoaXMub3B0aW9ucy5pZ25vcmVMZWFrcyA9IEJvb2xlYW4oaWdub3JlKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIGdsb2JhbCBsZWFrIGNoZWNraW5nLlxcbiAqXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmNoZWNrTGVha3MgPSBmdW5jdGlvbigpIHtcXG4gIHRoaXMub3B0aW9ucy5pZ25vcmVMZWFrcyA9IGZhbHNlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBEaXNwbGF5IGxvbmcgc3RhY2stdHJhY2Ugb24gZmFpbGluZ1xcbiAqXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmZ1bGxUcmFjZSA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5vcHRpb25zLmZ1bGxTdGFja1RyYWNlID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIGdyb3dsIHN1cHBvcnQuXFxuICpcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZ3Jvd2wgPSBmdW5jdGlvbigpIHtcXG4gIHRoaXMub3B0aW9ucy5ncm93bCA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIElnbm9yZSBgZ2xvYmFsc2AgYXJyYXkgb3Igc3RyaW5nLlxcbiAqXFxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGdsb2JhbHNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gZ2xvYmFsc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5nbG9iYWxzID0gZnVuY3Rpb24oZ2xvYmFscykge1xcbiAgdGhpcy5vcHRpb25zLmdsb2JhbHMgPSAodGhpcy5vcHRpb25zLmdsb2JhbHMgfHwgW10pLmNvbmNhdChnbG9iYWxzKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRW1pdCBjb2xvciBvdXRwdXQuXFxuICpcXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbG9yc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29sb3JzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnVzZUNvbG9ycyA9IGZ1bmN0aW9uKGNvbG9ycykge1xcbiAgaWYgKGNvbG9ycyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIHRoaXMub3B0aW9ucy51c2VDb2xvcnMgPSBjb2xvcnM7XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFVzZSBpbmxpbmUgZGlmZnMgcmF0aGVyIHRoYW4gKy8tLlxcbiAqXFxuICogQHBhcmFtIHtCb29sZWFufSBpbmxpbmVEaWZmc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5saW5lRGlmZnNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUudXNlSW5saW5lRGlmZnMgPSBmdW5jdGlvbihpbmxpbmVEaWZmcykge1xcbiAgdGhpcy5vcHRpb25zLnVzZUlubGluZURpZmZzID0gaW5saW5lRGlmZnMgIT09IHVuZGVmaW5lZCAmJiBpbmxpbmVEaWZmcztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRG8gbm90IHNob3cgZGlmZnMgYXQgYWxsLlxcbiAqXFxuICogQHBhcmFtIHtCb29sZWFufSBoaWRlRGlmZlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlkZURpZmZcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuaGlkZURpZmYgPSBmdW5jdGlvbihoaWRlRGlmZikge1xcbiAgdGhpcy5vcHRpb25zLmhpZGVEaWZmID0gaGlkZURpZmYgIT09IHVuZGVmaW5lZCAmJiBoaWRlRGlmZjtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRoZSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcy5cXG4gKlxcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0XFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcXG4gIHRoaXMuc3VpdGUudGltZW91dCh0aW1lb3V0KTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgZmFpbGVkIHRlc3RzLlxcbiAqXFxuICogQHBhcmFtIHtOdW1iZXJ9IHJldHJ5IHRpbWVzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbihuKSB7XFxuICB0aGlzLnN1aXRlLnJldHJpZXMobik7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBzbG93bmVzcyB0aHJlc2hvbGQgaW4gbWlsbGlzZWNvbmRzLlxcbiAqXFxuICogQHBhcmFtIHtOdW1iZXJ9IHNsb3dcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge251bWJlcn0gc2xvd1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5zbG93ID0gZnVuY3Rpb24oc2xvdykge1xcbiAgdGhpcy5zdWl0ZS5zbG93KHNsb3cpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBFbmFibGUgdGltZW91dHMuXFxuICpcXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZW5hYmxlVGltZW91dHMgPSBmdW5jdGlvbihlbmFibGVkKSB7XFxuICB0aGlzLnN1aXRlLmVuYWJsZVRpbWVvdXRzKFxcbiAgICBhcmd1bWVudHMubGVuZ3RoICYmIGVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IGVuYWJsZWQgOiB0cnVlXFxuICApO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBNYWtlcyBhbGwgdGVzdHMgYXN5bmMgKGFjY2VwdGluZyBhIGNhbGxiYWNrKVxcbiAqXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmFzeW5jT25seSA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5vcHRpb25zLmFzeW5jT25seSA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIERpc2FibGUgc3ludGF4IGhpZ2hsaWdodGluZyAoaW4gYnJvd3NlcikuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUubm9IaWdobGlnaHRpbmcgPSBmdW5jdGlvbigpIHtcXG4gIHRoaXMub3B0aW9ucy5ub0hpZ2hsaWdodGluZyA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEVuYWJsZSB1bmNhdWdodCBlcnJvcnMgdG8gcHJvcGFnYXRlIChpbiBicm93c2VyKS5cXG4gKlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5hbGxvd1VuY2F1Z2h0ID0gZnVuY3Rpb24oKSB7XFxuICB0aGlzLm9wdGlvbnMuYWxsb3dVbmNhdWdodCA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIERlbGF5IHJvb3Qgc3VpdGUgZXhlY3V0aW9uLlxcbiAqIEByZXR1cm5zIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiBkZWxheSgpIHtcXG4gIHRoaXMub3B0aW9ucy5kZWxheSA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFRlc3RzIG1hcmtlZCBvbmx5IGZhaWwgdGhlIHN1aXRlXFxuICogQHJldHVybnMge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5mb3JiaWRPbmx5ID0gZnVuY3Rpb24oKSB7XFxuICB0aGlzLm9wdGlvbnMuZm9yYmlkT25seSA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFBlbmRpbmcgdGVzdHMgYW5kIHRlc3RzIG1hcmtlZCBza2lwIGZhaWwgdGhlIHN1aXRlXFxuICogQHJldHVybnMge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5mb3JiaWRQZW5kaW5nID0gZnVuY3Rpb24oKSB7XFxuICB0aGlzLm9wdGlvbnMuZm9yYmlkUGVuZGluZyA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biB0ZXN0cyBhbmQgaW52b2tlIGBmbigpYCB3aGVuIGNvbXBsZXRlLlxcbiAqXFxuICogTm90ZSB0aGF0IGBsb2FkRmlsZXNgIHJlbGllcyBvbiBOb2RlJ3MgYHJlcXVpcmVgIHRvIGV4ZWN1dGVcXG4gKiB0aGUgdGVzdCBpbnRlcmZhY2UgZnVuY3Rpb25zIGFuZCB3aWxsIGJlIHN1YmplY3QgdG8gdGhlXFxuICogY2FjaGUgLSBpZiB0aGUgZmlsZXMgYXJlIGFscmVhZHkgaW4gdGhlIGByZXF1aXJlYCBjYWNoZSxcXG4gKiB0aGV5IHdpbGwgZWZmZWN0aXZlbHkgYmUgc2tpcHBlZC4gVGhlcmVmb3JlLCB0byBydW4gdGVzdHNcXG4gKiBtdWx0aXBsZSB0aW1lcyBvciB0byBydW4gdGVzdHMgaW4gZmlsZXMgdGhhdCBhcmUgYWxyZWFkeVxcbiAqIGluIHRoZSBgcmVxdWlyZWAgY2FjaGUsIG1ha2Ugc3VyZSB0byBjbGVhciB0aGVtIGZyb20gdGhlXFxuICogY2FjaGUgZmlyc3QgaW4gd2hpY2hldmVyIG1hbm5lciBiZXN0IHN1aXRzIHlvdXIgbmVlZHMuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1J1bm5lcn1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oZm4pIHtcXG4gIGlmICh0aGlzLmZpbGVzLmxlbmd0aCkge1xcbiAgICB0aGlzLmxvYWRGaWxlcygpO1xcbiAgfVxcbiAgdmFyIHN1aXRlID0gdGhpcy5zdWl0ZTtcXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xcbiAgb3B0aW9ucy5maWxlcyA9IHRoaXMuZmlsZXM7XFxuICB2YXIgcnVubmVyID0gbmV3IGV4cG9ydHMuUnVubmVyKHN1aXRlLCBvcHRpb25zLmRlbGF5KTtcXG4gIHZhciByZXBvcnRlciA9IG5ldyB0aGlzLl9yZXBvcnRlcihydW5uZXIsIG9wdGlvbnMpO1xcbiAgcnVubmVyLmlnbm9yZUxlYWtzID0gb3B0aW9ucy5pZ25vcmVMZWFrcyAhPT0gZmFsc2U7XFxuICBydW5uZXIuZnVsbFN0YWNrVHJhY2UgPSBvcHRpb25zLmZ1bGxTdGFja1RyYWNlO1xcbiAgcnVubmVyLmFzeW5jT25seSA9IG9wdGlvbnMuYXN5bmNPbmx5O1xcbiAgcnVubmVyLmFsbG93VW5jYXVnaHQgPSBvcHRpb25zLmFsbG93VW5jYXVnaHQ7XFxuICBydW5uZXIuZm9yYmlkT25seSA9IG9wdGlvbnMuZm9yYmlkT25seTtcXG4gIHJ1bm5lci5mb3JiaWRQZW5kaW5nID0gb3B0aW9ucy5mb3JiaWRQZW5kaW5nO1xcbiAgaWYgKG9wdGlvbnMuZ3JlcCkge1xcbiAgICBydW5uZXIuZ3JlcChvcHRpb25zLmdyZXAsIG9wdGlvbnMuaW52ZXJ0KTtcXG4gIH1cXG4gIGlmIChvcHRpb25zLmdsb2JhbHMpIHtcXG4gICAgcnVubmVyLmdsb2JhbHMob3B0aW9ucy5nbG9iYWxzKTtcXG4gIH1cXG4gIGlmIChvcHRpb25zLmdyb3dsKSB7XFxuICAgIHRoaXMuX2dyb3dsKHJ1bm5lciwgcmVwb3J0ZXIpO1xcbiAgfVxcbiAgaWYgKG9wdGlvbnMudXNlQ29sb3JzICE9PSB1bmRlZmluZWQpIHtcXG4gICAgZXhwb3J0cy5yZXBvcnRlcnMuQmFzZS51c2VDb2xvcnMgPSBvcHRpb25zLnVzZUNvbG9ycztcXG4gIH1cXG4gIGV4cG9ydHMucmVwb3J0ZXJzLkJhc2UuaW5saW5lRGlmZnMgPSBvcHRpb25zLnVzZUlubGluZURpZmZzO1xcbiAgZXhwb3J0cy5yZXBvcnRlcnMuQmFzZS5oaWRlRGlmZiA9IG9wdGlvbnMuaGlkZURpZmY7XFxuXFxuICBmdW5jdGlvbiBkb25lKGZhaWx1cmVzKSB7XFxuICAgIGlmIChyZXBvcnRlci5kb25lKSB7XFxuICAgICAgcmVwb3J0ZXIuZG9uZShmYWlsdXJlcywgZm4pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZuICYmIGZuKGZhaWx1cmVzKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHJ1bm5lci5ydW4oZG9uZSk7XFxufTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9LFxcXCIvbGliXFxcIilcXG59LHtcXFwiLi9jb250ZXh0XFxcIjo1LFxcXCIuL2hvb2tcXFwiOjYsXFxcIi4vaW50ZXJmYWNlc1xcXCI6MTAsXFxcIi4vcmVwb3J0ZXJzXFxcIjoyMCxcXFwiLi9ydW5uYWJsZVxcXCI6MzIsXFxcIi4vcnVubmVyXFxcIjozMyxcXFwiLi9zdWl0ZVxcXCI6MzQsXFxcIi4vdGVzdFxcXCI6MzUsXFxcIi4vdXRpbHNcXFwiOjM2LFxcXCJfcHJvY2Vzc1xcXCI6NTYsXFxcImVzY2FwZS1zdHJpbmctcmVnZXhwXFxcIjo0NixcXFwiZ3Jvd2xcXFwiOjIsXFxcInBhdGhcXFwiOjQwfV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIG1pbGxpc2Vjb25kc1xcbiAqL1xcbi8qKlxcbiAqIEhlbHBlcnMuXFxuICovXFxuXFxudmFyIHMgPSAxMDAwO1xcbnZhciBtID0gcyAqIDYwO1xcbnZhciBoID0gbSAqIDYwO1xcbnZhciBkID0gaCAqIDI0O1xcbnZhciB5ID0gZCAqIDM2NS4yNTtcXG5cXG4vKipcXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWxcXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVtYmVyfVxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsKSB7XFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcXG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XFxuICB9XFxuICByZXR1cm4gZm9ybWF0KHZhbCk7XFxufTtcXG5cXG4vKipcXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xcbiAgdmFyIG1hdGNoID0gL14oKD86XFxcXGQrKT9cXFxcLj9cXFxcZCspICoobXN8c2Vjb25kcz98c3xtaW51dGVzP3xtfGhvdXJzP3xofGRheXM/fGR8eWVhcnM/fHkpPyQvaS5leGVjKFxcbiAgICBzdHJcXG4gICk7XFxuICBpZiAoIW1hdGNoKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XFxuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xcbiAgc3dpdGNoICh0eXBlKSB7XFxuICAgIGNhc2UgJ3llYXJzJzpcXG4gICAgY2FzZSAneWVhcic6XFxuICAgIGNhc2UgJ3knOlxcbiAgICAgIHJldHVybiBuICogeTtcXG4gICAgY2FzZSAnZGF5cyc6XFxuICAgIGNhc2UgJ2RheSc6XFxuICAgIGNhc2UgJ2QnOlxcbiAgICAgIHJldHVybiBuICogZDtcXG4gICAgY2FzZSAnaG91cnMnOlxcbiAgICBjYXNlICdob3VyJzpcXG4gICAgY2FzZSAnaCc6XFxuICAgICAgcmV0dXJuIG4gKiBoO1xcbiAgICBjYXNlICdtaW51dGVzJzpcXG4gICAgY2FzZSAnbWludXRlJzpcXG4gICAgY2FzZSAnbSc6XFxuICAgICAgcmV0dXJuIG4gKiBtO1xcbiAgICBjYXNlICdzZWNvbmRzJzpcXG4gICAgY2FzZSAnc2Vjb25kJzpcXG4gICAgY2FzZSAncyc6XFxuICAgICAgcmV0dXJuIG4gKiBzO1xcbiAgICBjYXNlICdtcyc6XFxuICAgICAgcmV0dXJuIG47XFxuICAgIGRlZmF1bHQ6XFxuICAgIC8vIE5vIGRlZmF1bHQgY2FzZVxcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBGb3JtYXQgZm9yIGBtc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gZm9ybWF0KG1zKSB7XFxuICBpZiAobXMgPj0gZCkge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xcbiAgfVxcbiAgaWYgKG1zID49IGgpIHtcXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcXG4gIH1cXG4gIGlmIChtcyA+PSBtKSB7XFxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XFxuICB9XFxuICBpZiAobXMgPj0gcykge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xcbiAgfVxcbiAgcmV0dXJuIG1zICsgJ21zJztcXG59XFxuXFxufSx7fV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFBlbmRpbmc7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUGVuZGluZ2AgZXJyb3Igd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZS5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXFxuICovXFxuZnVuY3Rpb24gUGVuZGluZyhtZXNzYWdlKSB7XFxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xcbn1cXG5cXG59LHt9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgQmFzZVxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xcbnZhciBkaWZmID0gcmVxdWlyZSgnZGlmZicpO1xcbnZhciBtcyA9IHJlcXVpcmUoJy4uL21zJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcXG52YXIgc3VwcG9ydHNDb2xvciA9IHByb2Nlc3MuYnJvd3NlciA/IG51bGwgOiByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgQmFzZWAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQmFzZTtcXG5cXG4vKipcXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcuXFxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbW9jaGFqcy9tb2NoYS9pc3N1ZXMvMjM3XFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG5cXG4vKipcXG4gKiBDaGVjayBpZiBib3RoIHN0ZGlvIHN0cmVhbXMgYXJlIGFzc29jaWF0ZWQgd2l0aCBhIHR0eS5cXG4gKi9cXG5cXG52YXIgaXNhdHR5ID0gdHR5LmlzYXR0eSgxKSAmJiB0dHkuaXNhdHR5KDIpO1xcblxcbi8qKlxcbiAqIEVuYWJsZSBjb2xvcmluZyBieSBkZWZhdWx0LCBleGNlcHQgaW4gdGhlIGJyb3dzZXIgaW50ZXJmYWNlLlxcbiAqL1xcblxcbmV4cG9ydHMudXNlQ29sb3JzID1cXG4gICFwcm9jZXNzLmJyb3dzZXIgJiZcXG4gIChzdXBwb3J0c0NvbG9yLnN0ZG91dCB8fCBwcm9jZXNzLmVudi5NT0NIQV9DT0xPUlMgIT09IHVuZGVmaW5lZCk7XFxuXFxuLyoqXFxuICogSW5saW5lIGRpZmZzIGluc3RlYWQgb2YgKy8tXFxuICovXFxuXFxuZXhwb3J0cy5pbmxpbmVEaWZmcyA9IGZhbHNlO1xcblxcbi8qKlxcbiAqIERlZmF1bHQgY29sb3IgbWFwLlxcbiAqL1xcblxcbmV4cG9ydHMuY29sb3JzID0ge1xcbiAgcGFzczogOTAsXFxuICBmYWlsOiAzMSxcXG4gICdicmlnaHQgcGFzcyc6IDkyLFxcbiAgJ2JyaWdodCBmYWlsJzogOTEsXFxuICAnYnJpZ2h0IHllbGxvdyc6IDkzLFxcbiAgcGVuZGluZzogMzYsXFxuICBzdWl0ZTogMCxcXG4gICdlcnJvciB0aXRsZSc6IDAsXFxuICAnZXJyb3IgbWVzc2FnZSc6IDMxLFxcbiAgJ2Vycm9yIHN0YWNrJzogOTAsXFxuICBjaGVja21hcms6IDMyLFxcbiAgZmFzdDogOTAsXFxuICBtZWRpdW06IDMzLFxcbiAgc2xvdzogMzEsXFxuICBncmVlbjogMzIsXFxuICBsaWdodDogOTAsXFxuICAnZGlmZiBndXR0ZXInOiA5MCxcXG4gICdkaWZmIGFkZGVkJzogMzIsXFxuICAnZGlmZiByZW1vdmVkJzogMzFcXG59O1xcblxcbi8qKlxcbiAqIERlZmF1bHQgc3ltYm9sIG1hcC5cXG4gKi9cXG5cXG5leHBvcnRzLnN5bWJvbHMgPSB7XFxuICBvazogJ+KckycsXFxuICBlcnI6ICfinJYnLFxcbiAgZG90OiAn4oCkJyxcXG4gIGNvbW1hOiAnLCcsXFxuICBiYW5nOiAnISdcXG59O1xcblxcbi8vIFdpdGggbm9kZS5qcyBvbiBXaW5kb3dzOiB1c2Ugc3ltYm9scyBhdmFpbGFibGUgaW4gdGVybWluYWwgZGVmYXVsdCBmb250c1xcbmlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XFxuICBleHBvcnRzLnN5bWJvbHMub2sgPSAnXFxcXHUyMjFBJztcXG4gIGV4cG9ydHMuc3ltYm9scy5lcnIgPSAnXFxcXHUwMEQ3JztcXG4gIGV4cG9ydHMuc3ltYm9scy5kb3QgPSAnLic7XFxufVxcblxcbi8qKlxcbiAqIENvbG9yIGBzdHJgIHdpdGggdGhlIGdpdmVuIGB0eXBlYCxcXG4gKiBhbGxvd2luZyBjb2xvcnMgdG8gYmUgZGlzYWJsZWQsXFxuICogYXMgd2VsbCBhcyB1c2VyLWRlZmluZWQgY29sb3JcXG4gKiBzY2hlbWVzLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbnZhciBjb2xvciA9IChleHBvcnRzLmNvbG9yID0gZnVuY3Rpb24odHlwZSwgc3RyKSB7XFxuICBpZiAoIWV4cG9ydHMudXNlQ29sb3JzKSB7XFxuICAgIHJldHVybiBTdHJpbmcoc3RyKTtcXG4gIH1cXG4gIHJldHVybiAnXFxcXHUwMDFiWycgKyBleHBvcnRzLmNvbG9yc1t0eXBlXSArICdtJyArIHN0ciArICdcXFxcdTAwMWJbMG0nO1xcbn0pO1xcblxcbi8qKlxcbiAqIEV4cG9zZSB0ZXJtIHdpbmRvdyBzaXplLCB3aXRoIHNvbWUgZGVmYXVsdHMgZm9yIHdoZW4gc3RkZXJyIGlzIG5vdCBhIHR0eS5cXG4gKi9cXG5cXG5leHBvcnRzLndpbmRvdyA9IHtcXG4gIHdpZHRoOiA3NVxcbn07XFxuXFxuaWYgKGlzYXR0eSkge1xcbiAgZXhwb3J0cy53aW5kb3cud2lkdGggPSBwcm9jZXNzLnN0ZG91dC5nZXRXaW5kb3dTaXplXFxuICAgID8gcHJvY2Vzcy5zdGRvdXQuZ2V0V2luZG93U2l6ZSgxKVswXVxcbiAgICA6IHR0eS5nZXRXaW5kb3dTaXplKClbMV07XFxufVxcblxcbi8qKlxcbiAqIEV4cG9zZSBzb21lIGJhc2ljIGN1cnNvciBpbnRlcmFjdGlvbnMgdGhhdCBhcmUgY29tbW9uIGFtb25nIHJlcG9ydGVycy5cXG4gKi9cXG5cXG5leHBvcnRzLmN1cnNvciA9IHtcXG4gIGhpZGU6IGZ1bmN0aW9uKCkge1xcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYls/MjVsJyk7XFxuICB9LFxcblxcbiAgc2hvdzogZnVuY3Rpb24oKSB7XFxuICAgIGlzYXR0eSAmJiBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHUwMDFiWz8yNWgnKTtcXG4gIH0sXFxuXFxuICBkZWxldGVMaW5lOiBmdW5jdGlvbigpIHtcXG4gICAgaXNhdHR5ICYmIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbMksnKTtcXG4gIH0sXFxuXFxuICBiZWdpbm5pbmdPZkxpbmU6IGZ1bmN0aW9uKCkge1xcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYlswRycpO1xcbiAgfSxcXG5cXG4gIENSOiBmdW5jdGlvbigpIHtcXG4gICAgaWYgKGlzYXR0eSkge1xcbiAgICAgIGV4cG9ydHMuY3Vyc29yLmRlbGV0ZUxpbmUoKTtcXG4gICAgICBleHBvcnRzLmN1cnNvci5iZWdpbm5pbmdPZkxpbmUoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHInKTtcXG4gICAgfVxcbiAgfVxcbn07XFxuXFxuZnVuY3Rpb24gc2hvd0RpZmYoZXJyKSB7XFxuICByZXR1cm4gKFxcbiAgICBlcnIgJiZcXG4gICAgZXJyLnNob3dEaWZmICE9PSBmYWxzZSAmJlxcbiAgICBzYW1lVHlwZShlcnIuYWN0dWFsLCBlcnIuZXhwZWN0ZWQpICYmXFxuICAgIGVyci5leHBlY3RlZCAhPT0gdW5kZWZpbmVkXFxuICApO1xcbn1cXG5cXG5mdW5jdGlvbiBzdHJpbmdpZnlEaWZmT2JqcyhlcnIpIHtcXG4gIGlmICghdXRpbHMuaXNTdHJpbmcoZXJyLmFjdHVhbCkgfHwgIXV0aWxzLmlzU3RyaW5nKGVyci5leHBlY3RlZCkpIHtcXG4gICAgZXJyLmFjdHVhbCA9IHV0aWxzLnN0cmluZ2lmeShlcnIuYWN0dWFsKTtcXG4gICAgZXJyLmV4cGVjdGVkID0gdXRpbHMuc3RyaW5naWZ5KGVyci5leHBlY3RlZCk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFJldHVybnMgYSBkaWZmIGJldHdlZW4gMiBzdHJpbmdzIHdpdGggY29sb3VyZWQgQU5TSSBvdXRwdXQuXFxuICpcXG4gKiBUaGUgZGlmZiB3aWxsIGJlIGVpdGhlciBpbmxpbmUgb3IgdW5pZmllZCBkZXBlbmRhbnQgb24gdGhlIHZhbHVlXFxuICogb2YgYEJhc2UuaW5saW5lRGlmZmAuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0dWFsXFxuICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkXFxuICogQHJldHVybiB7c3RyaW5nfSBEaWZmXFxuICovXFxudmFyIGdlbmVyYXRlRGlmZiA9IChleHBvcnRzLmdlbmVyYXRlRGlmZiA9IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcXG4gIHJldHVybiBleHBvcnRzLmlubGluZURpZmZzXFxuICAgID8gaW5saW5lRGlmZihhY3R1YWwsIGV4cGVjdGVkKVxcbiAgICA6IHVuaWZpZWREaWZmKGFjdHVhbCwgZXhwZWN0ZWQpO1xcbn0pO1xcblxcbi8qKlxcbiAqIE91dHB1dCB0aGUgZ2l2ZW4gYGZhaWx1cmVzYCBhcyBhIGxpc3QuXFxuICpcXG4gKiBAcHVibGljXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQHZhcmlhdGlvbiAxXFxuICogQHBhcmFtIHtBcnJheX0gZmFpbHVyZXNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmV4cG9ydHMubGlzdCA9IGZ1bmN0aW9uKGZhaWx1cmVzKSB7XFxuICBjb25zb2xlLmxvZygpO1xcbiAgZmFpbHVyZXMuZm9yRWFjaChmdW5jdGlvbih0ZXN0LCBpKSB7XFxuICAgIC8vIGZvcm1hdFxcbiAgICB2YXIgZm10ID1cXG4gICAgICBjb2xvcignZXJyb3IgdGl0bGUnLCAnICAlcykgJXM6XFxcXG4nKSArXFxuICAgICAgY29sb3IoJ2Vycm9yIG1lc3NhZ2UnLCAnICAgICAlcycpICtcXG4gICAgICBjb2xvcignZXJyb3Igc3RhY2snLCAnXFxcXG4lc1xcXFxuJyk7XFxuXFxuICAgIC8vIG1zZ1xcbiAgICB2YXIgbXNnO1xcbiAgICB2YXIgZXJyID0gdGVzdC5lcnI7XFxuICAgIHZhciBtZXNzYWdlO1xcbiAgICBpZiAoZXJyLm1lc3NhZ2UgJiYgdHlwZW9mIGVyci5tZXNzYWdlLnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgbWVzc2FnZSA9IGVyci5tZXNzYWdlICsgJyc7XFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVyci5pbnNwZWN0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgbWVzc2FnZSA9IGVyci5pbnNwZWN0KCkgKyAnJztcXG4gICAgfSBlbHNlIHtcXG4gICAgICBtZXNzYWdlID0gJyc7XFxuICAgIH1cXG4gICAgdmFyIHN0YWNrID0gZXJyLnN0YWNrIHx8IG1lc3NhZ2U7XFxuICAgIHZhciBpbmRleCA9IG1lc3NhZ2UgPyBzdGFjay5pbmRleE9mKG1lc3NhZ2UpIDogLTE7XFxuXFxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcXG4gICAgICBtc2cgPSBtZXNzYWdlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGluZGV4ICs9IG1lc3NhZ2UubGVuZ3RoO1xcbiAgICAgIG1zZyA9IHN0YWNrLnNsaWNlKDAsIGluZGV4KTtcXG4gICAgICAvLyByZW1vdmUgbXNnIGZyb20gc3RhY2tcXG4gICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKGluZGV4ICsgMSk7XFxuICAgIH1cXG5cXG4gICAgLy8gdW5jYXVnaHRcXG4gICAgaWYgKGVyci51bmNhdWdodCkge1xcbiAgICAgIG1zZyA9ICdVbmNhdWdodCAnICsgbXNnO1xcbiAgICB9XFxuICAgIC8vIGV4cGxpY2l0bHkgc2hvdyBkaWZmXFxuICAgIGlmICghZXhwb3J0cy5oaWRlRGlmZiAmJiBzaG93RGlmZihlcnIpKSB7XFxuICAgICAgc3RyaW5naWZ5RGlmZk9ianMoZXJyKTtcXG4gICAgICBmbXQgPVxcbiAgICAgICAgY29sb3IoJ2Vycm9yIHRpdGxlJywgJyAgJXMpICVzOlxcXFxuJXMnKSArIGNvbG9yKCdlcnJvciBzdGFjaycsICdcXFxcbiVzXFxcXG4nKTtcXG4gICAgICB2YXIgbWF0Y2ggPSBtZXNzYWdlLm1hdGNoKC9eKFteOl0rKTogZXhwZWN0ZWQvKTtcXG4gICAgICBtc2cgPSAnXFxcXG4gICAgICAnICsgY29sb3IoJ2Vycm9yIG1lc3NhZ2UnLCBtYXRjaCA/IG1hdGNoWzFdIDogbXNnKTtcXG5cXG4gICAgICBtc2cgKz0gZ2VuZXJhdGVEaWZmKGVyci5hY3R1YWwsIGVyci5leHBlY3RlZCk7XFxuICAgIH1cXG5cXG4gICAgLy8gaW5kZW50IHN0YWNrIHRyYWNlXFxuICAgIHN0YWNrID0gc3RhY2sucmVwbGFjZSgvXi9nbSwgJyAgJyk7XFxuXFxuICAgIC8vIGluZGVudGVkIHRlc3QgdGl0bGVcXG4gICAgdmFyIHRlc3RUaXRsZSA9ICcnO1xcbiAgICB0ZXN0LnRpdGxlUGF0aCgpLmZvckVhY2goZnVuY3Rpb24oc3RyLCBpbmRleCkge1xcbiAgICAgIGlmIChpbmRleCAhPT0gMCkge1xcbiAgICAgICAgdGVzdFRpdGxlICs9ICdcXFxcbiAgICAgJztcXG4gICAgICB9XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XFxuICAgICAgICB0ZXN0VGl0bGUgKz0gJyAgJztcXG4gICAgICB9XFxuICAgICAgdGVzdFRpdGxlICs9IHN0cjtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnNvbGUubG9nKGZtdCwgaSArIDEsIHRlc3RUaXRsZSwgbXNnLCBzdGFjayk7XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYEJhc2VgIHJlcG9ydGVyLlxcbiAqXFxuICogQWxsIG90aGVyIHJlcG9ydGVycyBnZW5lcmFsbHlcXG4gKiBpbmhlcml0IGZyb20gdGhpcyByZXBvcnRlciwgcHJvdmlkaW5nXFxuICogc3RhdHMgc3VjaCBhcyB0ZXN0IGR1cmF0aW9uLCBudW1iZXJcXG4gKiBvZiB0ZXN0cyBwYXNzZWQgLyBmYWlsZWQgZXRjLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5mdW5jdGlvbiBCYXNlKHJ1bm5lcikge1xcbiAgdmFyIHN0YXRzID0gKHRoaXMuc3RhdHMgPSB7XFxuICAgIHN1aXRlczogMCxcXG4gICAgdGVzdHM6IDAsXFxuICAgIHBhc3NlczogMCxcXG4gICAgcGVuZGluZzogMCxcXG4gICAgZmFpbHVyZXM6IDBcXG4gIH0pO1xcbiAgdmFyIGZhaWx1cmVzID0gKHRoaXMuZmFpbHVyZXMgPSBbXSk7XFxuXFxuICBpZiAoIXJ1bm5lcikge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB0aGlzLnJ1bm5lciA9IHJ1bm5lcjtcXG5cXG4gIHJ1bm5lci5zdGF0cyA9IHN0YXRzO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xcbiAgICBzdGF0cy5zdGFydCA9IG5ldyBEYXRlKCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUnLCBmdW5jdGlvbihzdWl0ZSkge1xcbiAgICBzdGF0cy5zdWl0ZXMgPSBzdGF0cy5zdWl0ZXMgfHwgMDtcXG4gICAgc3VpdGUucm9vdCB8fCBzdGF0cy5zdWl0ZXMrKztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBzdGF0cy50ZXN0cyA9IHN0YXRzLnRlc3RzIHx8IDA7XFxuICAgIHN0YXRzLnRlc3RzKys7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgc3RhdHMucGFzc2VzID0gc3RhdHMucGFzc2VzIHx8IDA7XFxuXFxuICAgIGlmICh0ZXN0LmR1cmF0aW9uID4gdGVzdC5zbG93KCkpIHtcXG4gICAgICB0ZXN0LnNwZWVkID0gJ3Nsb3cnO1xcbiAgICB9IGVsc2UgaWYgKHRlc3QuZHVyYXRpb24gPiB0ZXN0LnNsb3coKSAvIDIpIHtcXG4gICAgICB0ZXN0LnNwZWVkID0gJ21lZGl1bSc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGVzdC5zcGVlZCA9ICdmYXN0JztcXG4gICAgfVxcblxcbiAgICBzdGF0cy5wYXNzZXMrKztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24odGVzdCwgZXJyKSB7XFxuICAgIHN0YXRzLmZhaWx1cmVzID0gc3RhdHMuZmFpbHVyZXMgfHwgMDtcXG4gICAgc3RhdHMuZmFpbHVyZXMrKztcXG4gICAgaWYgKHNob3dEaWZmKGVycikpIHtcXG4gICAgICBzdHJpbmdpZnlEaWZmT2JqcyhlcnIpO1xcbiAgICB9XFxuICAgIHRlc3QuZXJyID0gZXJyO1xcbiAgICBmYWlsdXJlcy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgIHN0YXRzLmVuZCA9IG5ldyBEYXRlKCk7XFxuICAgIHN0YXRzLmR1cmF0aW9uID0gc3RhdHMuZW5kIC0gc3RhdHMuc3RhcnQ7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uKCkge1xcbiAgICBzdGF0cy5wZW5kaW5nKys7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogT3V0cHV0IGNvbW1vbiBlcGlsb2d1ZSB1c2VkIGJ5IG1hbnkgb2ZcXG4gKiB0aGUgYnVuZGxlZCByZXBvcnRlcnMuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5CYXNlLnByb3RvdHlwZS5lcGlsb2d1ZSA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG4gIHZhciBmbXQ7XFxuXFxuICBjb25zb2xlLmxvZygpO1xcblxcbiAgLy8gcGFzc2VzXFxuICBmbXQgPVxcbiAgICBjb2xvcignYnJpZ2h0IHBhc3MnLCAnICcpICtcXG4gICAgY29sb3IoJ2dyZWVuJywgJyAlZCBwYXNzaW5nJykgK1xcbiAgICBjb2xvcignbGlnaHQnLCAnICglcyknKTtcXG5cXG4gIGNvbnNvbGUubG9nKGZtdCwgc3RhdHMucGFzc2VzIHx8IDAsIG1zKHN0YXRzLmR1cmF0aW9uKSk7XFxuXFxuICAvLyBwZW5kaW5nXFxuICBpZiAoc3RhdHMucGVuZGluZykge1xcbiAgICBmbXQgPSBjb2xvcigncGVuZGluZycsICcgJykgKyBjb2xvcigncGVuZGluZycsICcgJWQgcGVuZGluZycpO1xcblxcbiAgICBjb25zb2xlLmxvZyhmbXQsIHN0YXRzLnBlbmRpbmcpO1xcbiAgfVxcblxcbiAgLy8gZmFpbHVyZXNcXG4gIGlmIChzdGF0cy5mYWlsdXJlcykge1xcbiAgICBmbXQgPSBjb2xvcignZmFpbCcsICcgICVkIGZhaWxpbmcnKTtcXG5cXG4gICAgY29uc29sZS5sb2coZm10LCBzdGF0cy5mYWlsdXJlcyk7XFxuXFxuICAgIEJhc2UubGlzdCh0aGlzLmZhaWx1cmVzKTtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gIH1cXG5cXG4gIGNvbnNvbGUubG9nKCk7XFxufTtcXG5cXG4vKipcXG4gKiBQYWQgdGhlIGdpdmVuIGBzdHJgIHRvIGBsZW5gLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZW5cXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gcGFkKHN0ciwgbGVuKSB7XFxuICBzdHIgPSBTdHJpbmcoc3RyKTtcXG4gIHJldHVybiBBcnJheShsZW4gLSBzdHIubGVuZ3RoICsgMSkuam9pbignICcpICsgc3RyO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGFuIGlubGluZSBkaWZmIGJldHdlZW4gMiBzdHJpbmdzIHdpdGggY29sb3VyZWQgQU5TSSBvdXRwdXQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0dWFsXFxuICogQHBhcmFtIHtTdHJpbmd9IGV4cGVjdGVkXFxuICogQHJldHVybiB7c3RyaW5nfSBEaWZmXFxuICovXFxuZnVuY3Rpb24gaW5saW5lRGlmZihhY3R1YWwsIGV4cGVjdGVkKSB7XFxuICB2YXIgbXNnID0gZXJyb3JEaWZmKGFjdHVhbCwgZXhwZWN0ZWQpO1xcblxcbiAgLy8gbGluZW5vc1xcbiAgdmFyIGxpbmVzID0gbXNnLnNwbGl0KCdcXFxcbicpO1xcbiAgaWYgKGxpbmVzLmxlbmd0aCA+IDQpIHtcXG4gICAgdmFyIHdpZHRoID0gU3RyaW5nKGxpbmVzLmxlbmd0aCkubGVuZ3RoO1xcbiAgICBtc2cgPSBsaW5lc1xcbiAgICAgIC5tYXAoZnVuY3Rpb24oc3RyLCBpKSB7XFxuICAgICAgICByZXR1cm4gcGFkKCsraSwgd2lkdGgpICsgJyB8JyArICcgJyArIHN0cjtcXG4gICAgICB9KVxcbiAgICAgIC5qb2luKCdcXFxcbicpO1xcbiAgfVxcblxcbiAgLy8gbGVnZW5kXFxuICBtc2cgPVxcbiAgICAnXFxcXG4nICtcXG4gICAgY29sb3IoJ2RpZmYgcmVtb3ZlZCcsICdhY3R1YWwnKSArXFxuICAgICcgJyArXFxuICAgIGNvbG9yKCdkaWZmIGFkZGVkJywgJ2V4cGVjdGVkJykgK1xcbiAgICAnXFxcXG5cXFxcbicgK1xcbiAgICBtc2cgK1xcbiAgICAnXFxcXG4nO1xcblxcbiAgLy8gaW5kZW50XFxuICBtc2cgPSBtc2cucmVwbGFjZSgvXi9nbSwgJyAgICAgICcpO1xcbiAgcmV0dXJuIG1zZztcXG59XFxuXFxuLyoqXFxuICogUmV0dXJucyBhIHVuaWZpZWQgZGlmZiBiZXR3ZWVuIHR3byBzdHJpbmdzIHdpdGggY29sb3VyZWQgQU5TSSBvdXRwdXQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0dWFsXFxuICogQHBhcmFtIHtTdHJpbmd9IGV4cGVjdGVkXFxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZGlmZi5cXG4gKi9cXG5mdW5jdGlvbiB1bmlmaWVkRGlmZihhY3R1YWwsIGV4cGVjdGVkKSB7XFxuICB2YXIgaW5kZW50ID0gJyAgICAgICc7XFxuICBmdW5jdGlvbiBjbGVhblVwKGxpbmUpIHtcXG4gICAgaWYgKGxpbmVbMF0gPT09ICcrJykge1xcbiAgICAgIHJldHVybiBpbmRlbnQgKyBjb2xvckxpbmVzKCdkaWZmIGFkZGVkJywgbGluZSk7XFxuICAgIH1cXG4gICAgaWYgKGxpbmVbMF0gPT09ICctJykge1xcbiAgICAgIHJldHVybiBpbmRlbnQgKyBjb2xvckxpbmVzKCdkaWZmIHJlbW92ZWQnLCBsaW5lKTtcXG4gICAgfVxcbiAgICBpZiAobGluZS5tYXRjaCgvQEAvKSkge1xcbiAgICAgIHJldHVybiAnLS0nO1xcbiAgICB9XFxuICAgIGlmIChsaW5lLm1hdGNoKC9cXFxcXFxcXCBObyBuZXdsaW5lLykpIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICByZXR1cm4gaW5kZW50ICsgbGluZTtcXG4gIH1cXG4gIGZ1bmN0aW9uIG5vdEJsYW5rKGxpbmUpIHtcXG4gICAgcmV0dXJuIHR5cGVvZiBsaW5lICE9PSAndW5kZWZpbmVkJyAmJiBsaW5lICE9PSBudWxsO1xcbiAgfVxcbiAgdmFyIG1zZyA9IGRpZmYuY3JlYXRlUGF0Y2goJ3N0cmluZycsIGFjdHVhbCwgZXhwZWN0ZWQpO1xcbiAgdmFyIGxpbmVzID0gbXNnLnNwbGl0KCdcXFxcbicpLnNwbGljZSg1KTtcXG4gIHJldHVybiAoXFxuICAgICdcXFxcbiAgICAgICcgK1xcbiAgICBjb2xvckxpbmVzKCdkaWZmIGFkZGVkJywgJysgZXhwZWN0ZWQnKSArXFxuICAgICcgJyArXFxuICAgIGNvbG9yTGluZXMoJ2RpZmYgcmVtb3ZlZCcsICctIGFjdHVhbCcpICtcXG4gICAgJ1xcXFxuXFxcXG4nICtcXG4gICAgbGluZXNcXG4gICAgICAubWFwKGNsZWFuVXApXFxuICAgICAgLmZpbHRlcihub3RCbGFuaylcXG4gICAgICAuam9pbignXFxcXG4nKVxcbiAgKTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgY2hhcmFjdGVyIGRpZmYgZm9yIGBlcnJgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtTdHJpbmd9IGFjdHVhbFxcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBlY3RlZFxcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGRpZmZcXG4gKi9cXG5mdW5jdGlvbiBlcnJvckRpZmYoYWN0dWFsLCBleHBlY3RlZCkge1xcbiAgcmV0dXJuIGRpZmZcXG4gICAgLmRpZmZXb3Jkc1dpdGhTcGFjZShhY3R1YWwsIGV4cGVjdGVkKVxcbiAgICAubWFwKGZ1bmN0aW9uKHN0cikge1xcbiAgICAgIGlmIChzdHIuYWRkZWQpIHtcXG4gICAgICAgIHJldHVybiBjb2xvckxpbmVzKCdkaWZmIGFkZGVkJywgc3RyLnZhbHVlKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHN0ci5yZW1vdmVkKSB7XFxuICAgICAgICByZXR1cm4gY29sb3JMaW5lcygnZGlmZiByZW1vdmVkJywgc3RyLnZhbHVlKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHN0ci52YWx1ZTtcXG4gICAgfSlcXG4gICAgLmpvaW4oJycpO1xcbn1cXG5cXG4vKipcXG4gKiBDb2xvciBsaW5lcyBmb3IgYHN0cmAsIHVzaW5nIHRoZSBjb2xvciBgbmFtZWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gY29sb3JMaW5lcyhuYW1lLCBzdHIpIHtcXG4gIHJldHVybiBzdHJcXG4gICAgLnNwbGl0KCdcXFxcbicpXFxuICAgIC5tYXAoZnVuY3Rpb24oc3RyKSB7XFxuICAgICAgcmV0dXJuIGNvbG9yKG5hbWUsIHN0cik7XFxuICAgIH0pXFxuICAgIC5qb2luKCdcXFxcbicpO1xcbn1cXG5cXG4vKipcXG4gKiBPYmplY3QjdG9TdHJpbmcgcmVmZXJlbmNlLlxcbiAqL1xcbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XFxuXFxuLyoqXFxuICogQ2hlY2sgdGhhdCBhIC8gYiBoYXZlIHRoZSBzYW1lIHR5cGUuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gYVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXFxuICogQHJldHVybiB7Ym9vbGVhbn1cXG4gKi9cXG5mdW5jdGlvbiBzYW1lVHlwZShhLCBiKSB7XFxuICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbChhKSA9PT0gb2JqVG9TdHJpbmcuY2FsbChiKTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi4vbXNcXFwiOjE0LFxcXCIuLi91dGlsc1xcXCI6MzYsXFxcIl9wcm9jZXNzXFxcIjo1NixcXFwiZGlmZlxcXCI6NDUsXFxcInN1cHBvcnRzLWNvbG9yXFxcIjo0MCxcXFwidHR5XFxcIjo0fV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIERvY1xcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgRG9jYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBEb2M7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRG9jYCByZXBvcnRlci5cXG4gKlxcbiAqIEBjbGFzc1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyB7QmFzZX1cXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuZnVuY3Rpb24gRG9jKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgaW5kZW50cyA9IDI7XFxuXFxuICBmdW5jdGlvbiBpbmRlbnQoKSB7XFxuICAgIHJldHVybiBBcnJheShpbmRlbnRzKS5qb2luKCcgICcpO1xcbiAgfVxcblxcbiAgcnVubmVyLm9uKCdzdWl0ZScsIGZ1bmN0aW9uKHN1aXRlKSB7XFxuICAgIGlmIChzdWl0ZS5yb290KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgICsraW5kZW50cztcXG4gICAgY29uc29sZS5sb2coJyVzPHNlY3Rpb24gY2xhc3M9XFxcInN1aXRlXFxcIj4nLCBpbmRlbnQoKSk7XFxuICAgICsraW5kZW50cztcXG4gICAgY29uc29sZS5sb2coJyVzPGgxPiVzPC9oMT4nLCBpbmRlbnQoKSwgdXRpbHMuZXNjYXBlKHN1aXRlLnRpdGxlKSk7XFxuICAgIGNvbnNvbGUubG9nKCclczxkbD4nLCBpbmRlbnQoKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUgZW5kJywgZnVuY3Rpb24oc3VpdGUpIHtcXG4gICAgaWYgKHN1aXRlLnJvb3QpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgY29uc29sZS5sb2coJyVzPC9kbD4nLCBpbmRlbnQoKSk7XFxuICAgIC0taW5kZW50cztcXG4gICAgY29uc29sZS5sb2coJyVzPC9zZWN0aW9uPicsIGluZGVudCgpKTtcXG4gICAgLS1pbmRlbnRzO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIGNvbnNvbGUubG9nKCclcyAgPGR0PiVzPC9kdD4nLCBpbmRlbnQoKSwgdXRpbHMuZXNjYXBlKHRlc3QudGl0bGUpKTtcXG4gICAgdmFyIGNvZGUgPSB1dGlscy5lc2NhcGUodXRpbHMuY2xlYW4odGVzdC5ib2R5KSk7XFxuICAgIGNvbnNvbGUubG9nKCclcyAgPGRkPjxwcmU+PGNvZGU+JXM8L2NvZGU+PC9wcmU+PC9kZD4nLCBpbmRlbnQoKSwgY29kZSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uKHRlc3QsIGVycikge1xcbiAgICBjb25zb2xlLmxvZyhcXG4gICAgICAnJXMgIDxkdCBjbGFzcz1cXFwiZXJyb3JcXFwiPiVzPC9kdD4nLFxcbiAgICAgIGluZGVudCgpLFxcbiAgICAgIHV0aWxzLmVzY2FwZSh0ZXN0LnRpdGxlKVxcbiAgICApO1xcbiAgICB2YXIgY29kZSA9IHV0aWxzLmVzY2FwZSh1dGlscy5jbGVhbih0ZXN0LmJvZHkpKTtcXG4gICAgY29uc29sZS5sb2coXFxuICAgICAgJyVzICA8ZGQgY2xhc3M9XFxcImVycm9yXFxcIj48cHJlPjxjb2RlPiVzPC9jb2RlPjwvcHJlPjwvZGQ+JyxcXG4gICAgICBpbmRlbnQoKSxcXG4gICAgICBjb2RlXFxuICAgICk7XFxuICAgIGNvbnNvbGUubG9nKCclcyAgPGRkIGNsYXNzPVxcXCJlcnJvclxcXCI+JXM8L2RkPicsIGluZGVudCgpLCB1dGlscy5lc2NhcGUoZXJyKSk7XFxuICB9KTtcXG59XFxuXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozNixcXFwiLi9iYXNlXFxcIjoxNn1dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIERvdFxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBEb3RgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IERvdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBEb3RgIG1hdHJpeCB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQGNsYXNzXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIERvdChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHdpZHRoID0gKEJhc2Uud2luZG93LndpZHRoICogMC43NSkgfCAwO1xcbiAgdmFyIG4gPSAtMTtcXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbigpIHtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFxuJyk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uKCkge1xcbiAgICBpZiAoKytuICUgd2lkdGggPT09IDApIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXG4gICcpO1xcbiAgICB9XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwZW5kaW5nJywgQmFzZS5zeW1ib2xzLmNvbW1hKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgaWYgKCsrbiAlIHdpZHRoID09PSAwKSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFxuICAnKTtcXG4gICAgfVxcbiAgICBpZiAodGVzdC5zcGVlZCA9PT0gJ3Nsb3cnKSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ2JyaWdodCB5ZWxsb3cnLCBCYXNlLnN5bWJvbHMuZG90KSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IodGVzdC5zcGVlZCwgQmFzZS5zeW1ib2xzLmRvdCkpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uKCkge1xcbiAgICBpZiAoKytuICUgd2lkdGggPT09IDApIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXG4gICcpO1xcbiAgICB9XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdmYWlsJywgQmFzZS5zeW1ib2xzLmJhbmcpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgICBzZWxmLmVwaWxvZ3VlKCk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoRG90LCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM2LFxcXCIuL2Jhc2VcXFwiOjE2LFxcXCJfcHJvY2Vzc1xcXCI6NTZ9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cXG4vKipcXG4gKiBAbW9kdWxlIEhUTUxcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcXG52YXIgUHJvZ3Jlc3MgPSByZXF1aXJlKCcuLi9icm93c2VyL3Byb2dyZXNzJyk7XFxudmFyIGVzY2FwZVJlID0gcmVxdWlyZSgnZXNjYXBlLXN0cmluZy1yZWdleHAnKTtcXG52YXIgZXNjYXBlID0gdXRpbHMuZXNjYXBlO1xcblxcbi8qKlxcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG5cXG4vKipcXG4gKiBFeHBvc2UgYEhUTUxgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEhUTUw7XFxuXFxuLyoqXFxuICogU3RhdHMgdGVtcGxhdGUuXFxuICovXFxuXFxudmFyIHN0YXRzVGVtcGxhdGUgPVxcbiAgJzx1bCBpZD1cXFwibW9jaGEtc3RhdHNcXFwiPicgK1xcbiAgJzxsaSBjbGFzcz1cXFwicHJvZ3Jlc3NcXFwiPjxjYW52YXMgd2lkdGg9XFxcIjQwXFxcIiBoZWlnaHQ9XFxcIjQwXFxcIj48L2NhbnZhcz48L2xpPicgK1xcbiAgJzxsaSBjbGFzcz1cXFwicGFzc2VzXFxcIj48YSBocmVmPVxcXCJqYXZhc2NyaXB0OnZvaWQoMCk7XFxcIj5wYXNzZXM6PC9hPiA8ZW0+MDwvZW0+PC9saT4nICtcXG4gICc8bGkgY2xhc3M9XFxcImZhaWx1cmVzXFxcIj48YSBocmVmPVxcXCJqYXZhc2NyaXB0OnZvaWQoMCk7XFxcIj5mYWlsdXJlczo8L2E+IDxlbT4wPC9lbT48L2xpPicgK1xcbiAgJzxsaSBjbGFzcz1cXFwiZHVyYXRpb25cXFwiPmR1cmF0aW9uOiA8ZW0+MDwvZW0+czwvbGk+JyArXFxuICAnPC91bD4nO1xcblxcbnZhciBwbGF5SWNvbiA9ICcmI3gyMDIzOyc7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgSFRNTGAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gSFRNTChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG4gIHZhciBzdGF0ID0gZnJhZ21lbnQoc3RhdHNUZW1wbGF0ZSk7XFxuICB2YXIgaXRlbXMgPSBzdGF0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaScpO1xcbiAgdmFyIHBhc3NlcyA9IGl0ZW1zWzFdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdlbScpWzBdO1xcbiAgdmFyIHBhc3Nlc0xpbmsgPSBpdGVtc1sxXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpWzBdO1xcbiAgdmFyIGZhaWx1cmVzID0gaXRlbXNbMl0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2VtJylbMF07XFxuICB2YXIgZmFpbHVyZXNMaW5rID0gaXRlbXNbMl0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKVswXTtcXG4gIHZhciBkdXJhdGlvbiA9IGl0ZW1zWzNdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdlbScpWzBdO1xcbiAgdmFyIGNhbnZhcyA9IHN0YXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NhbnZhcycpWzBdO1xcbiAgdmFyIHJlcG9ydCA9IGZyYWdtZW50KCc8dWwgaWQ9XFxcIm1vY2hhLXJlcG9ydFxcXCI+PC91bD4nKTtcXG4gIHZhciBzdGFjayA9IFtyZXBvcnRdO1xcbiAgdmFyIHByb2dyZXNzO1xcbiAgdmFyIGN0eDtcXG4gIHZhciByb290ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhJyk7XFxuXFxuICBpZiAoY2FudmFzLmdldENvbnRleHQpIHtcXG4gICAgdmFyIHJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcXG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gY2FudmFzLndpZHRoO1xcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcXG4gICAgY2FudmFzLndpZHRoICo9IHJhdGlvO1xcbiAgICBjYW52YXMuaGVpZ2h0ICo9IHJhdGlvO1xcbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcXG4gICAgY3R4LnNjYWxlKHJhdGlvLCByYXRpbyk7XFxuICAgIHByb2dyZXNzID0gbmV3IFByb2dyZXNzKCk7XFxuICB9XFxuXFxuICBpZiAoIXJvb3QpIHtcXG4gICAgcmV0dXJuIGVycm9yKCcjbW9jaGEgZGl2IG1pc3NpbmcsIGFkZCBpdCB0byB5b3VyIGRvY3VtZW50Jyk7XFxuICB9XFxuXFxuICAvLyBwYXNzIHRvZ2dsZVxcbiAgb24ocGFzc2VzTGluaywgJ2NsaWNrJywgZnVuY3Rpb24oZXZ0KSB7XFxuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICB1bmhpZGUoKTtcXG4gICAgdmFyIG5hbWUgPSAvcGFzcy8udGVzdChyZXBvcnQuY2xhc3NOYW1lKSA/ICcnIDogJyBwYXNzJztcXG4gICAgcmVwb3J0LmNsYXNzTmFtZSA9IHJlcG9ydC5jbGFzc05hbWUucmVwbGFjZSgvZmFpbHxwYXNzL2csICcnKSArIG5hbWU7XFxuICAgIGlmIChyZXBvcnQuY2xhc3NOYW1lLnRyaW0oKSkge1xcbiAgICAgIGhpZGVTdWl0ZXNXaXRob3V0KCd0ZXN0IHBhc3MnKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyBmYWlsdXJlIHRvZ2dsZVxcbiAgb24oZmFpbHVyZXNMaW5rLCAnY2xpY2snLCBmdW5jdGlvbihldnQpIHtcXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuICAgIHVuaGlkZSgpO1xcbiAgICB2YXIgbmFtZSA9IC9mYWlsLy50ZXN0KHJlcG9ydC5jbGFzc05hbWUpID8gJycgOiAnIGZhaWwnO1xcbiAgICByZXBvcnQuY2xhc3NOYW1lID0gcmVwb3J0LmNsYXNzTmFtZS5yZXBsYWNlKC9mYWlsfHBhc3MvZywgJycpICsgbmFtZTtcXG4gICAgaWYgKHJlcG9ydC5jbGFzc05hbWUudHJpbSgpKSB7XFxuICAgICAgaGlkZVN1aXRlc1dpdGhvdXQoJ3Rlc3QgZmFpbCcpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJvb3QuYXBwZW5kQ2hpbGQoc3RhdCk7XFxuICByb290LmFwcGVuZENoaWxkKHJlcG9ydCk7XFxuXFxuICBpZiAocHJvZ3Jlc3MpIHtcXG4gICAgcHJvZ3Jlc3Muc2l6ZSg0MCk7XFxuICB9XFxuXFxuICBydW5uZXIub24oJ3N1aXRlJywgZnVuY3Rpb24oc3VpdGUpIHtcXG4gICAgaWYgKHN1aXRlLnJvb3QpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gc3VpdGVcXG4gICAgdmFyIHVybCA9IHNlbGYuc3VpdGVVUkwoc3VpdGUpO1xcbiAgICB2YXIgZWwgPSBmcmFnbWVudChcXG4gICAgICAnPGxpIGNsYXNzPVxcXCJzdWl0ZVxcXCI+PGgxPjxhIGhyZWY9XFxcIiVzXFxcIj4lczwvYT48L2gxPjwvbGk+JyxcXG4gICAgICB1cmwsXFxuICAgICAgZXNjYXBlKHN1aXRlLnRpdGxlKVxcbiAgICApO1xcblxcbiAgICAvLyBjb250YWluZXJcXG4gICAgc3RhY2tbMF0uYXBwZW5kQ2hpbGQoZWwpO1xcbiAgICBzdGFjay51bnNoaWZ0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJykpO1xcbiAgICBlbC5hcHBlbmRDaGlsZChzdGFja1swXSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUgZW5kJywgZnVuY3Rpb24oc3VpdGUpIHtcXG4gICAgaWYgKHN1aXRlLnJvb3QpIHtcXG4gICAgICB1cGRhdGVTdGF0cygpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBzdGFjay5zaGlmdCgpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHZhciB1cmwgPSBzZWxmLnRlc3RVUkwodGVzdCk7XFxuICAgIHZhciBtYXJrdXAgPVxcbiAgICAgICc8bGkgY2xhc3M9XFxcInRlc3QgcGFzcyAlZVxcXCI+PGgyPiVlPHNwYW4gY2xhc3M9XFxcImR1cmF0aW9uXFxcIj4lZW1zPC9zcGFuPiAnICtcXG4gICAgICAnPGEgaHJlZj1cXFwiJXNcXFwiIGNsYXNzPVxcXCJyZXBsYXlcXFwiPicgK1xcbiAgICAgIHBsYXlJY29uICtcXG4gICAgICAnPC9hPjwvaDI+PC9saT4nO1xcbiAgICB2YXIgZWwgPSBmcmFnbWVudChtYXJrdXAsIHRlc3Quc3BlZWQsIHRlc3QudGl0bGUsIHRlc3QuZHVyYXRpb24sIHVybCk7XFxuICAgIHNlbGYuYWRkQ29kZVRvZ2dsZShlbCwgdGVzdC5ib2R5KTtcXG4gICAgYXBwZW5kVG9TdGFjayhlbCk7XFxuICAgIHVwZGF0ZVN0YXRzKCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgdmFyIGVsID0gZnJhZ21lbnQoXFxuICAgICAgJzxsaSBjbGFzcz1cXFwidGVzdCBmYWlsXFxcIj48aDI+JWUgPGEgaHJlZj1cXFwiJWVcXFwiIGNsYXNzPVxcXCJyZXBsYXlcXFwiPicgK1xcbiAgICAgICAgcGxheUljb24gK1xcbiAgICAgICAgJzwvYT48L2gyPjwvbGk+JyxcXG4gICAgICB0ZXN0LnRpdGxlLFxcbiAgICAgIHNlbGYudGVzdFVSTCh0ZXN0KVxcbiAgICApO1xcbiAgICB2YXIgc3RhY2tTdHJpbmc7IC8vIE5vdGU6IEluY2x1ZGVzIGxlYWRpbmcgbmV3bGluZVxcbiAgICB2YXIgbWVzc2FnZSA9IHRlc3QuZXJyLnRvU3RyaW5nKCk7XFxuXFxuICAgIC8vIDw9SUU3IHN0cmluZ2lmaWVzIHRvIFtPYmplY3QgRXJyb3JdLiBTaW5jZSBpdCBjYW4gYmUgb3ZlcmxvYWRlZCwgd2VcXG4gICAgLy8gY2hlY2sgZm9yIHRoZSByZXN1bHQgb2YgdGhlIHN0cmluZ2lmeWluZy5cXG4gICAgaWYgKG1lc3NhZ2UgPT09ICdbb2JqZWN0IEVycm9yXScpIHtcXG4gICAgICBtZXNzYWdlID0gdGVzdC5lcnIubWVzc2FnZTtcXG4gICAgfVxcblxcbiAgICBpZiAodGVzdC5lcnIuc3RhY2spIHtcXG4gICAgICB2YXIgaW5kZXhPZk1lc3NhZ2UgPSB0ZXN0LmVyci5zdGFjay5pbmRleE9mKHRlc3QuZXJyLm1lc3NhZ2UpO1xcbiAgICAgIGlmIChpbmRleE9mTWVzc2FnZSA9PT0gLTEpIHtcXG4gICAgICAgIHN0YWNrU3RyaW5nID0gdGVzdC5lcnIuc3RhY2s7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN0YWNrU3RyaW5nID0gdGVzdC5lcnIuc3RhY2suc3Vic3RyKFxcbiAgICAgICAgICB0ZXN0LmVyci5tZXNzYWdlLmxlbmd0aCArIGluZGV4T2ZNZXNzYWdlXFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICh0ZXN0LmVyci5zb3VyY2VVUkwgJiYgdGVzdC5lcnIubGluZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgZ2l2ZSB5b3UgYSBzdGFjay4gTGV0J3MgYXQgbGVhc3QgcHJvdmlkZSBhIHNvdXJjZSBsaW5lLlxcbiAgICAgIHN0YWNrU3RyaW5nID0gJ1xcXFxuKCcgKyB0ZXN0LmVyci5zb3VyY2VVUkwgKyAnOicgKyB0ZXN0LmVyci5saW5lICsgJyknO1xcbiAgICB9XFxuXFxuICAgIHN0YWNrU3RyaW5nID0gc3RhY2tTdHJpbmcgfHwgJyc7XFxuXFxuICAgIGlmICh0ZXN0LmVyci5odG1sTWVzc2FnZSAmJiBzdGFja1N0cmluZykge1xcbiAgICAgIGVsLmFwcGVuZENoaWxkKFxcbiAgICAgICAgZnJhZ21lbnQoXFxuICAgICAgICAgICc8ZGl2IGNsYXNzPVxcXCJodG1sLWVycm9yXFxcIj4lc1xcXFxuPHByZSBjbGFzcz1cXFwiZXJyb3JcXFwiPiVlPC9wcmU+PC9kaXY+JyxcXG4gICAgICAgICAgdGVzdC5lcnIuaHRtbE1lc3NhZ2UsXFxuICAgICAgICAgIHN0YWNrU3RyaW5nXFxuICAgICAgICApXFxuICAgICAgKTtcXG4gICAgfSBlbHNlIGlmICh0ZXN0LmVyci5odG1sTWVzc2FnZSkge1xcbiAgICAgIGVsLmFwcGVuZENoaWxkKFxcbiAgICAgICAgZnJhZ21lbnQoJzxkaXYgY2xhc3M9XFxcImh0bWwtZXJyb3JcXFwiPiVzPC9kaXY+JywgdGVzdC5lcnIuaHRtbE1lc3NhZ2UpXFxuICAgICAgKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBlbC5hcHBlbmRDaGlsZChcXG4gICAgICAgIGZyYWdtZW50KCc8cHJlIGNsYXNzPVxcXCJlcnJvclxcXCI+JWUlZTwvcHJlPicsIG1lc3NhZ2UsIHN0YWNrU3RyaW5nKVxcbiAgICAgICk7XFxuICAgIH1cXG5cXG4gICAgc2VsZi5hZGRDb2RlVG9nZ2xlKGVsLCB0ZXN0LmJvZHkpO1xcbiAgICBhcHBlbmRUb1N0YWNrKGVsKTtcXG4gICAgdXBkYXRlU3RhdHMoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICB2YXIgZWwgPSBmcmFnbWVudChcXG4gICAgICAnPGxpIGNsYXNzPVxcXCJ0ZXN0IHBhc3MgcGVuZGluZ1xcXCI+PGgyPiVlPC9oMj48L2xpPicsXFxuICAgICAgdGVzdC50aXRsZVxcbiAgICApO1xcbiAgICBhcHBlbmRUb1N0YWNrKGVsKTtcXG4gICAgdXBkYXRlU3RhdHMoKTtcXG4gIH0pO1xcblxcbiAgZnVuY3Rpb24gYXBwZW5kVG9TdGFjayhlbCkge1xcbiAgICAvLyBEb24ndCBjYWxsIC5hcHBlbmRDaGlsZCBpZiAjbW9jaGEtcmVwb3J0IHdhcyBhbHJlYWR5IC5zaGlmdCgpJ2VkIG9mZiB0aGUgc3RhY2suXFxuICAgIGlmIChzdGFja1swXSkge1xcbiAgICAgIHN0YWNrWzBdLmFwcGVuZENoaWxkKGVsKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gdXBkYXRlU3RhdHMoKSB7XFxuICAgIC8vIFRPRE86IGFkZCB0byBzdGF0c1xcbiAgICB2YXIgcGVyY2VudCA9IChzdGF0cy50ZXN0cyAvIHJ1bm5lci50b3RhbCAqIDEwMCkgfCAwO1xcbiAgICBpZiAocHJvZ3Jlc3MpIHtcXG4gICAgICBwcm9ncmVzcy51cGRhdGUocGVyY2VudCkuZHJhdyhjdHgpO1xcbiAgICB9XFxuXFxuICAgIC8vIHVwZGF0ZSBzdGF0c1xcbiAgICB2YXIgbXMgPSBuZXcgRGF0ZSgpIC0gc3RhdHMuc3RhcnQ7XFxuICAgIHRleHQocGFzc2VzLCBzdGF0cy5wYXNzZXMpO1xcbiAgICB0ZXh0KGZhaWx1cmVzLCBzdGF0cy5mYWlsdXJlcyk7XFxuICAgIHRleHQoZHVyYXRpb24sIChtcyAvIDEwMDApLnRvRml4ZWQoMikpO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBNYWtlcyBhIFVSTCwgcHJlc2VydmluZyBxdWVyeXN0cmluZyAoXFxcInNlYXJjaFxcXCIpIHBhcmFtZXRlcnMuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBuZXcgVVJMLlxcbiAqL1xcbmZ1bmN0aW9uIG1ha2VVcmwocykge1xcbiAgdmFyIHNlYXJjaCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XFxuXFxuICAvLyBSZW1vdmUgcHJldmlvdXMgZ3JlcCBxdWVyeSBwYXJhbWV0ZXIgaWYgcHJlc2VudFxcbiAgaWYgKHNlYXJjaCkge1xcbiAgICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgvWz8mXWdyZXA9W14mXFxcXHNdKi9nLCAnJykucmVwbGFjZSgvXiYvLCAnPycpO1xcbiAgfVxcblxcbiAgcmV0dXJuIChcXG4gICAgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICtcXG4gICAgKHNlYXJjaCA/IHNlYXJjaCArICcmJyA6ICc/JykgK1xcbiAgICAnZ3JlcD0nICtcXG4gICAgZW5jb2RlVVJJQ29tcG9uZW50KGVzY2FwZVJlKHMpKVxcbiAgKTtcXG59XFxuXFxuLyoqXFxuICogUHJvdmlkZSBzdWl0ZSBVUkwuXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gW3N1aXRlXVxcbiAqL1xcbkhUTUwucHJvdG90eXBlLnN1aXRlVVJMID0gZnVuY3Rpb24oc3VpdGUpIHtcXG4gIHJldHVybiBtYWtlVXJsKHN1aXRlLmZ1bGxUaXRsZSgpKTtcXG59O1xcblxcbi8qKlxcbiAqIFByb3ZpZGUgdGVzdCBVUkwuXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gW3Rlc3RdXFxuICovXFxuSFRNTC5wcm90b3R5cGUudGVzdFVSTCA9IGZ1bmN0aW9uKHRlc3QpIHtcXG4gIHJldHVybiBtYWtlVXJsKHRlc3QuZnVsbFRpdGxlKCkpO1xcbn07XFxuXFxuLyoqXFxuICogQWRkcyBjb2RlIHRvZ2dsZSBmdW5jdGlvbmFsaXR5IGZvciB0aGUgcHJvdmlkZWQgdGVzdCdzIGxpc3QgZWxlbWVudC5cXG4gKlxcbiAqIEBwYXJhbSB7SFRNTExJRWxlbWVudH0gZWxcXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudHNcXG4gKi9cXG5IVE1MLnByb3RvdHlwZS5hZGRDb2RlVG9nZ2xlID0gZnVuY3Rpb24oZWwsIGNvbnRlbnRzKSB7XFxuICB2YXIgaDIgPSBlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaDInKVswXTtcXG5cXG4gIG9uKGgyLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcXG4gICAgcHJlLnN0eWxlLmRpc3BsYXkgPSBwcmUuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJ2Jsb2NrJyA6ICdub25lJztcXG4gIH0pO1xcblxcbiAgdmFyIHByZSA9IGZyYWdtZW50KCc8cHJlPjxjb2RlPiVlPC9jb2RlPjwvcHJlPicsIHV0aWxzLmNsZWFuKGNvbnRlbnRzKSk7XFxuICBlbC5hcHBlbmRDaGlsZChwcmUpO1xcbiAgcHJlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XFxufTtcXG5cXG4vKipcXG4gKiBEaXNwbGF5IGVycm9yIGBtc2dgLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xcbiAqL1xcbmZ1bmN0aW9uIGVycm9yKG1zZykge1xcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmcmFnbWVudCgnPGRpdiBpZD1cXFwibW9jaGEtZXJyb3JcXFwiPiVzPC9kaXY+JywgbXNnKSk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybiBhIERPTSBmcmFnbWVudCBmcm9tIGBodG1sYC5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXFxuICovXFxuZnVuY3Rpb24gZnJhZ21lbnQoaHRtbCkge1xcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XFxuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICB2YXIgaSA9IDE7XFxuXFxuICBkaXYuaW5uZXJIVE1MID0gaHRtbC5yZXBsYWNlKC8lKFtzZV0pL2csIGZ1bmN0aW9uKF8sIHR5cGUpIHtcXG4gICAgc3dpdGNoICh0eXBlKSB7XFxuICAgICAgY2FzZSAncyc6XFxuICAgICAgICByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XFxuICAgICAgY2FzZSAnZSc6XFxuICAgICAgICByZXR1cm4gZXNjYXBlKGFyZ3NbaSsrXSk7XFxuICAgICAgLy8gbm8gZGVmYXVsdFxcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJldHVybiBkaXYuZmlyc3RDaGlsZDtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2sgZm9yIHN1aXRlcyB0aGF0IGRvIG5vdCBoYXZlIGVsZW1lbnRzXFxuICogd2l0aCBgY2xhc3NuYW1lYCwgYW5kIGhpZGUgdGhlbS5cXG4gKlxcbiAqIEBwYXJhbSB7dGV4dH0gY2xhc3NuYW1lXFxuICovXFxuZnVuY3Rpb24gaGlkZVN1aXRlc1dpdGhvdXQoY2xhc3NuYW1lKSB7XFxuICB2YXIgc3VpdGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc3VpdGUnKTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3VpdGVzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBlbHMgPSBzdWl0ZXNbaV0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc25hbWUpO1xcbiAgICBpZiAoIWVscy5sZW5ndGgpIHtcXG4gICAgICBzdWl0ZXNbaV0uY2xhc3NOYW1lICs9ICcgaGlkZGVuJztcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBVbmhpZGUgLmhpZGRlbiBzdWl0ZXMuXFxuICovXFxuZnVuY3Rpb24gdW5oaWRlKCkge1xcbiAgdmFyIGVscyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3N1aXRlIGhpZGRlbicpO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyArK2kpIHtcXG4gICAgZWxzW2ldLmNsYXNzTmFtZSA9IGVsc1tpXS5jbGFzc05hbWUucmVwbGFjZSgnc3VpdGUgaGlkZGVuJywgJ3N1aXRlJyk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFNldCBhbiBlbGVtZW50J3MgdGV4dCBjb250ZW50cy5cXG4gKlxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRzXFxuICovXFxuZnVuY3Rpb24gdGV4dChlbCwgY29udGVudHMpIHtcXG4gIGlmIChlbC50ZXh0Q29udGVudCkge1xcbiAgICBlbC50ZXh0Q29udGVudCA9IGNvbnRlbnRzO1xcbiAgfSBlbHNlIHtcXG4gICAgZWwuaW5uZXJUZXh0ID0gY29udGVudHM7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIExpc3RlbiBvbiBgZXZlbnRgIHdpdGggY2FsbGJhY2sgYGZuYC5cXG4gKi9cXG5mdW5jdGlvbiBvbihlbCwgZXZlbnQsIGZuKSB7XFxuICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgZmFsc2UpO1xcbiAgfSBlbHNlIHtcXG4gICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmbik7XFxuICB9XFxufVxcblxcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuLi9icm93c2VyL3Byb2dyZXNzXFxcIjozLFxcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTYsXFxcImVzY2FwZS1zdHJpbmctcmVnZXhwXFxcIjo0Nn1dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLy8gQWxpYXMgZXhwb3J0cyB0byBhIHRoZWlyIG5vcm1hbGl6ZWQgZm9ybWF0IE1vY2hhI3JlcG9ydGVyIHRvIHByZXZlbnQgYSBuZWVkXFxuLy8gZm9yIGR5bmFtaWMgKHRyeS9jYXRjaCkgcmVxdWlyZXMsIHdoaWNoIEJyb3dzZXJpZnkgZG9lc24ndCBoYW5kbGUuXFxuZXhwb3J0cy5CYXNlID0gZXhwb3J0cy5iYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxuZXhwb3J0cy5Eb3QgPSBleHBvcnRzLmRvdCA9IHJlcXVpcmUoJy4vZG90Jyk7XFxuZXhwb3J0cy5Eb2MgPSBleHBvcnRzLmRvYyA9IHJlcXVpcmUoJy4vZG9jJyk7XFxuZXhwb3J0cy5UQVAgPSBleHBvcnRzLnRhcCA9IHJlcXVpcmUoJy4vdGFwJyk7XFxuZXhwb3J0cy5KU09OID0gZXhwb3J0cy5qc29uID0gcmVxdWlyZSgnLi9qc29uJyk7XFxuZXhwb3J0cy5IVE1MID0gZXhwb3J0cy5odG1sID0gcmVxdWlyZSgnLi9odG1sJyk7XFxuZXhwb3J0cy5MaXN0ID0gZXhwb3J0cy5saXN0ID0gcmVxdWlyZSgnLi9saXN0Jyk7XFxuZXhwb3J0cy5NaW4gPSBleHBvcnRzLm1pbiA9IHJlcXVpcmUoJy4vbWluJyk7XFxuZXhwb3J0cy5TcGVjID0gZXhwb3J0cy5zcGVjID0gcmVxdWlyZSgnLi9zcGVjJyk7XFxuZXhwb3J0cy5OeWFuID0gZXhwb3J0cy5ueWFuID0gcmVxdWlyZSgnLi9ueWFuJyk7XFxuZXhwb3J0cy5YVW5pdCA9IGV4cG9ydHMueHVuaXQgPSByZXF1aXJlKCcuL3h1bml0Jyk7XFxuZXhwb3J0cy5NYXJrZG93biA9IGV4cG9ydHMubWFya2Rvd24gPSByZXF1aXJlKCcuL21hcmtkb3duJyk7XFxuZXhwb3J0cy5Qcm9ncmVzcyA9IGV4cG9ydHMucHJvZ3Jlc3MgPSByZXF1aXJlKCcuL3Byb2dyZXNzJyk7XFxuZXhwb3J0cy5MYW5kaW5nID0gZXhwb3J0cy5sYW5kaW5nID0gcmVxdWlyZSgnLi9sYW5kaW5nJyk7XFxuZXhwb3J0cy5KU09OU3RyZWFtID0gZXhwb3J0c1snanNvbi1zdHJlYW0nXSA9IHJlcXVpcmUoJy4vanNvbi1zdHJlYW0nKTtcXG5cXG59LHtcXFwiLi9iYXNlXFxcIjoxNixcXFwiLi9kb2NcXFwiOjE3LFxcXCIuL2RvdFxcXCI6MTgsXFxcIi4vaHRtbFxcXCI6MTksXFxcIi4vanNvblxcXCI6MjIsXFxcIi4vanNvbi1zdHJlYW1cXFwiOjIxLFxcXCIuL2xhbmRpbmdcXFwiOjIzLFxcXCIuL2xpc3RcXFwiOjI0LFxcXCIuL21hcmtkb3duXFxcIjoyNSxcXFwiLi9taW5cXFwiOjI2LFxcXCIuL255YW5cXFwiOjI3LFxcXCIuL3Byb2dyZXNzXFxcIjoyOCxcXFwiLi9zcGVjXFxcIjoyOSxcXFwiLi90YXBcXFwiOjMwLFxcXCIuL3h1bml0XFxcIjozMX1dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIEpTT05TdHJlYW1cXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBMaXN0YC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBMaXN0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYEpTT05TdHJlYW1gIHRlc3QgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQG5hbWUgSlNPTlN0cmVhbVxcbiAqIEBjbGFzcyBKU09OU3RyZWFtXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gTGlzdChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRvdGFsID0gcnVubmVyLnRvdGFsO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xcbiAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShbJ3N0YXJ0Jywge3RvdGFsOiB0b3RhbH1dKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoWydwYXNzJywgY2xlYW4odGVzdCldKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uKHRlc3QsIGVycikge1xcbiAgICB0ZXN0ID0gY2xlYW4odGVzdCk7XFxuICAgIHRlc3QuZXJyID0gZXJyLm1lc3NhZ2U7XFxuICAgIHRlc3Quc3RhY2sgPSBlcnIuc3RhY2sgfHwgbnVsbDtcXG4gICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoWydmYWlsJywgdGVzdF0pKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShKU09OLnN0cmluZ2lmeShbJ2VuZCcsIHNlbGYuc3RhdHNdKSk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgcGxhaW4tb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGB0ZXN0YFxcbiAqIGZyZWUgb2YgY3ljbGljIHByb3BlcnRpZXMgZXRjLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IHRlc3RcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuZnVuY3Rpb24gY2xlYW4odGVzdCkge1xcbiAgcmV0dXJuIHtcXG4gICAgdGl0bGU6IHRlc3QudGl0bGUsXFxuICAgIGZ1bGxUaXRsZTogdGVzdC5mdWxsVGl0bGUoKSxcXG4gICAgZHVyYXRpb246IHRlc3QuZHVyYXRpb24sXFxuICAgIGN1cnJlbnRSZXRyeTogdGVzdC5jdXJyZW50UmV0cnkoKVxcbiAgfTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIEpTT05cXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBKU09OYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBKU09OUmVwb3J0ZXI7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgSlNPTmAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGNsYXNzIEpTT05cXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBKU09OUmVwb3J0ZXIocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB0ZXN0cyA9IFtdO1xcbiAgdmFyIHBlbmRpbmcgPSBbXTtcXG4gIHZhciBmYWlsdXJlcyA9IFtdO1xcbiAgdmFyIHBhc3NlcyA9IFtdO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICBwYXNzZXMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICBmYWlsdXJlcy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHBlbmRpbmcucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgb2JqID0ge1xcbiAgICAgIHN0YXRzOiBzZWxmLnN0YXRzLFxcbiAgICAgIHRlc3RzOiB0ZXN0cy5tYXAoY2xlYW4pLFxcbiAgICAgIHBlbmRpbmc6IHBlbmRpbmcubWFwKGNsZWFuKSxcXG4gICAgICBmYWlsdXJlczogZmFpbHVyZXMubWFwKGNsZWFuKSxcXG4gICAgICBwYXNzZXM6IHBhc3Nlcy5tYXAoY2xlYW4pXFxuICAgIH07XFxuXFxuICAgIHJ1bm5lci50ZXN0UmVzdWx0cyA9IG9iajtcXG5cXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKSk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgcGxhaW4tb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGB0ZXN0YFxcbiAqIGZyZWUgb2YgY3ljbGljIHByb3BlcnRpZXMgZXRjLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IHRlc3RcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuZnVuY3Rpb24gY2xlYW4odGVzdCkge1xcbiAgdmFyIGVyciA9IHRlc3QuZXJyIHx8IHt9O1xcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XFxuICAgIGVyciA9IGVycm9ySlNPTihlcnIpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHtcXG4gICAgdGl0bGU6IHRlc3QudGl0bGUsXFxuICAgIGZ1bGxUaXRsZTogdGVzdC5mdWxsVGl0bGUoKSxcXG4gICAgZHVyYXRpb246IHRlc3QuZHVyYXRpb24sXFxuICAgIGN1cnJlbnRSZXRyeTogdGVzdC5jdXJyZW50UmV0cnkoKSxcXG4gICAgZXJyOiBjbGVhbkN5Y2xlcyhlcnIpXFxuICB9O1xcbn1cXG5cXG4vKipcXG4gKiBSZXBsYWNlcyBhbnkgY2lyY3VsYXIgcmVmZXJlbmNlcyBpbnNpZGUgYG9iamAgd2l0aCAnW29iamVjdCBPYmplY3RdJ1xcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxcbiAqIEByZXR1cm4ge09iamVjdH1cXG4gKi9cXG5mdW5jdGlvbiBjbGVhbkN5Y2xlcyhvYmopIHtcXG4gIHZhciBjYWNoZSA9IFtdO1xcbiAgcmV0dXJuIEpTT04ucGFyc2UoXFxuICAgIEpTT04uc3RyaW5naWZ5KG9iaiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XFxuICAgICAgICBpZiAoY2FjaGUuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XFxuICAgICAgICAgIC8vIEluc3RlYWQgb2YgZ29pbmcgaW4gYSBjaXJjbGUsIHdlJ2xsIHByaW50IFtvYmplY3QgT2JqZWN0XVxcbiAgICAgICAgICByZXR1cm4gJycgKyB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNhY2hlLnB1c2godmFsdWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdmFsdWU7XFxuICAgIH0pXFxuICApO1xcbn1cXG5cXG4vKipcXG4gKiBUcmFuc2Zvcm0gYW4gRXJyb3Igb2JqZWN0IGludG8gYSBKU09OIG9iamVjdC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqIEByZXR1cm4ge09iamVjdH1cXG4gKi9cXG5mdW5jdGlvbiBlcnJvckpTT04oZXJyKSB7XFxuICB2YXIgcmVzID0ge307XFxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlcnIpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XFxuICAgIHJlc1trZXldID0gZXJyW2tleV07XFxuICB9LCBlcnIpO1xcbiAgcmV0dXJuIHJlcztcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIExhbmRpbmdcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY3Vyc29yID0gQmFzZS5jdXJzb3I7XFxudmFyIGNvbG9yID0gQmFzZS5jb2xvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYExhbmRpbmdgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IExhbmRpbmc7XFxuXFxuLyoqXFxuICogQWlycGxhbmUgY29sb3IuXFxuICovXFxuXFxuQmFzZS5jb2xvcnMucGxhbmUgPSAwO1xcblxcbi8qKlxcbiAqIEFpcnBsYW5lIGNyYXNoIGNvbG9yLlxcbiAqL1xcblxcbkJhc2UuY29sb3JzWydwbGFuZSBjcmFzaCddID0gMzE7XFxuXFxuLyoqXFxuICogUnVud2F5IGNvbG9yLlxcbiAqL1xcblxcbkJhc2UuY29sb3JzLnJ1bndheSA9IDkwO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYExhbmRpbmdgIHJlcG9ydGVyLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIExhbmRpbmcocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB3aWR0aCA9IChCYXNlLndpbmRvdy53aWR0aCAqIDAuNzUpIHwgMDtcXG4gIHZhciB0b3RhbCA9IHJ1bm5lci50b3RhbDtcXG4gIHZhciBzdHJlYW0gPSBwcm9jZXNzLnN0ZG91dDtcXG4gIHZhciBwbGFuZSA9IGNvbG9yKCdwbGFuZScsICfinIgnKTtcXG4gIHZhciBjcmFzaGVkID0gLTE7XFxuICB2YXIgbiA9IDA7XFxuXFxuICBmdW5jdGlvbiBydW53YXkoKSB7XFxuICAgIHZhciBidWYgPSBBcnJheSh3aWR0aCkuam9pbignLScpO1xcbiAgICByZXR1cm4gJyAgJyArIGNvbG9yKCdydW53YXknLCBidWYpO1xcbiAgfVxcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xcbiAgICBzdHJlYW0ud3JpdGUoJ1xcXFxuXFxcXG5cXFxcbiAgJyk7XFxuICAgIGN1cnNvci5oaWRlKCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIC8vIGNoZWNrIGlmIHRoZSBwbGFuZSBjcmFzaGVkXFxuICAgIHZhciBjb2wgPSBjcmFzaGVkID09PSAtMSA/ICh3aWR0aCAqICsrbiAvIHRvdGFsKSB8IDAgOiBjcmFzaGVkO1xcblxcbiAgICAvLyBzaG93IHRoZSBjcmFzaFxcbiAgICBpZiAodGVzdC5zdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcXG4gICAgICBwbGFuZSA9IGNvbG9yKCdwbGFuZSBjcmFzaCcsICfinIgnKTtcXG4gICAgICBjcmFzaGVkID0gY29sO1xcbiAgICB9XFxuXFxuICAgIC8vIHJlbmRlciBsYW5kaW5nIHN0cmlwXFxuICAgIHN0cmVhbS53cml0ZSgnXFxcXHUwMDFiWycgKyAod2lkdGggKyAxKSArICdEXFxcXHUwMDFiWzJBJyk7XFxuICAgIHN0cmVhbS53cml0ZShydW53YXkoKSk7XFxuICAgIHN0cmVhbS53cml0ZSgnXFxcXG4gICcpO1xcbiAgICBzdHJlYW0ud3JpdGUoY29sb3IoJ3J1bndheScsIEFycmF5KGNvbCkuam9pbign4ouFJykpKTtcXG4gICAgc3RyZWFtLndyaXRlKHBsYW5lKTtcXG4gICAgc3RyZWFtLndyaXRlKGNvbG9yKCdydW53YXknLCBBcnJheSh3aWR0aCAtIGNvbCkuam9pbign4ouFJykgKyAnXFxcXG4nKSk7XFxuICAgIHN0cmVhbS53cml0ZShydW53YXkoKSk7XFxuICAgIHN0cmVhbS53cml0ZSgnXFxcXHUwMDFiWzBtJyk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgY3Vyc29yLnNob3coKTtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gICAgc2VsZi5lcGlsb2d1ZSgpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKExhbmRpbmcsIEJhc2UpO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIExpc3RcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYExpc3RgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IExpc3Q7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTGlzdGAgdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBMaXN0KHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgbiA9IDA7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24oKSB7XFxuICAgIGNvbnNvbGUubG9nKCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCcsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Bhc3MnLCAnICAgICcgKyB0ZXN0LmZ1bGxUaXRsZSgpICsgJzogJykpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHZhciBmbXQgPSBjb2xvcignY2hlY2ttYXJrJywgJyAgLScpICsgY29sb3IoJ3BlbmRpbmcnLCAnICVzJyk7XFxuICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC5mdWxsVGl0bGUoKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgdmFyIGZtdCA9XFxuICAgICAgY29sb3IoJ2NoZWNrbWFyaycsICcgICcgKyBCYXNlLnN5bWJvbHMub2spICtcXG4gICAgICBjb2xvcigncGFzcycsICcgJXM6ICcpICtcXG4gICAgICBjb2xvcih0ZXN0LnNwZWVkLCAnJWRtcycpO1xcbiAgICBjdXJzb3IuQ1IoKTtcXG4gICAgY29uc29sZS5sb2coZm10LCB0ZXN0LmZ1bGxUaXRsZSgpLCB0ZXN0LmR1cmF0aW9uKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICBjdXJzb3IuQ1IoKTtcXG4gICAgY29uc29sZS5sb2coY29sb3IoJ2ZhaWwnLCAnICAlZCkgJXMnKSwgKytuLCB0ZXN0LmZ1bGxUaXRsZSgpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIHNlbGYuZXBpbG9ndWUuYmluZChzZWxmKSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKExpc3QsIEJhc2UpO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIE1hcmtkb3duXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XFxuXFxuLyoqXFxuICogQ29uc3RhbnRzXFxuICovXFxuXFxudmFyIFNVSVRFX1BSRUZJWCA9ICckJztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYE1hcmtkb3duYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNYXJrZG93bjtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBNYXJrZG93bmAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gTWFya2Rvd24ocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBsZXZlbCA9IDA7XFxuICB2YXIgYnVmID0gJyc7XFxuXFxuICBmdW5jdGlvbiB0aXRsZShzdHIpIHtcXG4gICAgcmV0dXJuIEFycmF5KGxldmVsKS5qb2luKCcjJykgKyAnICcgKyBzdHI7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBtYXBUT0Moc3VpdGUsIG9iaikge1xcbiAgICB2YXIgcmV0ID0gb2JqO1xcbiAgICB2YXIga2V5ID0gU1VJVEVfUFJFRklYICsgc3VpdGUudGl0bGU7XFxuXFxuICAgIG9iaiA9IG9ialtrZXldID0gb2JqW2tleV0gfHwge3N1aXRlOiBzdWl0ZX07XFxuICAgIHN1aXRlLnN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uKHN1aXRlKSB7XFxuICAgICAgbWFwVE9DKHN1aXRlLCBvYmopO1xcbiAgICB9KTtcXG5cXG4gICAgcmV0dXJuIHJldDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeVRPQyhvYmosIGxldmVsKSB7XFxuICAgICsrbGV2ZWw7XFxuICAgIHZhciBidWYgPSAnJztcXG4gICAgdmFyIGxpbms7XFxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcXG4gICAgICBpZiAoa2V5ID09PSAnc3VpdGUnKSB7XFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9XFxuICAgICAgaWYgKGtleSAhPT0gU1VJVEVfUFJFRklYKSB7XFxuICAgICAgICBsaW5rID0gJyAtIFsnICsga2V5LnN1YnN0cmluZygxKSArICddJztcXG4gICAgICAgIGxpbmsgKz0gJygjJyArIHV0aWxzLnNsdWcob2JqW2tleV0uc3VpdGUuZnVsbFRpdGxlKCkpICsgJylcXFxcbic7XFxuICAgICAgICBidWYgKz0gQXJyYXkobGV2ZWwpLmpvaW4oJyAgJykgKyBsaW5rO1xcbiAgICAgIH1cXG4gICAgICBidWYgKz0gc3RyaW5naWZ5VE9DKG9ialtrZXldLCBsZXZlbCk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGJ1ZjtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdlbmVyYXRlVE9DKHN1aXRlKSB7XFxuICAgIHZhciBvYmogPSBtYXBUT0Moc3VpdGUsIHt9KTtcXG4gICAgcmV0dXJuIHN0cmluZ2lmeVRPQyhvYmosIDApO1xcbiAgfVxcblxcbiAgZ2VuZXJhdGVUT0MocnVubmVyLnN1aXRlKTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUnLCBmdW5jdGlvbihzdWl0ZSkge1xcbiAgICArK2xldmVsO1xcbiAgICB2YXIgc2x1ZyA9IHV0aWxzLnNsdWcoc3VpdGUuZnVsbFRpdGxlKCkpO1xcbiAgICBidWYgKz0gJzxhIG5hbWU9XFxcIicgKyBzbHVnICsgJ1xcXCI+PC9hPicgKyAnXFxcXG4nO1xcbiAgICBidWYgKz0gdGl0bGUoc3VpdGUudGl0bGUpICsgJ1xcXFxuJztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZSBlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgLS1sZXZlbDtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICB2YXIgY29kZSA9IHV0aWxzLmNsZWFuKHRlc3QuYm9keSk7XFxuICAgIGJ1ZiArPSB0ZXN0LnRpdGxlICsgJy5cXFxcbic7XFxuICAgIGJ1ZiArPSAnXFxcXG5gYGBqc1xcXFxuJztcXG4gICAgYnVmICs9IGNvZGUgKyAnXFxcXG4nO1xcbiAgICBidWYgKz0gJ2BgYFxcXFxuXFxcXG4nO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCcjIFRPQ1xcXFxuJyk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGdlbmVyYXRlVE9DKHJ1bm5lci5zdWl0ZSkpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShidWYpO1xcbiAgfSk7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIE1pblxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgTWluYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNaW47XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTWluYCBtaW5pbWFsIHRlc3QgcmVwb3J0ZXIgKGJlc3QgdXNlZCB3aXRoIC0td2F0Y2gpLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIE1pbihydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xcbiAgICAvLyBjbGVhciBzY3JlZW5cXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYlsySicpO1xcbiAgICAvLyBzZXQgY3Vyc29yIHBvc2l0aW9uXFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbMTszSCcpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgdGhpcy5lcGlsb2d1ZS5iaW5kKHRoaXMpKTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoTWluLCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM2LFxcXCIuL2Jhc2VcXFwiOjE2LFxcXCJfcHJvY2Vzc1xcXCI6NTZ9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBOeWFuXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBEb3RgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE55YW5DYXQ7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRG90YCBtYXRyaXggdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3MgTnlhblxcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqL1xcblxcbmZ1bmN0aW9uIE55YW5DYXQocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB3aWR0aCA9IChCYXNlLndpbmRvdy53aWR0aCAqIDAuNzUpIHwgMDtcXG4gIHZhciBueWFuQ2F0V2lkdGggPSAodGhpcy5ueWFuQ2F0V2lkdGggPSAxMSk7XFxuXFxuICB0aGlzLmNvbG9ySW5kZXggPSAwO1xcbiAgdGhpcy5udW1iZXJPZkxpbmVzID0gNDtcXG4gIHRoaXMucmFpbmJvd0NvbG9ycyA9IHNlbGYuZ2VuZXJhdGVDb2xvcnMoKTtcXG4gIHRoaXMuc2NvcmVib2FyZFdpZHRoID0gNTtcXG4gIHRoaXMudGljayA9IDA7XFxuICB0aGlzLnRyYWplY3RvcmllcyA9IFtbXSwgW10sIFtdLCBbXV07XFxuICB0aGlzLnRyYWplY3RvcnlXaWR0aE1heCA9IHdpZHRoIC0gbnlhbkNhdFdpZHRoO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xcbiAgICBCYXNlLmN1cnNvci5oaWRlKCk7XFxuICAgIHNlbGYuZHJhdygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbigpIHtcXG4gICAgc2VsZi5kcmF3KCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uKCkge1xcbiAgICBzZWxmLmRyYXcoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24oKSB7XFxuICAgIHNlbGYuZHJhdygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgIEJhc2UuY3Vyc29yLnNob3coKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLm51bWJlck9mTGluZXM7IGkrKykge1xcbiAgICAgIHdyaXRlKCdcXFxcbicpO1xcbiAgICB9XFxuICAgIHNlbGYuZXBpbG9ndWUoKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhOeWFuQ2F0LCBCYXNlKTtcXG5cXG4vKipcXG4gKiBEcmF3IHRoZSBueWFuIGNhdFxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5hcHBlbmRSYWluYm93KCk7XFxuICB0aGlzLmRyYXdTY29yZWJvYXJkKCk7XFxuICB0aGlzLmRyYXdSYWluYm93KCk7XFxuICB0aGlzLmRyYXdOeWFuQ2F0KCk7XFxuICB0aGlzLnRpY2sgPSAhdGhpcy50aWNrO1xcbn07XFxuXFxuLyoqXFxuICogRHJhdyB0aGUgXFxcInNjb3JlYm9hcmRcXFwiIHNob3dpbmcgdGhlIG51bWJlclxcbiAqIG9mIHBhc3NlcywgZmFpbHVyZXMgYW5kIHBlbmRpbmcgdGVzdHMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3U2NvcmVib2FyZCA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG5cXG4gIGZ1bmN0aW9uIGRyYXcodHlwZSwgbikge1xcbiAgICB3cml0ZSgnICcpO1xcbiAgICB3cml0ZShCYXNlLmNvbG9yKHR5cGUsIG4pKTtcXG4gICAgd3JpdGUoJ1xcXFxuJyk7XFxuICB9XFxuXFxuICBkcmF3KCdncmVlbicsIHN0YXRzLnBhc3Nlcyk7XFxuICBkcmF3KCdmYWlsJywgc3RhdHMuZmFpbHVyZXMpO1xcbiAgZHJhdygncGVuZGluZycsIHN0YXRzLnBlbmRpbmcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB0aGlzLmN1cnNvclVwKHRoaXMubnVtYmVyT2ZMaW5lcyk7XFxufTtcXG5cXG4vKipcXG4gKiBBcHBlbmQgdGhlIHJhaW5ib3cuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5hcHBlbmRSYWluYm93ID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgc2VnbWVudCA9IHRoaXMudGljayA/ICdfJyA6ICctJztcXG4gIHZhciByYWluYm93aWZpZWQgPSB0aGlzLnJhaW5ib3dpZnkoc2VnbWVudCk7XFxuXFxuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5udW1iZXJPZkxpbmVzOyBpbmRleCsrKSB7XFxuICAgIHZhciB0cmFqZWN0b3J5ID0gdGhpcy50cmFqZWN0b3JpZXNbaW5kZXhdO1xcbiAgICBpZiAodHJhamVjdG9yeS5sZW5ndGggPj0gdGhpcy50cmFqZWN0b3J5V2lkdGhNYXgpIHtcXG4gICAgICB0cmFqZWN0b3J5LnNoaWZ0KCk7XFxuICAgIH1cXG4gICAgdHJhamVjdG9yeS5wdXNoKHJhaW5ib3dpZmllZCk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBEcmF3IHRoZSByYWluYm93LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuZHJhd1JhaW5ib3cgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG5cXG4gIHRoaXMudHJhamVjdG9yaWVzLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xcbiAgICB3cml0ZSgnXFxcXHUwMDFiWycgKyBzZWxmLnNjb3JlYm9hcmRXaWR0aCArICdDJyk7XFxuICAgIHdyaXRlKGxpbmUuam9pbignJykpO1xcbiAgICB3cml0ZSgnXFxcXG4nKTtcXG4gIH0pO1xcblxcbiAgdGhpcy5jdXJzb3JVcCh0aGlzLm51bWJlck9mTGluZXMpO1xcbn07XFxuXFxuLyoqXFxuICogRHJhdyB0aGUgbnlhbiBjYXRcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbk55YW5DYXQucHJvdG90eXBlLmRyYXdOeWFuQ2F0ID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgc3RhcnRXaWR0aCA9IHRoaXMuc2NvcmVib2FyZFdpZHRoICsgdGhpcy50cmFqZWN0b3JpZXNbMF0ubGVuZ3RoO1xcbiAgdmFyIGRpc3QgPSAnXFxcXHUwMDFiWycgKyBzdGFydFdpZHRoICsgJ0MnO1xcbiAgdmFyIHBhZGRpbmcgPSAnJztcXG5cXG4gIHdyaXRlKGRpc3QpO1xcbiAgd3JpdGUoJ18sLS0tLS0tLCcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB3cml0ZShkaXN0KTtcXG4gIHBhZGRpbmcgPSBzZWxmLnRpY2sgPyAnICAnIDogJyAgICc7XFxuICB3cml0ZSgnX3wnICsgcGFkZGluZyArICcvXFxcXFxcXFxfL1xcXFxcXFxcICcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB3cml0ZShkaXN0KTtcXG4gIHBhZGRpbmcgPSBzZWxmLnRpY2sgPyAnXycgOiAnX18nO1xcbiAgdmFyIHRhaWwgPSBzZWxmLnRpY2sgPyAnficgOiAnXic7XFxuICB3cml0ZSh0YWlsICsgJ3wnICsgcGFkZGluZyArIHRoaXMuZmFjZSgpICsgJyAnKTtcXG4gIHdyaXRlKCdcXFxcbicpO1xcblxcbiAgd3JpdGUoZGlzdCk7XFxuICBwYWRkaW5nID0gc2VsZi50aWNrID8gJyAnIDogJyAgJztcXG4gIHdyaXRlKHBhZGRpbmcgKyAnXFxcIlxcXCIgIFxcXCJcXFwiICcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB0aGlzLmN1cnNvclVwKHRoaXMubnVtYmVyT2ZMaW5lcyk7XFxufTtcXG5cXG4vKipcXG4gKiBEcmF3IG55YW4gY2F0IGZhY2UuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuZmFjZSA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG4gIGlmIChzdGF0cy5mYWlsdXJlcykge1xcbiAgICByZXR1cm4gJyggeCAueCknO1xcbiAgfSBlbHNlIGlmIChzdGF0cy5wZW5kaW5nKSB7XFxuICAgIHJldHVybiAnKCBvIC5vKSc7XFxuICB9IGVsc2UgaWYgKHN0YXRzLnBhc3Nlcykge1xcbiAgICByZXR1cm4gJyggXiAuXiknO1xcbiAgfVxcbiAgcmV0dXJuICcoIC0gLi0pJztcXG59O1xcblxcbi8qKlxcbiAqIE1vdmUgY3Vyc29yIHVwIGBuYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuY3Vyc29yVXAgPSBmdW5jdGlvbihuKSB7XFxuICB3cml0ZSgnXFxcXHUwMDFiWycgKyBuICsgJ0EnKTtcXG59O1xcblxcbi8qKlxcbiAqIE1vdmUgY3Vyc29yIGRvd24gYG5gLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5jdXJzb3JEb3duID0gZnVuY3Rpb24obikge1xcbiAgd3JpdGUoJ1xcXFx1MDAxYlsnICsgbiArICdCJyk7XFxufTtcXG5cXG4vKipcXG4gKiBHZW5lcmF0ZSByYWluYm93IGNvbG9ycy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqL1xcbk55YW5DYXQucHJvdG90eXBlLmdlbmVyYXRlQ29sb3JzID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgY29sb3JzID0gW107XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IDYgKiA3OyBpKyspIHtcXG4gICAgdmFyIHBpMyA9IE1hdGguZmxvb3IoTWF0aC5QSSAvIDMpO1xcbiAgICB2YXIgbiA9IGkgKiAoMS4wIC8gNik7XFxuICAgIHZhciByID0gTWF0aC5mbG9vcigzICogTWF0aC5zaW4obikgKyAzKTtcXG4gICAgdmFyIGcgPSBNYXRoLmZsb29yKDMgKiBNYXRoLnNpbihuICsgMiAqIHBpMykgKyAzKTtcXG4gICAgdmFyIGIgPSBNYXRoLmZsb29yKDMgKiBNYXRoLnNpbihuICsgNCAqIHBpMykgKyAzKTtcXG4gICAgY29sb3JzLnB1c2goMzYgKiByICsgNiAqIGcgKyBiICsgMTYpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGNvbG9ycztcXG59O1xcblxcbi8qKlxcbiAqIEFwcGx5IHJhaW5ib3cgdG8gdGhlIGdpdmVuIGBzdHJgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5OeWFuQ2F0LnByb3RvdHlwZS5yYWluYm93aWZ5ID0gZnVuY3Rpb24oc3RyKSB7XFxuICBpZiAoIUJhc2UudXNlQ29sb3JzKSB7XFxuICAgIHJldHVybiBzdHI7XFxuICB9XFxuICB2YXIgY29sb3IgPSB0aGlzLnJhaW5ib3dDb2xvcnNbdGhpcy5jb2xvckluZGV4ICUgdGhpcy5yYWluYm93Q29sb3JzLmxlbmd0aF07XFxuICB0aGlzLmNvbG9ySW5kZXggKz0gMTtcXG4gIHJldHVybiAnXFxcXHUwMDFiWzM4OzU7JyArIGNvbG9yICsgJ20nICsgc3RyICsgJ1xcXFx1MDAxYlswbSc7XFxufTtcXG5cXG4vKipcXG4gKiBTdGRvdXQgaGVscGVyLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBBIG1lc3NhZ2UgdG8gd3JpdGUgdG8gc3Rkb3V0LlxcbiAqL1xcbmZ1bmN0aW9uIHdyaXRlKHN0cmluZykge1xcbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoc3RyaW5nKTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozNixcXFwiLi9iYXNlXFxcIjoxNixcXFwiX3Byb2Nlc3NcXFwiOjU2fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgUHJvZ3Jlc3NcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFByb2dyZXNzYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBQcm9ncmVzcztcXG5cXG4vKipcXG4gKiBHZW5lcmFsIHByb2dyZXNzIGJhciBjb2xvci5cXG4gKi9cXG5cXG5CYXNlLmNvbG9ycy5wcm9ncmVzcyA9IDkwO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFByb2dyZXNzYCBiYXIgdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xcbiAqL1xcbmZ1bmN0aW9uIFByb2dyZXNzKHJ1bm5lciwgb3B0aW9ucykge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgd2lkdGggPSAoQmFzZS53aW5kb3cud2lkdGggKiAwLjUpIHwgMDtcXG4gIHZhciB0b3RhbCA9IHJ1bm5lci50b3RhbDtcXG4gIHZhciBjb21wbGV0ZSA9IDA7XFxuICB2YXIgbGFzdE4gPSAtMTtcXG5cXG4gIC8vIGRlZmF1bHQgY2hhcnNcXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcbiAgdmFyIHJlcG9ydGVyT3B0aW9ucyA9IG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zIHx8IHt9O1xcblxcbiAgb3B0aW9ucy5vcGVuID0gcmVwb3J0ZXJPcHRpb25zLm9wZW4gfHwgJ1snO1xcbiAgb3B0aW9ucy5jb21wbGV0ZSA9IHJlcG9ydGVyT3B0aW9ucy5jb21wbGV0ZSB8fCAn4pasJztcXG4gIG9wdGlvbnMuaW5jb21wbGV0ZSA9IHJlcG9ydGVyT3B0aW9ucy5pbmNvbXBsZXRlIHx8IEJhc2Uuc3ltYm9scy5kb3Q7XFxuICBvcHRpb25zLmNsb3NlID0gcmVwb3J0ZXJPcHRpb25zLmNsb3NlIHx8ICddJztcXG4gIG9wdGlvbnMudmVyYm9zZSA9IHJlcG9ydGVyT3B0aW9ucy52ZXJib3NlIHx8IGZhbHNlO1xcblxcbiAgLy8gdGVzdHMgc3RhcnRlZFxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgICBjdXJzb3IuaGlkZSgpO1xcbiAgfSk7XFxuXFxuICAvLyB0ZXN0cyBjb21wbGV0ZVxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBjb21wbGV0ZSsrO1xcblxcbiAgICB2YXIgcGVyY2VudCA9IGNvbXBsZXRlIC8gdG90YWw7XFxuICAgIHZhciBuID0gKHdpZHRoICogcGVyY2VudCkgfCAwO1xcbiAgICB2YXIgaSA9IHdpZHRoIC0gbjtcXG5cXG4gICAgaWYgKG4gPT09IGxhc3ROICYmICFvcHRpb25zLnZlcmJvc2UpIHtcXG4gICAgICAvLyBEb24ndCByZS1yZW5kZXIgdGhlIGxpbmUgaWYgaXQgaGFzbid0IGNoYW5nZWRcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgbGFzdE4gPSBuO1xcblxcbiAgICBjdXJzb3IuQ1IoKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYltKJyk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwcm9ncmVzcycsICcgICcgKyBvcHRpb25zLm9wZW4pKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoQXJyYXkobikuam9pbihvcHRpb25zLmNvbXBsZXRlKSk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEFycmF5KGkpLmpvaW4ob3B0aW9ucy5pbmNvbXBsZXRlKSk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwcm9ncmVzcycsIG9wdGlvbnMuY2xvc2UpKTtcXG4gICAgaWYgKG9wdGlvbnMudmVyYm9zZSkge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwcm9ncmVzcycsICcgJyArIGNvbXBsZXRlICsgJyBvZiAnICsgdG90YWwpKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyB0ZXN0cyBhcmUgY29tcGxldGUsIG91dHB1dCBzb21lIHN0YXRzXFxuICAvLyBhbmQgdGhlIGZhaWx1cmVzIGlmIGFueVxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBjdXJzb3Iuc2hvdygpO1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgICBzZWxmLmVwaWxvZ3VlKCk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoUHJvZ3Jlc3MsIEJhc2UpO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBTcGVjXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XFxudmFyIGNvbG9yID0gQmFzZS5jb2xvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFNwZWNgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFNwZWM7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgU3BlY2AgdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBTcGVjKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgaW5kZW50cyA9IDA7XFxuICB2YXIgbiA9IDA7XFxuXFxuICBmdW5jdGlvbiBpbmRlbnQoKSB7XFxuICAgIHJldHVybiBBcnJheShpbmRlbnRzKS5qb2luKCcgICcpO1xcbiAgfVxcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlJywgZnVuY3Rpb24oc3VpdGUpIHtcXG4gICAgKytpbmRlbnRzO1xcbiAgICBjb25zb2xlLmxvZyhjb2xvcignc3VpdGUnLCAnJXMlcycpLCBpbmRlbnQoKSwgc3VpdGUudGl0bGUpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlIGVuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICAtLWluZGVudHM7XFxuICAgIGlmIChpbmRlbnRzID09PSAxKSB7XFxuICAgICAgY29uc29sZS5sb2coKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHZhciBmbXQgPSBpbmRlbnQoKSArIGNvbG9yKCdwZW5kaW5nJywgJyAgLSAlcycpO1xcbiAgICBjb25zb2xlLmxvZyhmbXQsIHRlc3QudGl0bGUpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHZhciBmbXQ7XFxuICAgIGlmICh0ZXN0LnNwZWVkID09PSAnZmFzdCcpIHtcXG4gICAgICBmbXQgPVxcbiAgICAgICAgaW5kZW50KCkgK1xcbiAgICAgICAgY29sb3IoJ2NoZWNrbWFyaycsICcgICcgKyBCYXNlLnN5bWJvbHMub2spICtcXG4gICAgICAgIGNvbG9yKCdwYXNzJywgJyAlcycpO1xcbiAgICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC50aXRsZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm10ID1cXG4gICAgICAgIGluZGVudCgpICtcXG4gICAgICAgIGNvbG9yKCdjaGVja21hcmsnLCAnICAnICsgQmFzZS5zeW1ib2xzLm9rKSArXFxuICAgICAgICBjb2xvcigncGFzcycsICcgJXMnKSArXFxuICAgICAgICBjb2xvcih0ZXN0LnNwZWVkLCAnICglZG1zKScpO1xcbiAgICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC50aXRsZSwgdGVzdC5kdXJhdGlvbik7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICBjb25zb2xlLmxvZyhpbmRlbnQoKSArIGNvbG9yKCdmYWlsJywgJyAgJWQpICVzJyksICsrbiwgdGVzdC50aXRsZSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCBzZWxmLmVwaWxvZ3VlLmJpbmQoc2VsZikpO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhTcGVjLCBCYXNlKTtcXG5cXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM2LFxcXCIuL2Jhc2VcXFwiOjE2fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIFRBUFxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFRBUGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVEFQO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFRBUGAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gVEFQKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgbiA9IDE7XFxuICB2YXIgcGFzc2VzID0gMDtcXG4gIHZhciBmYWlsdXJlcyA9IDA7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24oKSB7XFxuICAgIHZhciB0b3RhbCA9IHJ1bm5lci5ncmVwVG90YWwocnVubmVyLnN1aXRlKTtcXG4gICAgY29uc29sZS5sb2coJyVkLi4lZCcsIDEsIHRvdGFsKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICArK247XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgY29uc29sZS5sb2coJ29rICVkICVzICMgU0tJUCAtJywgbiwgdGl0bGUodGVzdCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHBhc3NlcysrO1xcbiAgICBjb25zb2xlLmxvZygnb2sgJWQgJXMnLCBuLCB0aXRsZSh0ZXN0KSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uKHRlc3QsIGVycikge1xcbiAgICBmYWlsdXJlcysrO1xcbiAgICBjb25zb2xlLmxvZygnbm90IG9rICVkICVzJywgbiwgdGl0bGUodGVzdCkpO1xcbiAgICBpZiAoZXJyLnN0YWNrKSB7XFxuICAgICAgY29uc29sZS5sb2coZXJyLnN0YWNrLnJlcGxhY2UoL14vZ20sICcgICcpKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgIGNvbnNvbGUubG9nKCcjIHRlc3RzICcgKyAocGFzc2VzICsgZmFpbHVyZXMpKTtcXG4gICAgY29uc29sZS5sb2coJyMgcGFzcyAnICsgcGFzc2VzKTtcXG4gICAgY29uc29sZS5sb2coJyMgZmFpbCAnICsgZmFpbHVyZXMpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybiBhIFRBUC1zYWZlIHRpdGxlIG9mIGB0ZXN0YFxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IHRlc3RcXG4gKiBAcmV0dXJuIHtTdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gdGl0bGUodGVzdCkge1xcbiAgcmV0dXJuIHRlc3QuZnVsbFRpdGxlKCkucmVwbGFjZSgvIy9nLCAnJyk7XFxufVxcblxcbn0se1xcXCIuL2Jhc2VcXFwiOjE2fV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIFhVbml0XFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XFxudmFyIGluaGVyaXRzID0gdXRpbHMuaW5oZXJpdHM7XFxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcXG52YXIgZXNjYXBlID0gdXRpbHMuZXNjYXBlO1xcbnZhciBta2RpcnAgPSByZXF1aXJlKCdta2RpcnAnKTtcXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcXG5cXG4vKipcXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcgKHNlZSBHSC0yMzcpLlxcbiAqL1xcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XFxudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XFxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxuXFxuLyoqXFxuICogRXhwb3NlIGBYVW5pdGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gWFVuaXQ7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgWFVuaXRgIHJlcG9ydGVyLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIFhVbml0KHJ1bm5lciwgb3B0aW9ucykge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xcbiAgdmFyIHRlc3RzID0gW107XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAvLyB0aGUgbmFtZSBvZiB0aGUgdGVzdCBzdWl0ZSwgYXMgaXQgd2lsbCBhcHBlYXIgaW4gdGhlIHJlc3VsdGluZyBYTUwgZmlsZVxcbiAgdmFyIHN1aXRlTmFtZTtcXG5cXG4gIC8vIHRoZSBkZWZhdWx0IG5hbWUgb2YgdGhlIHRlc3Qgc3VpdGUgaWYgbm9uZSBpcyBwcm92aWRlZFxcbiAgdmFyIERFRkFVTFRfU1VJVEVfTkFNRSA9ICdNb2NoYSBUZXN0cyc7XFxuXFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucykge1xcbiAgICBpZiAob3B0aW9ucy5yZXBvcnRlck9wdGlvbnMub3V0cHV0KSB7XFxuICAgICAgaWYgKCFmcy5jcmVhdGVXcml0ZVN0cmVhbSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlIG91dHB1dCBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcXG4gICAgICB9XFxuXFxuICAgICAgbWtkaXJwLnN5bmMocGF0aC5kaXJuYW1lKG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zLm91dHB1dCkpO1xcbiAgICAgIHNlbGYuZmlsZVN0cmVhbSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zLm91dHB1dCk7XFxuICAgIH1cXG5cXG4gICAgLy8gZ2V0IHRoZSBzdWl0ZSBuYW1lIGZyb20gdGhlIHJlcG9ydGVyIG9wdGlvbnMgKGlmIHByb3ZpZGVkKVxcbiAgICBzdWl0ZU5hbWUgPSBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5zdWl0ZU5hbWU7XFxuICB9XFxuXFxuICAvLyBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgc3VpdGUgbmFtZVxcbiAgc3VpdGVOYW1lID0gc3VpdGVOYW1lIHx8IERFRkFVTFRfU1VJVEVfTkFNRTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICB0ZXN0cy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHRlc3RzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgc2VsZi53cml0ZShcXG4gICAgICB0YWcoXFxuICAgICAgICAndGVzdHN1aXRlJyxcXG4gICAgICAgIHtcXG4gICAgICAgICAgbmFtZTogc3VpdGVOYW1lLFxcbiAgICAgICAgICB0ZXN0czogc3RhdHMudGVzdHMsXFxuICAgICAgICAgIGZhaWx1cmVzOiBzdGF0cy5mYWlsdXJlcyxcXG4gICAgICAgICAgZXJyb3JzOiBzdGF0cy5mYWlsdXJlcyxcXG4gICAgICAgICAgc2tpcHBlZDogc3RhdHMudGVzdHMgLSBzdGF0cy5mYWlsdXJlcyAtIHN0YXRzLnBhc3NlcyxcXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvVVRDU3RyaW5nKCksXFxuICAgICAgICAgIHRpbWU6IHN0YXRzLmR1cmF0aW9uIC8gMTAwMCB8fCAwXFxuICAgICAgICB9LFxcbiAgICAgICAgZmFsc2VcXG4gICAgICApXFxuICAgICk7XFxuXFxuICAgIHRlc3RzLmZvckVhY2goZnVuY3Rpb24odCkge1xcbiAgICAgIHNlbGYudGVzdCh0KTtcXG4gICAgfSk7XFxuXFxuICAgIHNlbGYud3JpdGUoJzwvdGVzdHN1aXRlPicpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKFhVbml0LCBCYXNlKTtcXG5cXG4vKipcXG4gKiBPdmVycmlkZSBkb25lIHRvIGNsb3NlIHRoZSBzdHJlYW0gKGlmIGl0J3MgYSBmaWxlKS5cXG4gKlxcbiAqIEBwYXJhbSBmYWlsdXJlc1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuWFVuaXQucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbihmYWlsdXJlcywgZm4pIHtcXG4gIGlmICh0aGlzLmZpbGVTdHJlYW0pIHtcXG4gICAgdGhpcy5maWxlU3RyZWFtLmVuZChmdW5jdGlvbigpIHtcXG4gICAgICBmbihmYWlsdXJlcyk7XFxuICAgIH0pO1xcbiAgfSBlbHNlIHtcXG4gICAgZm4oZmFpbHVyZXMpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogV3JpdGUgb3V0IHRoZSBnaXZlbiBsaW5lLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IGxpbmVcXG4gKi9cXG5YVW5pdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihsaW5lKSB7XFxuICBpZiAodGhpcy5maWxlU3RyZWFtKSB7XFxuICAgIHRoaXMuZmlsZVN0cmVhbS53cml0ZShsaW5lICsgJ1xcXFxuJyk7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnN0ZG91dCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShsaW5lICsgJ1xcXFxuJyk7XFxuICB9IGVsc2Uge1xcbiAgICBjb25zb2xlLmxvZyhsaW5lKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIE91dHB1dCB0YWcgZm9yIHRoZSBnaXZlbiBgdGVzdC5gXFxuICpcXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3RcXG4gKi9cXG5YVW5pdC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHRlc3QpIHtcXG4gIHZhciBhdHRycyA9IHtcXG4gICAgY2xhc3NuYW1lOiB0ZXN0LnBhcmVudC5mdWxsVGl0bGUoKSxcXG4gICAgbmFtZTogdGVzdC50aXRsZSxcXG4gICAgdGltZTogdGVzdC5kdXJhdGlvbiAvIDEwMDAgfHwgMFxcbiAgfTtcXG5cXG4gIGlmICh0ZXN0LnN0YXRlID09PSAnZmFpbGVkJykge1xcbiAgICB2YXIgZXJyID0gdGVzdC5lcnI7XFxuICAgIHRoaXMud3JpdGUoXFxuICAgICAgdGFnKFxcbiAgICAgICAgJ3Rlc3RjYXNlJyxcXG4gICAgICAgIGF0dHJzLFxcbiAgICAgICAgZmFsc2UsXFxuICAgICAgICB0YWcoXFxuICAgICAgICAgICdmYWlsdXJlJyxcXG4gICAgICAgICAge30sXFxuICAgICAgICAgIGZhbHNlLFxcbiAgICAgICAgICBlc2NhcGUoZXJyLm1lc3NhZ2UpICsgJ1xcXFxuJyArIGVzY2FwZShlcnIuc3RhY2spXFxuICAgICAgICApXFxuICAgICAgKVxcbiAgICApO1xcbiAgfSBlbHNlIGlmICh0ZXN0LmlzUGVuZGluZygpKSB7XFxuICAgIHRoaXMud3JpdGUodGFnKCd0ZXN0Y2FzZScsIGF0dHJzLCBmYWxzZSwgdGFnKCdza2lwcGVkJywge30sIHRydWUpKSk7XFxuICB9IGVsc2Uge1xcbiAgICB0aGlzLndyaXRlKHRhZygndGVzdGNhc2UnLCBhdHRycywgdHJ1ZSkpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogSFRNTCB0YWcgaGVscGVyLlxcbiAqXFxuICogQHBhcmFtIG5hbWVcXG4gKiBAcGFyYW0gYXR0cnNcXG4gKiBAcGFyYW0gY2xvc2VcXG4gKiBAcGFyYW0gY29udGVudFxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiB0YWcobmFtZSwgYXR0cnMsIGNsb3NlLCBjb250ZW50KSB7XFxuICB2YXIgZW5kID0gY2xvc2UgPyAnLz4nIDogJz4nO1xcbiAgdmFyIHBhaXJzID0gW107XFxuICB2YXIgdGFnO1xcblxcbiAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XFxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cnMsIGtleSkpIHtcXG4gICAgICBwYWlycy5wdXNoKGtleSArICc9XFxcIicgKyBlc2NhcGUoYXR0cnNba2V5XSkgKyAnXFxcIicpO1xcbiAgICB9XFxuICB9XFxuXFxuICB0YWcgPSAnPCcgKyBuYW1lICsgKHBhaXJzLmxlbmd0aCA/ICcgJyArIHBhaXJzLmpvaW4oJyAnKSA6ICcnKSArIGVuZDtcXG4gIGlmIChjb250ZW50KSB7XFxuICAgIHRhZyArPSBjb250ZW50ICsgJzwvJyArIG5hbWUgKyBlbmQ7XFxuICB9XFxuICByZXR1cm4gdGFnO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1NixcXFwiZnNcXFwiOjQwLFxcXCJta2RpcnBcXFwiOjUzLFxcXCJwYXRoXFxcIjo0MH1dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKGdsb2JhbCl7XFxuJ3VzZSBzdHJpY3QnO1xcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxudmFyIFBlbmRpbmcgPSByZXF1aXJlKCcuL3BlbmRpbmcnKTtcXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTpydW5uYWJsZScpO1xcbnZhciBtaWxsaXNlY29uZHMgPSByZXF1aXJlKCcuL21zJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xcblxcbi8qKlxcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG5cXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xcblxcbm1vZHVsZS5leHBvcnRzID0gUnVubmFibGU7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUnVubmFibGVgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAuICBEZXJpdmVkIGZyb20gW0V2ZW50RW1pdHRlcl0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNldmVudHNfY2xhc3NfZXZlbnRlbWl0dGVyKVxcbiAqXFxuICogQGNsYXNzXFxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXFxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5mdW5jdGlvbiBSdW5uYWJsZSh0aXRsZSwgZm4pIHtcXG4gIHRoaXMudGl0bGUgPSB0aXRsZTtcXG4gIHRoaXMuZm4gPSBmbjtcXG4gIHRoaXMuYm9keSA9IChmbiB8fCAnJykudG9TdHJpbmcoKTtcXG4gIHRoaXMuYXN5bmMgPSBmbiAmJiBmbi5sZW5ndGg7XFxuICB0aGlzLnN5bmMgPSAhdGhpcy5hc3luYztcXG4gIHRoaXMuX3RpbWVvdXQgPSAyMDAwO1xcbiAgdGhpcy5fc2xvdyA9IDc1O1xcbiAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSB0cnVlO1xcbiAgdGhpcy50aW1lZE91dCA9IGZhbHNlO1xcbiAgdGhpcy5fcmV0cmllcyA9IC0xO1xcbiAgdGhpcy5fY3VycmVudFJldHJ5ID0gMDtcXG4gIHRoaXMucGVuZGluZyA9IGZhbHNlO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEV2ZW50RW1pdHRlci5wcm90b3R5cGVgLlxcbiAqL1xcbnV0aWxzLmluaGVyaXRzKFJ1bm5hYmxlLCBFdmVudEVtaXR0ZXIpO1xcblxcbi8qKlxcbiAqIFNldCAmIGdldCB0aW1lb3V0IGBtc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zXFxuICogQHJldHVybiB7UnVubmFibGV8bnVtYmVyfSBtcyBvciBSdW5uYWJsZSBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uKG1zKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XFxuICB9XFxuICAvLyBzZWUgIzE2NTIgZm9yIHJlYXNvbmluZ1xcbiAgaWYgKG1zID09PSAwIHx8IG1zID4gTWF0aC5wb3coMiwgMzEpKSB7XFxuICAgIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gZmFsc2U7XFxuICB9XFxuICBpZiAodHlwZW9mIG1zID09PSAnc3RyaW5nJykge1xcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XFxuICB9XFxuICBkZWJ1ZygndGltZW91dCAlZCcsIG1zKTtcXG4gIHRoaXMuX3RpbWVvdXQgPSBtcztcXG4gIGlmICh0aGlzLnRpbWVyKSB7XFxuICAgIHRoaXMucmVzZXRUaW1lb3V0KCk7XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgc2xvdyBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc1xcbiAqIEByZXR1cm4ge1J1bm5hYmxlfG51bWJlcn0gbXMgb3IgUnVubmFibGUgaW5zdGFuY2UuXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLnNsb3cgPSBmdW5jdGlvbihtcykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoIHx8IHR5cGVvZiBtcyA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3Nsb3c7XFxuICB9XFxuICBpZiAodHlwZW9mIG1zID09PSAnc3RyaW5nJykge1xcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XFxuICB9XFxuICBkZWJ1Zygnc2xvdyAlZCcsIG1zKTtcXG4gIHRoaXMuX3Nsb3cgPSBtcztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IGFuZCBnZXQgd2hldGhlciB0aW1lb3V0IGlzIGBlbmFibGVkYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxcbiAqIEByZXR1cm4ge1J1bm5hYmxlfGJvb2xlYW59IGVuYWJsZWQgb3IgUnVubmFibGUgaW5zdGFuY2UuXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmVuYWJsZVRpbWVvdXRzID0gZnVuY3Rpb24oZW5hYmxlZCkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9lbmFibGVUaW1lb3V0cztcXG4gIH1cXG4gIGRlYnVnKCdlbmFibGVUaW1lb3V0cyAlcycsIGVuYWJsZWQpO1xcbiAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSBlbmFibGVkO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBIYWx0IGFuZCBtYXJrIGFzIHBlbmRpbmcuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmFibGVcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uKCkge1xcbiAgdGhyb3cgbmV3IFBlbmRpbmcoJ3N5bmMgc2tpcCcpO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdGhpcyBydW5uYWJsZSBvciBpdHMgcGFyZW50IHN1aXRlIGlzIG1hcmtlZCBhcyBwZW5kaW5nLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uKCkge1xcbiAgcmV0dXJuIHRoaXMucGVuZGluZyB8fCAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNQZW5kaW5nKCkpO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGlzIFJ1bm5hYmxlIGhhcyBmYWlsZWQuXFxuICogQHJldHVybiB7Ym9vbGVhbn1cXG4gKiBAcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5pc0ZhaWxlZCA9IGZ1bmN0aW9uKCkge1xcbiAgcmV0dXJuICF0aGlzLmlzUGVuZGluZygpICYmIHRoaXMuc3RhdGUgPT09ICdmYWlsZWQnO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGlzIFJ1bm5hYmxlIGhhcyBwYXNzZWQuXFxuICogQHJldHVybiB7Ym9vbGVhbn1cXG4gKiBAcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5pc1Bhc3NlZCA9IGZ1bmN0aW9uKCkge1xcbiAgcmV0dXJuICF0aGlzLmlzUGVuZGluZygpICYmIHRoaXMuc3RhdGUgPT09ICdwYXNzZWQnO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IG9yIGdldCBudW1iZXIgb2YgcmV0cmllcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24obikge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9yZXRyaWVzO1xcbiAgfVxcbiAgdGhpcy5fcmV0cmllcyA9IG47XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IGN1cnJlbnQgcmV0cnlcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5jdXJyZW50UmV0cnkgPSBmdW5jdGlvbihuKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRSZXRyeTtcXG4gIH1cXG4gIHRoaXMuX2N1cnJlbnRSZXRyeSA9IG47XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIGZ1bGwgdGl0bGUgZ2VuZXJhdGVkIGJ5IHJlY3Vyc2l2ZWx5IGNvbmNhdGVuYXRpbmcgdGhlIHBhcmVudCdzXFxuICogZnVsbCB0aXRsZS5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYS5SdW5uYWJsZVxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuZnVsbFRpdGxlID0gZnVuY3Rpb24oKSB7XFxuICByZXR1cm4gdGhpcy50aXRsZVBhdGgoKS5qb2luKCcgJyk7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIHRpdGxlIHBhdGggZ2VuZXJhdGVkIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIHBhcmVudCdzIHRpdGxlIHBhdGggd2l0aCB0aGUgdGl0bGUuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmFibGVcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLnRpdGxlUGF0aCA9IGZ1bmN0aW9uKCkge1xcbiAgcmV0dXJuIHRoaXMucGFyZW50LnRpdGxlUGF0aCgpLmNvbmNhdChbdGhpcy50aXRsZV0pO1xcbn07XFxuXFxuLyoqXFxuICogQ2xlYXIgdGhlIHRpbWVvdXQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XFxuICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XFxufTtcXG5cXG4vKipcXG4gKiBJbnNwZWN0IHRoZSBydW5uYWJsZSB2b2lkIG9mIHByaXZhdGUgcHJvcGVydGllcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxcbiAgICB0aGlzLFxcbiAgICBmdW5jdGlvbihrZXksIHZhbCkge1xcbiAgICAgIGlmIChrZXlbMF0gPT09ICdfJykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBpZiAoa2V5ID09PSAncGFyZW50Jykge1xcbiAgICAgICAgcmV0dXJuICcjPFN1aXRlPic7XFxuICAgICAgfVxcbiAgICAgIGlmIChrZXkgPT09ICdjdHgnKSB7XFxuICAgICAgICByZXR1cm4gJyM8Q29udGV4dD4nO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdmFsO1xcbiAgICB9LFxcbiAgICAyXFxuICApO1xcbn07XFxuXFxuLyoqXFxuICogUmVzZXQgdGhlIHRpbWVvdXQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUucmVzZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgbXMgPSB0aGlzLnRpbWVvdXQoKSB8fCAxZTk7XFxuXFxuICBpZiAoIXRoaXMuX2VuYWJsZVRpbWVvdXRzKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XFxuICB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcXG4gICAgaWYgKCFzZWxmLl9lbmFibGVUaW1lb3V0cykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBzZWxmLmNhbGxiYWNrKHNlbGYuX3RpbWVvdXRFcnJvcihtcykpO1xcbiAgICBzZWxmLnRpbWVkT3V0ID0gdHJ1ZTtcXG4gIH0sIG1zKTtcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgYSBsaXN0IG9mIHdoaXRlbGlzdGVkIGdsb2JhbHMgZm9yIHRoaXMgdGVzdCBydW4uXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBnbG9iYWxzXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmdsb2JhbHMgPSBmdW5jdGlvbihnbG9iYWxzKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2FsbG93ZWRHbG9iYWxzO1xcbiAgfVxcbiAgdGhpcy5fYWxsb3dlZEdsb2JhbHMgPSBnbG9iYWxzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIHRoZSB0ZXN0IGFuZCBpbnZva2UgYGZuKGVycilgLlxcbiAqXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBzdGFydCA9IG5ldyBEYXRlKCk7XFxuICB2YXIgY3R4ID0gdGhpcy5jdHg7XFxuICB2YXIgZmluaXNoZWQ7XFxuICB2YXIgZW1pdHRlZDtcXG5cXG4gIC8vIFNvbWV0aW1lcyB0aGUgY3R4IGV4aXN0cywgYnV0IGl0IGlzIG5vdCBydW5uYWJsZVxcbiAgaWYgKGN0eCAmJiBjdHgucnVubmFibGUpIHtcXG4gICAgY3R4LnJ1bm5hYmxlKHRoaXMpO1xcbiAgfVxcblxcbiAgLy8gY2FsbGVkIG11bHRpcGxlIHRpbWVzXFxuICBmdW5jdGlvbiBtdWx0aXBsZShlcnIpIHtcXG4gICAgaWYgKGVtaXR0ZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZW1pdHRlZCA9IHRydWU7XFxuICAgIHZhciBtc2cgPSAnZG9uZSgpIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyc7XFxuICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UpIHtcXG4gICAgICBlcnIubWVzc2FnZSArPSBcXFwiIChhbmQgTW9jaGEncyBcXFwiICsgbXNnICsgJyknO1xcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IobXNnKSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIGZpbmlzaGVkXFxuICBmdW5jdGlvbiBkb25lKGVycikge1xcbiAgICB2YXIgbXMgPSBzZWxmLnRpbWVvdXQoKTtcXG4gICAgaWYgKHNlbGYudGltZWRPdXQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKGZpbmlzaGVkKSB7XFxuICAgICAgcmV0dXJuIG11bHRpcGxlKGVycik7XFxuICAgIH1cXG5cXG4gICAgc2VsZi5jbGVhclRpbWVvdXQoKTtcXG4gICAgc2VsZi5kdXJhdGlvbiA9IG5ldyBEYXRlKCkgLSBzdGFydDtcXG4gICAgZmluaXNoZWQgPSB0cnVlO1xcbiAgICBpZiAoIWVyciAmJiBzZWxmLmR1cmF0aW9uID4gbXMgJiYgc2VsZi5fZW5hYmxlVGltZW91dHMpIHtcXG4gICAgICBlcnIgPSBzZWxmLl90aW1lb3V0RXJyb3IobXMpO1xcbiAgICB9XFxuICAgIGZuKGVycik7XFxuICB9XFxuXFxuICAvLyBmb3IgLnJlc2V0VGltZW91dCgpXFxuICB0aGlzLmNhbGxiYWNrID0gZG9uZTtcXG5cXG4gIC8vIGV4cGxpY2l0IGFzeW5jIHdpdGggYGRvbmVgIGFyZ3VtZW50XFxuICBpZiAodGhpcy5hc3luYykge1xcbiAgICB0aGlzLnJlc2V0VGltZW91dCgpO1xcblxcbiAgICAvLyBhbGxvd3Mgc2tpcCgpIHRvIGJlIHVzZWQgaW4gYW4gZXhwbGljaXQgYXN5bmMgY29udGV4dFxcbiAgICB0aGlzLnNraXAgPSBmdW5jdGlvbiBhc3luY1NraXAoKSB7XFxuICAgICAgZG9uZShuZXcgUGVuZGluZygnYXN5bmMgc2tpcCBjYWxsJykpO1xcbiAgICAgIC8vIGhhbHQgZXhlY3V0aW9uLiAgdGhlIFJ1bm5hYmxlIHdpbGwgYmUgbWFya2VkIHBlbmRpbmdcXG4gICAgICAvLyBieSB0aGUgcHJldmlvdXMgY2FsbCwgYW5kIHRoZSB1bmNhdWdodCBoYW5kbGVyIHdpbGwgaWdub3JlXFxuICAgICAgLy8gdGhlIGZhaWx1cmUuXFxuICAgICAgdGhyb3cgbmV3IFBlbmRpbmcoJ2FzeW5jIHNraXA7IGFib3J0aW5nIGV4ZWN1dGlvbicpO1xcbiAgICB9O1xcblxcbiAgICBpZiAodGhpcy5hbGxvd1VuY2F1Z2h0KSB7XFxuICAgICAgcmV0dXJuIGNhbGxGbkFzeW5jKHRoaXMuZm4pO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgY2FsbEZuQXN5bmModGhpcy5mbik7XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIGVtaXR0ZWQgPSB0cnVlO1xcbiAgICAgIGRvbmUodXRpbHMuZ2V0RXJyb3IoZXJyKSk7XFxuICAgIH1cXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgaWYgKHRoaXMuYWxsb3dVbmNhdWdodCkge1xcbiAgICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICAgIGRvbmUoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjYWxsRm4odGhpcy5mbik7XFxuICAgIH1cXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgLy8gc3luYyBvciBwcm9taXNlLXJldHVybmluZ1xcbiAgdHJ5IHtcXG4gICAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcXG4gICAgICBkb25lKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY2FsbEZuKHRoaXMuZm4pO1xcbiAgICB9XFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgZW1pdHRlZCA9IHRydWU7XFxuICAgIGRvbmUodXRpbHMuZ2V0RXJyb3IoZXJyKSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjYWxsRm4oZm4pIHtcXG4gICAgdmFyIHJlc3VsdCA9IGZuLmNhbGwoY3R4KTtcXG4gICAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBzZWxmLnJlc2V0VGltZW91dCgpO1xcbiAgICAgIHJlc3VsdC50aGVuKFxcbiAgICAgICAgZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIGRvbmUoKTtcXG4gICAgICAgICAgLy8gUmV0dXJuIG51bGwgc28gbGlicmFyaWVzIGxpa2UgYmx1ZWJpcmQgZG8gbm90IHdhcm4gYWJvdXRcXG4gICAgICAgICAgLy8gc3Vic2VxdWVudGx5IGNvbnN0cnVjdGVkIFByb21pc2VzLlxcbiAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH0sXFxuICAgICAgICBmdW5jdGlvbihyZWFzb24pIHtcXG4gICAgICAgICAgZG9uZShyZWFzb24gfHwgbmV3IEVycm9yKCdQcm9taXNlIHJlamVjdGVkIHdpdGggbm8gb3IgZmFsc3kgcmVhc29uJykpO1xcbiAgICAgICAgfVxcbiAgICAgICk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKHNlbGYuYXN5bmNPbmx5KSB7XFxuICAgICAgICByZXR1cm4gZG9uZShcXG4gICAgICAgICAgbmV3IEVycm9yKFxcbiAgICAgICAgICAgICctLWFzeW5jLW9ubHkgb3B0aW9uIGluIHVzZSB3aXRob3V0IGRlY2xhcmluZyBgZG9uZSgpYCBvciByZXR1cm5pbmcgYSBwcm9taXNlJ1xcbiAgICAgICAgICApXFxuICAgICAgICApO1xcbiAgICAgIH1cXG5cXG4gICAgICBkb25lKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNhbGxGbkFzeW5jKGZuKSB7XFxuICAgIHZhciByZXN1bHQgPSBmbi5jYWxsKGN0eCwgZnVuY3Rpb24oZXJyKSB7XFxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IHRvU3RyaW5nLmNhbGwoZXJyKSA9PT0gJ1tvYmplY3QgRXJyb3JdJykge1xcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGVycikge1xcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpID09PSAnW29iamVjdCBPYmplY3RdJykge1xcbiAgICAgICAgICByZXR1cm4gZG9uZShcXG4gICAgICAgICAgICBuZXcgRXJyb3IoJ2RvbmUoKSBpbnZva2VkIHdpdGggbm9uLUVycm9yOiAnICsgSlNPTi5zdHJpbmdpZnkoZXJyKSlcXG4gICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignZG9uZSgpIGludm9rZWQgd2l0aCBub24tRXJyb3I6ICcgKyBlcnIpKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHJlc3VsdCAmJiB1dGlscy5pc1Byb21pc2UocmVzdWx0KSkge1xcbiAgICAgICAgcmV0dXJuIGRvbmUoXFxuICAgICAgICAgIG5ldyBFcnJvcihcXG4gICAgICAgICAgICAnUmVzb2x1dGlvbiBtZXRob2QgaXMgb3ZlcnNwZWNpZmllZC4gU3BlY2lmeSBhIGNhbGxiYWNrICpvciogcmV0dXJuIGEgUHJvbWlzZTsgbm90IGJvdGguJ1xcbiAgICAgICAgICApXFxuICAgICAgICApO1xcbiAgICAgIH1cXG5cXG4gICAgICBkb25lKCk7XFxuICAgIH0pO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogSW5zdGFudGlhdGVzIGEgXFxcInRpbWVvdXRcXFwiIGVycm9yXFxuICpcXG4gKiBAcGFyYW0ge251bWJlcn0gbXMgLSBUaW1lb3V0IChpbiBtaWxsaXNlY29uZHMpXFxuICogQHJldHVybnMge0Vycm9yfSBhIFxcXCJ0aW1lb3V0XFxcIiBlcnJvclxcbiAqIEBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLl90aW1lb3V0RXJyb3IgPSBmdW5jdGlvbihtcykge1xcbiAgdmFyIG1zZyA9XFxuICAgICdUaW1lb3V0IG9mICcgK1xcbiAgICBtcyArXFxuICAgICdtcyBleGNlZWRlZC4gRm9yIGFzeW5jIHRlc3RzIGFuZCBob29rcywgZW5zdXJlIFxcXCJkb25lKClcXFwiIGlzIGNhbGxlZDsgaWYgcmV0dXJuaW5nIGEgUHJvbWlzZSwgZW5zdXJlIGl0IHJlc29sdmVzLic7XFxuICBpZiAodGhpcy5maWxlKSB7XFxuICAgIG1zZyArPSAnICgnICsgdGhpcy5maWxlICsgJyknO1xcbiAgfVxcbiAgcmV0dXJuIG5ldyBFcnJvcihtc2cpO1xcbn07XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4vbXNcXFwiOjE0LFxcXCIuL3BlbmRpbmdcXFwiOjE1LFxcXCIuL3V0aWxzXFxcIjozNixcXFwiZGVidWdcXFwiOjQzLFxcXCJldmVudHNcXFwiOjQ3fV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBAbW9kdWxlIFJ1bm5lclxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcXG52YXIgUGVuZGluZyA9IHJlcXVpcmUoJy4vcGVuZGluZycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG52YXIgaW5oZXJpdHMgPSB1dGlscy5pbmhlcml0cztcXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTpydW5uZXInKTtcXG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XFxudmFyIHN0YWNrRmlsdGVyID0gdXRpbHMuc3RhY2tUcmFjZUZpbHRlcigpO1xcbnZhciBzdHJpbmdpZnkgPSB1dGlscy5zdHJpbmdpZnk7XFxudmFyIHR5cGUgPSB1dGlscy50eXBlO1xcbnZhciB1bmRlZmluZWRFcnJvciA9IHV0aWxzLnVuZGVmaW5lZEVycm9yO1xcblxcbi8qKlxcbiAqIE5vbi1lbnVtZXJhYmxlIGdsb2JhbHMuXFxuICovXFxuXFxudmFyIGdsb2JhbHMgPSBbXFxuICAnc2V0VGltZW91dCcsXFxuICAnY2xlYXJUaW1lb3V0JyxcXG4gICdzZXRJbnRlcnZhbCcsXFxuICAnY2xlYXJJbnRlcnZhbCcsXFxuICAnWE1MSHR0cFJlcXVlc3QnLFxcbiAgJ0RhdGUnLFxcbiAgJ3NldEltbWVkaWF0ZScsXFxuICAnY2xlYXJJbW1lZGlhdGUnXFxuXTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFJ1bm5lcmAuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBSdW5uZXI7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIGBSdW5uZXJgIGZvciB0aGUgZ2l2ZW4gYHN1aXRlYC4gRGVyaXZlZCBmcm9tIFtFdmVudEVtaXR0ZXJdKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2NsYXNzX2V2ZW50ZW1pdHRlcilcXG4gKlxcbiAqIEV2ZW50czpcXG4gKlxcbiAqICAgLSBgc3RhcnRgICBleGVjdXRpb24gc3RhcnRlZFxcbiAqICAgLSBgZW5kYCAgZXhlY3V0aW9uIGNvbXBsZXRlXFxuICogICAtIGBzdWl0ZWAgIChzdWl0ZSkgdGVzdCBzdWl0ZSBleGVjdXRpb24gc3RhcnRlZFxcbiAqICAgLSBgc3VpdGUgZW5kYCAgKHN1aXRlKSBhbGwgdGVzdHMgKGFuZCBzdWItc3VpdGVzKSBoYXZlIGZpbmlzaGVkXFxuICogICAtIGB0ZXN0YCAgKHRlc3QpIHRlc3QgZXhlY3V0aW9uIHN0YXJ0ZWRcXG4gKiAgIC0gYHRlc3QgZW5kYCAgKHRlc3QpIHRlc3QgY29tcGxldGVkXFxuICogICAtIGBob29rYCAgKGhvb2spIGhvb2sgZXhlY3V0aW9uIHN0YXJ0ZWRcXG4gKiAgIC0gYGhvb2sgZW5kYCAgKGhvb2spIGhvb2sgY29tcGxldGVcXG4gKiAgIC0gYHBhc3NgICAodGVzdCkgdGVzdCBwYXNzZWRcXG4gKiAgIC0gYGZhaWxgICAodGVzdCwgZXJyKSB0ZXN0IGZhaWxlZFxcbiAqICAgLSBgcGVuZGluZ2AgICh0ZXN0KSB0ZXN0IHBlbmRpbmdcXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYVxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7U3VpdGV9IFtzdWl0ZV0gUm9vdCBzdWl0ZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlbGF5XSBXaGV0aGVyIG9yIG5vdCB0byBkZWxheSBleGVjdXRpb24gb2Ygcm9vdCBzdWl0ZVxcbiAqIHVudGlsIHJlYWR5LlxcbiAqL1xcbmZ1bmN0aW9uIFJ1bm5lcihzdWl0ZSwgZGVsYXkpIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHRoaXMuX2dsb2JhbHMgPSBbXTtcXG4gIHRoaXMuX2Fib3J0ID0gZmFsc2U7XFxuICB0aGlzLl9kZWxheSA9IGRlbGF5O1xcbiAgdGhpcy5zdWl0ZSA9IHN1aXRlO1xcbiAgdGhpcy5zdGFydGVkID0gZmFsc2U7XFxuICB0aGlzLnRvdGFsID0gc3VpdGUudG90YWwoKTtcXG4gIHRoaXMuZmFpbHVyZXMgPSAwO1xcbiAgdGhpcy5vbigndGVzdCBlbmQnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHNlbGYuY2hlY2tHbG9iYWxzKHRlc3QpO1xcbiAgfSk7XFxuICB0aGlzLm9uKCdob29rIGVuZCcsIGZ1bmN0aW9uKGhvb2spIHtcXG4gICAgc2VsZi5jaGVja0dsb2JhbHMoaG9vayk7XFxuICB9KTtcXG4gIHRoaXMuX2RlZmF1bHRHcmVwID0gLy4qLztcXG4gIHRoaXMuZ3JlcCh0aGlzLl9kZWZhdWx0R3JlcCk7XFxuICB0aGlzLmdsb2JhbHModGhpcy5nbG9iYWxQcm9wcygpLmNvbmNhdChleHRyYUdsb2JhbHMoKSkpO1xcbn1cXG5cXG4vKipcXG4gKiBXcmFwcGVyIGZvciBzZXRJbW1lZGlhdGUsIHByb2Nlc3MubmV4dFRpY2ssIG9yIGJyb3dzZXIgcG9seWZpbGwuXFxuICpcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5pbW1lZGlhdGVseSA9IGdsb2JhbC5zZXRJbW1lZGlhdGUgfHwgcHJvY2Vzcy5uZXh0VGljaztcXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEV2ZW50RW1pdHRlci5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKFJ1bm5lciwgRXZlbnRFbWl0dGVyKTtcXG5cXG4vKipcXG4gKiBSdW4gdGVzdHMgd2l0aCBmdWxsIHRpdGxlcyBtYXRjaGluZyBgcmVgLiBVcGRhdGVzIHJ1bm5lci50b3RhbFxcbiAqIHdpdGggbnVtYmVyIG9mIHRlc3RzIG1hdGNoZWQuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmVyXFxuICogQHBhcmFtIHtSZWdFeHB9IHJlXFxuICogQHBhcmFtIHtib29sZWFufSBpbnZlcnRcXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmdyZXAgPSBmdW5jdGlvbihyZSwgaW52ZXJ0KSB7XFxuICBkZWJ1ZygnZ3JlcCAlcycsIHJlKTtcXG4gIHRoaXMuX2dyZXAgPSByZTtcXG4gIHRoaXMuX2ludmVydCA9IGludmVydDtcXG4gIHRoaXMudG90YWwgPSB0aGlzLmdyZXBUb3RhbCh0aGlzLnN1aXRlKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRlc3RzIG1hdGNoaW5nIHRoZSBncmVwIHNlYXJjaCBmb3IgdGhlXFxuICogZ2l2ZW4gc3VpdGUuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmVyXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKiBAcmV0dXJuIHtudW1iZXJ9XFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ncmVwVG90YWwgPSBmdW5jdGlvbihzdWl0ZSkge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRvdGFsID0gMDtcXG5cXG4gIHN1aXRlLmVhY2hUZXN0KGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgdmFyIG1hdGNoID0gc2VsZi5fZ3JlcC50ZXN0KHRlc3QuZnVsbFRpdGxlKCkpO1xcbiAgICBpZiAoc2VsZi5faW52ZXJ0KSB7XFxuICAgICAgbWF0Y2ggPSAhbWF0Y2g7XFxuICAgIH1cXG4gICAgaWYgKG1hdGNoKSB7XFxuICAgICAgdG90YWwrKztcXG4gICAgfVxcbiAgfSk7XFxuXFxuICByZXR1cm4gdG90YWw7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBsaXN0IG9mIGdsb2JhbCBwcm9wZXJ0aWVzLlxcbiAqXFxuICogQHJldHVybiB7QXJyYXl9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5nbG9iYWxQcm9wcyA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHByb3BzID0gT2JqZWN0LmtleXMoZ2xvYmFsKTtcXG5cXG4gIC8vIG5vbi1lbnVtZXJhYmxlc1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbG9iYWxzLmxlbmd0aDsgKytpKSB7XFxuICAgIGlmICh+cHJvcHMuaW5kZXhPZihnbG9iYWxzW2ldKSkge1xcbiAgICAgIGNvbnRpbnVlO1xcbiAgICB9XFxuICAgIHByb3BzLnB1c2goZ2xvYmFsc1tpXSk7XFxuICB9XFxuXFxuICByZXR1cm4gcHJvcHM7XFxufTtcXG5cXG4vKipcXG4gKiBBbGxvdyB0aGUgZ2l2ZW4gYGFycmAgb2YgZ2xvYmFscy5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5SdW5uZXJcXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmdsb2JhbHMgPSBmdW5jdGlvbihhcnIpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fZ2xvYmFscztcXG4gIH1cXG4gIGRlYnVnKCdnbG9iYWxzICVqJywgYXJyKTtcXG4gIHRoaXMuX2dsb2JhbHMgPSB0aGlzLl9nbG9iYWxzLmNvbmNhdChhcnIpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBmb3IgZ2xvYmFsIHZhcmlhYmxlIGxlYWtzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5jaGVja0dsb2JhbHMgPSBmdW5jdGlvbih0ZXN0KSB7XFxuICBpZiAodGhpcy5pZ25vcmVMZWFrcykge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB2YXIgb2sgPSB0aGlzLl9nbG9iYWxzO1xcblxcbiAgdmFyIGdsb2JhbHMgPSB0aGlzLmdsb2JhbFByb3BzKCk7XFxuICB2YXIgbGVha3M7XFxuXFxuICBpZiAodGVzdCkge1xcbiAgICBvayA9IG9rLmNvbmNhdCh0ZXN0Ll9hbGxvd2VkR2xvYmFscyB8fCBbXSk7XFxuICB9XFxuXFxuICBpZiAodGhpcy5wcmV2R2xvYmFsc0xlbmd0aCA9PT0gZ2xvYmFscy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdGhpcy5wcmV2R2xvYmFsc0xlbmd0aCA9IGdsb2JhbHMubGVuZ3RoO1xcblxcbiAgbGVha3MgPSBmaWx0ZXJMZWFrcyhvaywgZ2xvYmFscyk7XFxuICB0aGlzLl9nbG9iYWxzID0gdGhpcy5fZ2xvYmFscy5jb25jYXQobGVha3MpO1xcblxcbiAgaWYgKGxlYWtzLmxlbmd0aCA+IDEpIHtcXG4gICAgdGhpcy5mYWlsKFxcbiAgICAgIHRlc3QsXFxuICAgICAgbmV3IEVycm9yKCdnbG9iYWwgbGVha3MgZGV0ZWN0ZWQ6ICcgKyBsZWFrcy5qb2luKCcsICcpICsgJycpXFxuICAgICk7XFxuICB9IGVsc2UgaWYgKGxlYWtzLmxlbmd0aCkge1xcbiAgICB0aGlzLmZhaWwodGVzdCwgbmV3IEVycm9yKCdnbG9iYWwgbGVhayBkZXRlY3RlZDogJyArIGxlYWtzWzBdKSk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBGYWlsIHRoZSBnaXZlbiBgdGVzdGAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3RcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmZhaWwgPSBmdW5jdGlvbih0ZXN0LCBlcnIpIHtcXG4gIGlmICh0ZXN0LmlzUGVuZGluZygpKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gICsrdGhpcy5mYWlsdXJlcztcXG4gIHRlc3Quc3RhdGUgPSAnZmFpbGVkJztcXG5cXG4gIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IChlcnIgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJykpKSB7XFxuICAgIGVyciA9IG5ldyBFcnJvcihcXG4gICAgICAndGhlICcgK1xcbiAgICAgICAgdHlwZShlcnIpICtcXG4gICAgICAgICcgJyArXFxuICAgICAgICBzdHJpbmdpZnkoZXJyKSArXFxuICAgICAgICAnIHdhcyB0aHJvd24sIHRocm93IGFuIEVycm9yIDopJ1xcbiAgICApO1xcbiAgfVxcblxcbiAgdHJ5IHtcXG4gICAgZXJyLnN0YWNrID1cXG4gICAgICB0aGlzLmZ1bGxTdGFja1RyYWNlIHx8ICFlcnIuc3RhY2sgPyBlcnIuc3RhY2sgOiBzdGFja0ZpbHRlcihlcnIuc3RhY2spO1xcbiAgfSBjYXRjaCAoaWdub3JlKSB7XFxuICAgIC8vIHNvbWUgZW52aXJvbm1lbnRzIGRvIG5vdCB0YWtlIGtpbmRseSB0byBtb25rZXlpbmcgd2l0aCB0aGUgc3RhY2tcXG4gIH1cXG5cXG4gIHRoaXMuZW1pdCgnZmFpbCcsIHRlc3QsIGVycik7XFxuICBpZiAodGhpcy5zdWl0ZS5iYWlsKCkpIHtcXG4gICAgdGhpcy5lbWl0KCdlbmQnKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEZhaWwgdGhlIGdpdmVuIGBob29rYCB3aXRoIGBlcnJgLlxcbiAqXFxuICogSG9vayBmYWlsdXJlcyB3b3JrIGluIHRoZSBmb2xsb3dpbmcgcGF0dGVybjpcXG4gKiAtIElmIGJhaWwsIHRoZW4gZXhpdFxcbiAqIC0gRmFpbGVkIGBiZWZvcmVgIGhvb2sgc2tpcHMgYWxsIHRlc3RzIGluIGEgc3VpdGUgYW5kIHN1YnN1aXRlcyxcXG4gKiAgIGJ1dCBqdW1wcyB0byBjb3JyZXNwb25kaW5nIGBhZnRlcmAgaG9va1xcbiAqIC0gRmFpbGVkIGBiZWZvcmUgZWFjaGAgaG9vayBza2lwcyByZW1haW5pbmcgdGVzdHMgaW4gYVxcbiAqICAgc3VpdGUgYW5kIGp1bXBzIHRvIGNvcnJlc3BvbmRpbmcgYGFmdGVyIGVhY2hgIGhvb2ssXFxuICogICB3aGljaCBpcyBydW4gb25seSBvbmNlXFxuICogLSBGYWlsZWQgYGFmdGVyYCBob29rIGRvZXMgbm90IGFsdGVyXFxuICogICBleGVjdXRpb24gb3JkZXJcXG4gKiAtIEZhaWxlZCBgYWZ0ZXIgZWFjaGAgaG9vayBza2lwcyByZW1haW5pbmcgdGVzdHMgaW4gYVxcbiAqICAgc3VpdGUgYW5kIHN1YnN1aXRlcywgYnV0IGV4ZWN1dGVzIG90aGVyIGBhZnRlciBlYWNoYFxcbiAqICAgaG9va3NcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7SG9va30gaG9va1xcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuZmFpbEhvb2sgPSBmdW5jdGlvbihob29rLCBlcnIpIHtcXG4gIGlmIChob29rLmN0eCAmJiBob29rLmN0eC5jdXJyZW50VGVzdCkge1xcbiAgICBob29rLm9yaWdpbmFsVGl0bGUgPSBob29rLm9yaWdpbmFsVGl0bGUgfHwgaG9vay50aXRsZTtcXG4gICAgaG9vay50aXRsZSA9XFxuICAgICAgaG9vay5vcmlnaW5hbFRpdGxlICsgJyBmb3IgXFxcIicgKyBob29rLmN0eC5jdXJyZW50VGVzdC50aXRsZSArICdcXFwiJztcXG4gIH1cXG5cXG4gIHRoaXMuZmFpbChob29rLCBlcnIpO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGhvb2sgYG5hbWVgIGNhbGxiYWNrcyBhbmQgdGhlbiBpbnZva2UgYGZuKClgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcblxcblJ1bm5lci5wcm90b3R5cGUuaG9vayA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XFxuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xcbiAgdmFyIGhvb2tzID0gc3VpdGVbJ18nICsgbmFtZV07XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICBmdW5jdGlvbiBuZXh0KGkpIHtcXG4gICAgdmFyIGhvb2sgPSBob29rc1tpXTtcXG4gICAgaWYgKCFob29rKSB7XFxuICAgICAgcmV0dXJuIGZuKCk7XFxuICAgIH1cXG4gICAgc2VsZi5jdXJyZW50UnVubmFibGUgPSBob29rO1xcblxcbiAgICBob29rLmN0eC5jdXJyZW50VGVzdCA9IHNlbGYudGVzdDtcXG5cXG4gICAgc2VsZi5lbWl0KCdob29rJywgaG9vayk7XFxuXFxuICAgIGlmICghaG9vay5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoKSB7XFxuICAgICAgaG9vay5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcXG4gICAgICAgIHNlbGYuZmFpbEhvb2soaG9vaywgZXJyKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBob29rLnJ1bihmdW5jdGlvbihlcnIpIHtcXG4gICAgICB2YXIgdGVzdEVycm9yID0gaG9vay5lcnJvcigpO1xcbiAgICAgIGlmICh0ZXN0RXJyb3IpIHtcXG4gICAgICAgIHNlbGYuZmFpbChzZWxmLnRlc3QsIHRlc3RFcnJvcik7XFxuICAgICAgfVxcbiAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBQZW5kaW5nKSB7XFxuICAgICAgICAgIGlmIChuYW1lID09PSAnYmVmb3JlRWFjaCcgfHwgbmFtZSA9PT0gJ2FmdGVyRWFjaCcpIHtcXG4gICAgICAgICAgICBzZWxmLnRlc3QucGVuZGluZyA9IHRydWU7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgc3VpdGUudGVzdHMuZm9yRWFjaChmdW5jdGlvbih0ZXN0KSB7XFxuICAgICAgICAgICAgICB0ZXN0LnBlbmRpbmcgPSB0cnVlO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIC8vIGEgcGVuZGluZyBob29rIHdvbid0IGJlIGV4ZWN1dGVkIHR3aWNlLlxcbiAgICAgICAgICAgIGhvb2sucGVuZGluZyA9IHRydWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNlbGYuZmFpbEhvb2soaG9vaywgZXJyKTtcXG5cXG4gICAgICAgICAgLy8gc3RvcCBleGVjdXRpbmcgaG9va3MsIG5vdGlmeSBjYWxsZWUgb2YgaG9vayBlcnJcXG4gICAgICAgICAgcmV0dXJuIGZuKGVycik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHNlbGYuZW1pdCgnaG9vayBlbmQnLCBob29rKTtcXG4gICAgICBkZWxldGUgaG9vay5jdHguY3VycmVudFRlc3Q7XFxuICAgICAgbmV4dCgrK2kpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIFJ1bm5lci5pbW1lZGlhdGVseShmdW5jdGlvbigpIHtcXG4gICAgbmV4dCgwKTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGhvb2sgYG5hbWVgIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHN1aXRlc2BcXG4gKiBpbiBvcmRlciwgYW5kIGNhbGxiYWNrIGBmbihlcnIsIGVyclN1aXRlKWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7QXJyYXl9IHN1aXRlc1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ob29rcyA9IGZ1bmN0aW9uKG5hbWUsIHN1aXRlcywgZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBvcmlnID0gdGhpcy5zdWl0ZTtcXG5cXG4gIGZ1bmN0aW9uIG5leHQoc3VpdGUpIHtcXG4gICAgc2VsZi5zdWl0ZSA9IHN1aXRlO1xcblxcbiAgICBpZiAoIXN1aXRlKSB7XFxuICAgICAgc2VsZi5zdWl0ZSA9IG9yaWc7XFxuICAgICAgcmV0dXJuIGZuKCk7XFxuICAgIH1cXG5cXG4gICAgc2VsZi5ob29rKG5hbWUsIGZ1bmN0aW9uKGVycikge1xcbiAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgIHZhciBlcnJTdWl0ZSA9IHNlbGYuc3VpdGU7XFxuICAgICAgICBzZWxmLnN1aXRlID0gb3JpZztcXG4gICAgICAgIHJldHVybiBmbihlcnIsIGVyclN1aXRlKTtcXG4gICAgICB9XFxuXFxuICAgICAgbmV4dChzdWl0ZXMucG9wKCkpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIG5leHQoc3VpdGVzLnBvcCgpKTtcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBob29rcyBmcm9tIHRoZSB0b3AgbGV2ZWwgZG93bi5cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmhvb2tVcCA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XFxuICB2YXIgc3VpdGVzID0gW3RoaXMuc3VpdGVdLmNvbmNhdCh0aGlzLnBhcmVudHMoKSkucmV2ZXJzZSgpO1xcbiAgdGhpcy5ob29rcyhuYW1lLCBzdWl0ZXMsIGZuKTtcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBob29rcyBmcm9tIHRoZSBib3R0b20gdXAuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ob29rRG93biA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XFxuICB2YXIgc3VpdGVzID0gW3RoaXMuc3VpdGVdLmNvbmNhdCh0aGlzLnBhcmVudHMoKSk7XFxuICB0aGlzLmhvb2tzKG5hbWUsIHN1aXRlcywgZm4pO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIGFuIGFycmF5IG9mIHBhcmVudCBTdWl0ZXMgZnJvbVxcbiAqIGNsb3Nlc3QgdG8gZnVydGhlc3QuXFxuICpcXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnBhcmVudHMgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XFxuICB2YXIgc3VpdGVzID0gW107XFxuICB3aGlsZSAoc3VpdGUucGFyZW50KSB7XFxuICAgIHN1aXRlID0gc3VpdGUucGFyZW50O1xcbiAgICBzdWl0ZXMucHVzaChzdWl0ZSk7XFxuICB9XFxuICByZXR1cm4gc3VpdGVzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIHRoZSBjdXJyZW50IHRlc3QgYW5kIGNhbGxiYWNrIGBmbihlcnIpYC5cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ydW5UZXN0ID0gZnVuY3Rpb24oZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB0ZXN0ID0gdGhpcy50ZXN0O1xcblxcbiAgaWYgKCF0ZXN0KSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIGlmICh0aGlzLmZvcmJpZE9ubHkgJiYgaGFzT25seSh0aGlzLnBhcmVudHMoKS5yZXZlcnNlKClbMF0gfHwgdGhpcy5zdWl0ZSkpIHtcXG4gICAgZm4obmV3IEVycm9yKCdgLm9ubHlgIGZvcmJpZGRlbicpKTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgaWYgKHRoaXMuYXN5bmNPbmx5KSB7XFxuICAgIHRlc3QuYXN5bmNPbmx5ID0gdHJ1ZTtcXG4gIH1cXG4gIHRlc3Qub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XFxuICAgIHNlbGYuZmFpbCh0ZXN0LCBlcnIpO1xcbiAgfSk7XFxuICBpZiAodGhpcy5hbGxvd1VuY2F1Z2h0KSB7XFxuICAgIHRlc3QuYWxsb3dVbmNhdWdodCA9IHRydWU7XFxuICAgIHJldHVybiB0ZXN0LnJ1bihmbik7XFxuICB9XFxuICB0cnkge1xcbiAgICB0ZXN0LnJ1bihmbik7XFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgZm4oZXJyKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFJ1biB0ZXN0cyBpbiB0aGUgZ2l2ZW4gYHN1aXRlYCBhbmQgaW52b2tlIHRoZSBjYWxsYmFjayBgZm4oKWAgd2hlbiBjb21wbGV0ZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnJ1blRlc3RzID0gZnVuY3Rpb24oc3VpdGUsIGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdGVzdHMgPSBzdWl0ZS50ZXN0cy5zbGljZSgpO1xcbiAgdmFyIHRlc3Q7XFxuXFxuICBmdW5jdGlvbiBob29rRXJyKF8sIGVyclN1aXRlLCBhZnRlcikge1xcbiAgICAvLyBiZWZvcmUvYWZ0ZXIgRWFjaCBob29rIGZvciBlcnJTdWl0ZSBmYWlsZWQ6XFxuICAgIHZhciBvcmlnID0gc2VsZi5zdWl0ZTtcXG5cXG4gICAgLy8gZm9yIGZhaWxlZCAnYWZ0ZXIgZWFjaCcgaG9vayBzdGFydCBmcm9tIGVyclN1aXRlIHBhcmVudCxcXG4gICAgLy8gb3RoZXJ3aXNlIHN0YXJ0IGZyb20gZXJyU3VpdGUgaXRzZWxmXFxuICAgIHNlbGYuc3VpdGUgPSBhZnRlciA/IGVyclN1aXRlLnBhcmVudCA6IGVyclN1aXRlO1xcblxcbiAgICBpZiAoc2VsZi5zdWl0ZSkge1xcbiAgICAgIC8vIGNhbGwgaG9va1VwIGFmdGVyRWFjaFxcbiAgICAgIHNlbGYuaG9va1VwKCdhZnRlckVhY2gnLCBmdW5jdGlvbihlcnIyLCBlcnJTdWl0ZTIpIHtcXG4gICAgICAgIHNlbGYuc3VpdGUgPSBvcmlnO1xcbiAgICAgICAgLy8gc29tZSBob29rcyBtYXkgZmFpbCBldmVuIG5vd1xcbiAgICAgICAgaWYgKGVycjIpIHtcXG4gICAgICAgICAgcmV0dXJuIGhvb2tFcnIoZXJyMiwgZXJyU3VpdGUyLCB0cnVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIHJlcG9ydCBlcnJvciBzdWl0ZVxcbiAgICAgICAgZm4oZXJyU3VpdGUpO1xcbiAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgY2FsbGluZyBvdGhlciAnYWZ0ZXIgZWFjaCcgaG9va3NcXG4gICAgICBzZWxmLnN1aXRlID0gb3JpZztcXG4gICAgICBmbihlcnJTdWl0ZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG5leHQoZXJyLCBlcnJTdWl0ZSkge1xcbiAgICAvLyBpZiB3ZSBiYWlsIGFmdGVyIGZpcnN0IGVyclxcbiAgICBpZiAoc2VsZi5mYWlsdXJlcyAmJiBzdWl0ZS5fYmFpbCkge1xcbiAgICAgIHJldHVybiBmbigpO1xcbiAgICB9XFxuXFxuICAgIGlmIChzZWxmLl9hYm9ydCkge1xcbiAgICAgIHJldHVybiBmbigpO1xcbiAgICB9XFxuXFxuICAgIGlmIChlcnIpIHtcXG4gICAgICByZXR1cm4gaG9va0VycihlcnIsIGVyclN1aXRlLCB0cnVlKTtcXG4gICAgfVxcblxcbiAgICAvLyBuZXh0IHRlc3RcXG4gICAgdGVzdCA9IHRlc3RzLnNoaWZ0KCk7XFxuXFxuICAgIC8vIGFsbCBkb25lXFxuICAgIGlmICghdGVzdCkge1xcbiAgICAgIHJldHVybiBmbigpO1xcbiAgICB9XFxuXFxuICAgIC8vIGdyZXBcXG4gICAgdmFyIG1hdGNoID0gc2VsZi5fZ3JlcC50ZXN0KHRlc3QuZnVsbFRpdGxlKCkpO1xcbiAgICBpZiAoc2VsZi5faW52ZXJ0KSB7XFxuICAgICAgbWF0Y2ggPSAhbWF0Y2g7XFxuICAgIH1cXG4gICAgaWYgKCFtYXRjaCkge1xcbiAgICAgIC8vIFJ1biBpbW1lZGlhdGVseSBvbmx5IGlmIHdlIGhhdmUgZGVmaW5lZCBhIGdyZXAuIFdoZW4gd2VcXG4gICAgICAvLyBkZWZpbmUgYSBncmVwIOKAlCBJdCBjYW4gY2F1c2UgbWF4aW11bSBjYWxsc3RhY2sgZXJyb3IgaWZcXG4gICAgICAvLyB0aGUgZ3JlcCBpcyBkb2luZyBhIGxhcmdlIHJlY3Vyc2l2ZSBsb29wIGJ5IG5lZ2xlY3RpbmdcXG4gICAgICAvLyBhbGwgdGVzdHMuIFRoZSBydW4gaW1tZWRpYXRlbHkgZnVuY3Rpb24gYWxzbyBjb21lcyB3aXRoXFxuICAgICAgLy8gYSBwZXJmb3JtYW5jZSBjb3N0LiBTbyB3ZSBkb24ndCB3YW50IHRvIHJ1biBpbW1lZGlhdGVseVxcbiAgICAgIC8vIGlmIHdlIHJ1biB0aGUgd2hvbGUgdGVzdCBzdWl0ZSwgYmVjYXVzZSBydW5uaW5nIHRoZSB3aG9sZVxcbiAgICAgIC8vIHRlc3Qgc3VpdGUgZG9uJ3QgZG8gYW55IGltbWVkaWF0ZSByZWN1cnNpdmUgbG9vcHMuIFRodXMsXFxuICAgICAgLy8gYWxsb3dpbmcgYSBKUyBydW50aW1lIHRvIGJyZWF0aGUuXFxuICAgICAgaWYgKHNlbGYuX2dyZXAgIT09IHNlbGYuX2RlZmF1bHRHcmVwKSB7XFxuICAgICAgICBSdW5uZXIuaW1tZWRpYXRlbHkobmV4dCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG5leHQoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICh0ZXN0LmlzUGVuZGluZygpKSB7XFxuICAgICAgaWYgKHNlbGYuZm9yYmlkUGVuZGluZykge1xcbiAgICAgICAgdGVzdC5pc1BlbmRpbmcgPSBhbHdheXNGYWxzZTtcXG4gICAgICAgIHNlbGYuZmFpbCh0ZXN0LCBuZXcgRXJyb3IoJ1BlbmRpbmcgdGVzdCBmb3JiaWRkZW4nKSk7XFxuICAgICAgICBkZWxldGUgdGVzdC5pc1BlbmRpbmc7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHNlbGYuZW1pdCgncGVuZGluZycsIHRlc3QpO1xcbiAgICAgIH1cXG4gICAgICBzZWxmLmVtaXQoJ3Rlc3QgZW5kJywgdGVzdCk7XFxuICAgICAgcmV0dXJuIG5leHQoKTtcXG4gICAgfVxcblxcbiAgICAvLyBleGVjdXRlIHRlc3QgYW5kIGhvb2socylcXG4gICAgc2VsZi5lbWl0KCd0ZXN0JywgKHNlbGYudGVzdCA9IHRlc3QpKTtcXG4gICAgc2VsZi5ob29rRG93bignYmVmb3JlRWFjaCcsIGZ1bmN0aW9uKGVyciwgZXJyU3VpdGUpIHtcXG4gICAgICBpZiAodGVzdC5pc1BlbmRpbmcoKSkge1xcbiAgICAgICAgaWYgKHNlbGYuZm9yYmlkUGVuZGluZykge1xcbiAgICAgICAgICB0ZXN0LmlzUGVuZGluZyA9IGFsd2F5c0ZhbHNlO1xcbiAgICAgICAgICBzZWxmLmZhaWwodGVzdCwgbmV3IEVycm9yKCdQZW5kaW5nIHRlc3QgZm9yYmlkZGVuJykpO1xcbiAgICAgICAgICBkZWxldGUgdGVzdC5pc1BlbmRpbmc7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzZWxmLmVtaXQoJ3BlbmRpbmcnLCB0ZXN0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNlbGYuZW1pdCgndGVzdCBlbmQnLCB0ZXN0KTtcXG4gICAgICAgIHJldHVybiBuZXh0KCk7XFxuICAgICAgfVxcbiAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgIHJldHVybiBob29rRXJyKGVyciwgZXJyU3VpdGUsIGZhbHNlKTtcXG4gICAgICB9XFxuICAgICAgc2VsZi5jdXJyZW50UnVubmFibGUgPSBzZWxmLnRlc3Q7XFxuICAgICAgc2VsZi5ydW5UZXN0KGZ1bmN0aW9uKGVycikge1xcbiAgICAgICAgdGVzdCA9IHNlbGYudGVzdDtcXG4gICAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgICAgdmFyIHJldHJ5ID0gdGVzdC5jdXJyZW50UmV0cnkoKTtcXG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFBlbmRpbmcgJiYgc2VsZi5mb3JiaWRQZW5kaW5nKSB7XFxuICAgICAgICAgICAgc2VsZi5mYWlsKHRlc3QsIG5ldyBFcnJvcignUGVuZGluZyB0ZXN0IGZvcmJpZGRlbicpKTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChlcnIgaW5zdGFuY2VvZiBQZW5kaW5nKSB7XFxuICAgICAgICAgICAgdGVzdC5wZW5kaW5nID0gdHJ1ZTtcXG4gICAgICAgICAgICBzZWxmLmVtaXQoJ3BlbmRpbmcnLCB0ZXN0KTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChyZXRyeSA8IHRlc3QucmV0cmllcygpKSB7XFxuICAgICAgICAgICAgdmFyIGNsb25lZFRlc3QgPSB0ZXN0LmNsb25lKCk7XFxuICAgICAgICAgICAgY2xvbmVkVGVzdC5jdXJyZW50UmV0cnkocmV0cnkgKyAxKTtcXG4gICAgICAgICAgICB0ZXN0cy51bnNoaWZ0KGNsb25lZFRlc3QpO1xcblxcbiAgICAgICAgICAgIC8vIEVhcmx5IHJldHVybiArIGhvb2sgdHJpZ2dlciBzbyB0aGF0IGl0IGRvZXNuJ3RcXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGNvdW50IHdyb25nXFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaG9va1VwKCdhZnRlckVhY2gnLCBuZXh0KTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzZWxmLmZhaWwodGVzdCwgZXJyKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZWxmLmVtaXQoJ3Rlc3QgZW5kJywgdGVzdCk7XFxuXFxuICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBQZW5kaW5nKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gc2VsZi5ob29rVXAoJ2FmdGVyRWFjaCcsIG5leHQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGVzdC5zdGF0ZSA9ICdwYXNzZWQnO1xcbiAgICAgICAgc2VsZi5lbWl0KCdwYXNzJywgdGVzdCk7XFxuICAgICAgICBzZWxmLmVtaXQoJ3Rlc3QgZW5kJywgdGVzdCk7XFxuICAgICAgICBzZWxmLmhvb2tVcCgnYWZ0ZXJFYWNoJywgbmV4dCk7XFxuICAgICAgfSk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgdGhpcy5uZXh0ID0gbmV4dDtcXG4gIHRoaXMuaG9va0VyciA9IGhvb2tFcnI7XFxuICBuZXh0KCk7XFxufTtcXG5cXG5mdW5jdGlvbiBhbHdheXNGYWxzZSgpIHtcXG4gIHJldHVybiBmYWxzZTtcXG59XFxuXFxuLyoqXFxuICogUnVuIHRoZSBnaXZlbiBgc3VpdGVgIGFuZCBpbnZva2UgdGhlIGNhbGxiYWNrIGBmbigpYCB3aGVuIGNvbXBsZXRlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUucnVuU3VpdGUgPSBmdW5jdGlvbihzdWl0ZSwgZm4pIHtcXG4gIHZhciBpID0gMDtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB0b3RhbCA9IHRoaXMuZ3JlcFRvdGFsKHN1aXRlKTtcXG4gIHZhciBhZnRlckFsbEhvb2tDYWxsZWQgPSBmYWxzZTtcXG5cXG4gIGRlYnVnKCdydW4gc3VpdGUgJXMnLCBzdWl0ZS5mdWxsVGl0bGUoKSk7XFxuXFxuICBpZiAoIXRvdGFsIHx8IChzZWxmLmZhaWx1cmVzICYmIHN1aXRlLl9iYWlsKSkge1xcbiAgICByZXR1cm4gZm4oKTtcXG4gIH1cXG5cXG4gIHRoaXMuZW1pdCgnc3VpdGUnLCAodGhpcy5zdWl0ZSA9IHN1aXRlKSk7XFxuXFxuICBmdW5jdGlvbiBuZXh0KGVyclN1aXRlKSB7XFxuICAgIGlmIChlcnJTdWl0ZSkge1xcbiAgICAgIC8vIGN1cnJlbnQgc3VpdGUgZmFpbGVkIG9uIGEgaG9vayBmcm9tIGVyclN1aXRlXFxuICAgICAgaWYgKGVyclN1aXRlID09PSBzdWl0ZSkge1xcbiAgICAgICAgLy8gaWYgZXJyU3VpdGUgaXMgY3VycmVudCBzdWl0ZVxcbiAgICAgICAgLy8gY29udGludWUgdG8gdGhlIG5leHQgc2libGluZyBzdWl0ZVxcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcXG4gICAgICB9XFxuICAgICAgLy8gZXJyU3VpdGUgaXMgYW1vbmcgdGhlIHBhcmVudHMgb2YgY3VycmVudCBzdWl0ZVxcbiAgICAgIC8vIHN0b3AgZXhlY3V0aW9uIG9mIGVyclN1aXRlIGFuZCBhbGwgc3ViLXN1aXRlc1xcbiAgICAgIHJldHVybiBkb25lKGVyclN1aXRlKTtcXG4gICAgfVxcblxcbiAgICBpZiAoc2VsZi5fYWJvcnQpIHtcXG4gICAgICByZXR1cm4gZG9uZSgpO1xcbiAgICB9XFxuXFxuICAgIHZhciBjdXJyID0gc3VpdGUuc3VpdGVzW2krK107XFxuICAgIGlmICghY3Vycikge1xcbiAgICAgIHJldHVybiBkb25lKCk7XFxuICAgIH1cXG5cXG4gICAgLy8gQXZvaWQgZ3JlcCBuZWdsZWN0aW5nIGxhcmdlIG51bWJlciBvZiB0ZXN0cyBjYXVzaW5nIGFcXG4gICAgLy8gaHVnZSByZWN1cnNpdmUgbG9vcCBhbmQgdGh1cyBhIG1heGltdW0gY2FsbCBzdGFjayBlcnJvci5cXG4gICAgLy8gU2VlIGNvbW1lbnQgaW4gYHRoaXMucnVuVGVzdHMoKWAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXFxuICAgIGlmIChzZWxmLl9ncmVwICE9PSBzZWxmLl9kZWZhdWx0R3JlcCkge1xcbiAgICAgIFJ1bm5lci5pbW1lZGlhdGVseShmdW5jdGlvbigpIHtcXG4gICAgICAgIHNlbGYucnVuU3VpdGUoY3VyciwgbmV4dCk7XFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc2VsZi5ydW5TdWl0ZShjdXJyLCBuZXh0KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZG9uZShlcnJTdWl0ZSkge1xcbiAgICBzZWxmLnN1aXRlID0gc3VpdGU7XFxuICAgIHNlbGYubmV4dFN1aXRlID0gbmV4dDtcXG5cXG4gICAgaWYgKGFmdGVyQWxsSG9va0NhbGxlZCkge1xcbiAgICAgIGZuKGVyclN1aXRlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBtYXJrIHRoYXQgdGhlIGFmdGVyQWxsIGJsb2NrIGhhcyBiZWVuIGNhbGxlZCBvbmNlXFxuICAgICAgLy8gYW5kIHNvIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGlzIGFuIGVycm9yIGluIGl0LlxcbiAgICAgIGFmdGVyQWxsSG9va0NhbGxlZCA9IHRydWU7XFxuXFxuICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byB0ZXN0XFxuICAgICAgZGVsZXRlIHNlbGYudGVzdDtcXG5cXG4gICAgICBzZWxmLmhvb2soJ2FmdGVyQWxsJywgZnVuY3Rpb24oKSB7XFxuICAgICAgICBzZWxmLmVtaXQoJ3N1aXRlIGVuZCcsIHN1aXRlKTtcXG4gICAgICAgIGZuKGVyclN1aXRlKTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdGhpcy5uZXh0U3VpdGUgPSBuZXh0O1xcblxcbiAgdGhpcy5ob29rKCdiZWZvcmVBbGwnLCBmdW5jdGlvbihlcnIpIHtcXG4gICAgaWYgKGVycikge1xcbiAgICAgIHJldHVybiBkb25lKCk7XFxuICAgIH1cXG4gICAgc2VsZi5ydW5UZXN0cyhzdWl0ZSwgbmV4dCk7XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEhhbmRsZSB1bmNhdWdodCBleGNlcHRpb25zLlxcbiAqXFxuICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS51bmNhdWdodCA9IGZ1bmN0aW9uKGVycikge1xcbiAgaWYgKGVycikge1xcbiAgICBkZWJ1ZyhcXG4gICAgICAndW5jYXVnaHQgZXhjZXB0aW9uICVzJyxcXG4gICAgICBlcnIgPT09XFxuICAgICAgZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICB9LmNhbGwoZXJyKVxcbiAgICAgICAgPyBlcnIubWVzc2FnZSB8fCBlcnJcXG4gICAgICAgIDogZXJyXFxuICAgICk7XFxuICB9IGVsc2Uge1xcbiAgICBkZWJ1ZygndW5jYXVnaHQgdW5kZWZpbmVkIGV4Y2VwdGlvbicpO1xcbiAgICBlcnIgPSB1bmRlZmluZWRFcnJvcigpO1xcbiAgfVxcbiAgZXJyLnVuY2F1Z2h0ID0gdHJ1ZTtcXG5cXG4gIHZhciBydW5uYWJsZSA9IHRoaXMuY3VycmVudFJ1bm5hYmxlO1xcblxcbiAgaWYgKCFydW5uYWJsZSkge1xcbiAgICBydW5uYWJsZSA9IG5ldyBSdW5uYWJsZSgnVW5jYXVnaHQgZXJyb3Igb3V0c2lkZSB0ZXN0IHN1aXRlJyk7XFxuICAgIHJ1bm5hYmxlLnBhcmVudCA9IHRoaXMuc3VpdGU7XFxuXFxuICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcXG4gICAgICB0aGlzLmZhaWwocnVubmFibGUsIGVycik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gQ2FuJ3QgcmVjb3ZlciBmcm9tIHRoaXMgZmFpbHVyZVxcbiAgICAgIHRoaXMuZW1pdCgnc3RhcnQnKTtcXG4gICAgICB0aGlzLmZhaWwocnVubmFibGUsIGVycik7XFxuICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBydW5uYWJsZS5jbGVhclRpbWVvdXQoKTtcXG5cXG4gIC8vIElnbm9yZSBlcnJvcnMgaWYgYWxyZWFkeSBmYWlsZWQgb3IgcGVuZGluZ1xcbiAgLy8gU2VlICMzMjI2XFxuICBpZiAocnVubmFibGUuaXNGYWlsZWQoKSB8fCBydW5uYWJsZS5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICAvLyB3ZSBjYW5ub3QgcmVjb3ZlciBncmFjZWZ1bGx5IGlmIGEgUnVubmFibGUgaGFzIGFscmVhZHkgcGFzc2VkXFxuICAvLyB0aGVuIGZhaWxzIGFzeW5jaHJvbm91c2x5XFxuICB2YXIgYWxyZWFkeVBhc3NlZCA9IHJ1bm5hYmxlLmlzUGFzc2VkKCk7XFxuICAvLyB0aGlzIHdpbGwgY2hhbmdlIHRoZSBzdGF0ZSB0byBcXFwiZmFpbGVkXFxcIiByZWdhcmRsZXNzIG9mIHRoZSBjdXJyZW50IHZhbHVlXFxuICB0aGlzLmZhaWwocnVubmFibGUsIGVycik7XFxuICBpZiAoIWFscmVhZHlQYXNzZWQpIHtcXG4gICAgLy8gcmVjb3ZlciBmcm9tIHRlc3RcXG4gICAgaWYgKHJ1bm5hYmxlLnR5cGUgPT09ICd0ZXN0Jykge1xcbiAgICAgIHRoaXMuZW1pdCgndGVzdCBlbmQnLCBydW5uYWJsZSk7XFxuICAgICAgdGhpcy5ob29rVXAoJ2FmdGVyRWFjaCcsIHRoaXMubmV4dCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIHJlY292ZXIgZnJvbSBob29rc1xcbiAgICB2YXIgZXJyU3VpdGUgPSB0aGlzLnN1aXRlO1xcbiAgICAvLyBpZiBob29rIGZhaWx1cmUgaXMgaW4gYWZ0ZXJFYWNoIGJsb2NrXFxuICAgIGlmIChydW5uYWJsZS5mdWxsVGl0bGUoKS5pbmRleE9mKCdhZnRlciBlYWNoJykgPiAtMSkge1xcbiAgICAgIHJldHVybiB0aGlzLmhvb2tFcnIoZXJyLCBlcnJTdWl0ZSwgdHJ1ZSk7XFxuICAgIH1cXG4gICAgLy8gaWYgaG9vayBmYWlsdXJlIGlzIGluIGJlZm9yZUVhY2ggYmxvY2tcXG4gICAgaWYgKHJ1bm5hYmxlLmZ1bGxUaXRsZSgpLmluZGV4T2YoJ2JlZm9yZSBlYWNoJykgPiAtMSkge1xcbiAgICAgIHJldHVybiB0aGlzLmhvb2tFcnIoZXJyLCBlcnJTdWl0ZSwgZmFsc2UpO1xcbiAgICB9XFxuICAgIC8vIGlmIGhvb2sgZmFpbHVyZSBpcyBpbiBhZnRlciBvciBiZWZvcmUgYmxvY2tzXFxuICAgIHJldHVybiB0aGlzLm5leHRTdWl0ZShlcnJTdWl0ZSk7XFxuICB9XFxuXFxuICAvLyBiYWlsXFxuICB0aGlzLmVtaXQoJ2VuZCcpO1xcbn07XFxuXFxuLyoqXFxuICogQ2xlYW5zIHVwIHRoZSByZWZlcmVuY2VzIHRvIGFsbCB0aGUgZGVmZXJyZWQgZnVuY3Rpb25zXFxuICogKGJlZm9yZS9hZnRlci9iZWZvcmVFYWNoL2FmdGVyRWFjaCkgYW5kIHRlc3RzIG9mIGEgU3VpdGUuXFxuICogVGhlc2UgbXVzdCBiZSBkZWxldGVkIG90aGVyd2lzZSBhIG1lbW9yeSBsZWFrIGNhbiBoYXBwZW4sXFxuICogYXMgdGhvc2UgZnVuY3Rpb25zIG1heSByZWZlcmVuY2UgdmFyaWFibGVzIGZyb20gY2xvc3VyZXMsXFxuICogdGh1cyB0aG9zZSB2YXJpYWJsZXMgY2FuIG5ldmVyIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGFzIGxvbmdcXG4gKiBhcyB0aGUgZGVmZXJyZWQgZnVuY3Rpb25zIGV4aXN0LlxcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKi9cXG5mdW5jdGlvbiBjbGVhblN1aXRlUmVmZXJlbmNlcyhzdWl0ZSkge1xcbiAgZnVuY3Rpb24gY2xlYW5BcnJSZWZlcmVuY2VzKGFycikge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcbiAgICAgIGRlbGV0ZSBhcnJbaV0uZm47XFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmIChBcnJheS5pc0FycmF5KHN1aXRlLl9iZWZvcmVBbGwpKSB7XFxuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyhzdWl0ZS5fYmVmb3JlQWxsKTtcXG4gIH1cXG5cXG4gIGlmIChBcnJheS5pc0FycmF5KHN1aXRlLl9iZWZvcmVFYWNoKSkge1xcbiAgICBjbGVhbkFyclJlZmVyZW5jZXMoc3VpdGUuX2JlZm9yZUVhY2gpO1xcbiAgfVxcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3VpdGUuX2FmdGVyQWxsKSkge1xcbiAgICBjbGVhbkFyclJlZmVyZW5jZXMoc3VpdGUuX2FmdGVyQWxsKTtcXG4gIH1cXG5cXG4gIGlmIChBcnJheS5pc0FycmF5KHN1aXRlLl9hZnRlckVhY2gpKSB7XFxuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyhzdWl0ZS5fYWZ0ZXJFYWNoKTtcXG4gIH1cXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3VpdGUudGVzdHMubGVuZ3RoOyBpKyspIHtcXG4gICAgZGVsZXRlIHN1aXRlLnRlc3RzW2ldLmZuO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBSdW4gdGhlIHJvb3Qgc3VpdGUgYW5kIGludm9rZSBgZm4oZmFpbHVyZXMpYFxcbiAqIG9uIGNvbXBsZXRpb24uXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmVyXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgcm9vdFN1aXRlID0gdGhpcy5zdWl0ZTtcXG5cXG4gIGZuID0gZm4gfHwgZnVuY3Rpb24oKSB7fTtcXG5cXG4gIGZ1bmN0aW9uIHVuY2F1Z2h0KGVycikge1xcbiAgICBzZWxmLnVuY2F1Z2h0KGVycik7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBzdGFydCgpIHtcXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gYG9ubHlgIGZpbHRlclxcbiAgICBpZiAoaGFzT25seShyb290U3VpdGUpKSB7XFxuICAgICAgZmlsdGVyT25seShyb290U3VpdGUpO1xcbiAgICB9XFxuICAgIHNlbGYuc3RhcnRlZCA9IHRydWU7XFxuICAgIHNlbGYuZW1pdCgnc3RhcnQnKTtcXG4gICAgc2VsZi5ydW5TdWl0ZShyb290U3VpdGUsIGZ1bmN0aW9uKCkge1xcbiAgICAgIGRlYnVnKCdmaW5pc2hlZCBydW5uaW5nJyk7XFxuICAgICAgc2VsZi5lbWl0KCdlbmQnKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBkZWJ1Zygnc3RhcnQnKTtcXG5cXG4gIC8vIHJlZmVyZW5jZXMgY2xlYW51cCB0byBhdm9pZCBtZW1vcnkgbGVha3NcXG4gIHRoaXMub24oJ3N1aXRlIGVuZCcsIGNsZWFuU3VpdGVSZWZlcmVuY2VzKTtcXG5cXG4gIC8vIGNhbGxiYWNrXFxuICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgZGVidWcoJ2VuZCcpO1xcbiAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCd1bmNhdWdodEV4Y2VwdGlvbicsIHVuY2F1Z2h0KTtcXG4gICAgZm4oc2VsZi5mYWlsdXJlcyk7XFxuICB9KTtcXG5cXG4gIC8vIHVuY2F1Z2h0IGV4Y2VwdGlvblxcbiAgcHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCB1bmNhdWdodCk7XFxuXFxuICBpZiAodGhpcy5fZGVsYXkpIHtcXG4gICAgLy8gZm9yIHJlcG9ydGVycywgSSBndWVzcy5cXG4gICAgLy8gbWlnaHQgYmUgbmljZSB0byBkZWJvdW5jZSBzb21lIGRvdHMgd2hpbGUgd2Ugd2FpdC5cXG4gICAgdGhpcy5lbWl0KCd3YWl0aW5nJywgcm9vdFN1aXRlKTtcXG4gICAgcm9vdFN1aXRlLm9uY2UoJ3J1bicsIHN0YXJ0KTtcXG4gIH0gZWxzZSB7XFxuICAgIHN0YXJ0KCk7XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIENsZWFubHkgYWJvcnQgZXhlY3V0aW9uLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhLlJ1bm5lclxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEByZXR1cm4ge1J1bm5lcn0gUnVubmVyIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcXG4gIGRlYnVnKCdhYm9ydGluZycpO1xcbiAgdGhpcy5fYWJvcnQgPSB0cnVlO1xcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBGaWx0ZXIgc3VpdGVzIGJhc2VkIG9uIGBpc09ubHlgIGxvZ2ljLlxcbiAqXFxuICogQHBhcmFtIHtBcnJheX0gc3VpdGVcXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5mdW5jdGlvbiBmaWx0ZXJPbmx5KHN1aXRlKSB7XFxuICBpZiAoc3VpdGUuX29ubHlUZXN0cy5sZW5ndGgpIHtcXG4gICAgLy8gSWYgdGhlIHN1aXRlIGNvbnRhaW5zIGBvbmx5YCB0ZXN0cywgcnVuIHRob3NlIGFuZCBpZ25vcmUgYW55IG5lc3RlZCBzdWl0ZXMuXFxuICAgIHN1aXRlLnRlc3RzID0gc3VpdGUuX29ubHlUZXN0cztcXG4gICAgc3VpdGUuc3VpdGVzID0gW107XFxuICB9IGVsc2Uge1xcbiAgICAvLyBPdGhlcndpc2UsIGRvIG5vdCBydW4gYW55IG9mIHRoZSB0ZXN0cyBpbiB0aGlzIHN1aXRlLlxcbiAgICBzdWl0ZS50ZXN0cyA9IFtdO1xcbiAgICBzdWl0ZS5fb25seVN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uKG9ubHlTdWl0ZSkge1xcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBvdGhlciBgb25seWAgdGVzdHMvc3VpdGVzIG5lc3RlZCBpbiB0aGUgY3VycmVudCBgb25seWAgc3VpdGUsIHRoZW4gZmlsdGVyIHRoYXQgYG9ubHlgIHN1aXRlLlxcbiAgICAgIC8vIE90aGVyd2lzZSwgYWxsIG9mIHRoZSB0ZXN0cyBvbiB0aGlzIGBvbmx5YCBzdWl0ZSBzaG91bGQgYmUgcnVuLCBzbyBkb24ndCBmaWx0ZXIgaXQuXFxuICAgICAgaWYgKGhhc09ubHkob25seVN1aXRlKSkge1xcbiAgICAgICAgZmlsdGVyT25seShvbmx5U3VpdGUpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICAgIC8vIFJ1biB0aGUgYG9ubHlgIHN1aXRlcywgYXMgd2VsbCBhcyBhbnkgb3RoZXIgc3VpdGVzIHRoYXQgaGF2ZSBgb25seWAgdGVzdHMvc3VpdGVzIGFzIGRlc2NlbmRhbnRzLlxcbiAgICBzdWl0ZS5zdWl0ZXMgPSBzdWl0ZS5zdWl0ZXMuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkU3VpdGUpIHtcXG4gICAgICByZXR1cm4gKFxcbiAgICAgICAgc3VpdGUuX29ubHlTdWl0ZXMuaW5kZXhPZihjaGlsZFN1aXRlKSAhPT0gLTEgfHwgZmlsdGVyT25seShjaGlsZFN1aXRlKVxcbiAgICAgICk7XFxuICAgIH0pO1xcbiAgfVxcbiAgLy8gS2VlcCB0aGUgc3VpdGUgb25seSBpZiB0aGVyZSBpcyBzb21ldGhpbmcgdG8gcnVuXFxuICByZXR1cm4gc3VpdGUudGVzdHMubGVuZ3RoIHx8IHN1aXRlLnN1aXRlcy5sZW5ndGg7XFxufVxcblxcbi8qKlxcbiAqIERldGVybWluZXMgd2hldGhlciBhIHN1aXRlIGhhcyBhbiBgb25seWAgdGVzdCBvciBzdWl0ZSBhcyBhIGRlc2NlbmRhbnQuXFxuICpcXG4gKiBAcGFyYW0ge0FycmF5fSBzdWl0ZVxcbiAqIEByZXR1cm5zIHtCb29sZWFufVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbmZ1bmN0aW9uIGhhc09ubHkoc3VpdGUpIHtcXG4gIHJldHVybiAoXFxuICAgIHN1aXRlLl9vbmx5VGVzdHMubGVuZ3RoIHx8XFxuICAgIHN1aXRlLl9vbmx5U3VpdGVzLmxlbmd0aCB8fFxcbiAgICBzdWl0ZS5zdWl0ZXMuc29tZShoYXNPbmx5KVxcbiAgKTtcXG59XFxuXFxuLyoqXFxuICogRmlsdGVyIGxlYWtzIHdpdGggdGhlIGdpdmVuIGdsb2JhbHMgZmxhZ2dlZCBhcyBgb2tgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtBcnJheX0gb2tcXG4gKiBAcGFyYW0ge0FycmF5fSBnbG9iYWxzXFxuICogQHJldHVybiB7QXJyYXl9XFxuICovXFxuZnVuY3Rpb24gZmlsdGVyTGVha3Mob2ssIGdsb2JhbHMpIHtcXG4gIHJldHVybiBnbG9iYWxzLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcXG4gICAgLy8gRmlyZWZveCBhbmQgQ2hyb21lIGV4cG9zZXMgaWZyYW1lcyBhcyBpbmRleCBpbnNpZGUgdGhlIHdpbmRvdyBvYmplY3RcXG4gICAgaWYgKC9eXFxcXGQrLy50ZXN0KGtleSkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgLy8gaW4gZmlyZWZveFxcbiAgICAvLyBpZiBydW5uZXIgcnVucyBpbiBhbiBpZnJhbWUsIHRoaXMgaWZyYW1lJ3Mgd2luZG93LmdldEludGVyZmFjZSBtZXRob2RcXG4gICAgLy8gbm90IGluaXQgYXQgZmlyc3QgaXQgaXMgYXNzaWduZWQgaW4gc29tZSBzZWNvbmRzXFxuICAgIGlmIChnbG9iYWwubmF2aWdhdG9yICYmIC9eZ2V0SW50ZXJmYWNlLy50ZXN0KGtleSkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgLy8gYW4gaWZyYW1lIGNvdWxkIGJlIGFwcHJvYWNoZWQgYnkgd2luZG93W2lmcmFtZUluZGV4XVxcbiAgICAvLyBpbiBpZTYsNyw4IGFuZCBvcGVyYSwgaWZyYW1lSW5kZXggaXMgZW51bWVyYWJsZSwgdGhpcyBjb3VsZCBjYXVzZSBsZWFrXFxuICAgIGlmIChnbG9iYWwubmF2aWdhdG9yICYmIC9eXFxcXGQrLy50ZXN0KGtleSkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgLy8gT3BlcmEgYW5kIElFIGV4cG9zZSBnbG9iYWwgdmFyaWFibGVzIGZvciBIVE1MIGVsZW1lbnQgSURzIChpc3N1ZSAjMjQzKVxcbiAgICBpZiAoL15tb2NoYS0vLnRlc3Qoa2V5KSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICB2YXIgbWF0Y2hlZCA9IG9rLmZpbHRlcihmdW5jdGlvbihvaykge1xcbiAgICAgIGlmICh+b2suaW5kZXhPZignKicpKSB7XFxuICAgICAgICByZXR1cm4ga2V5LmluZGV4T2Yob2suc3BsaXQoJyonKVswXSkgPT09IDA7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBrZXkgPT09IG9rO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuICFtYXRjaGVkLmxlbmd0aCAmJiAoIWdsb2JhbC5uYXZpZ2F0b3IgfHwga2V5ICE9PSAnb25lcnJvcicpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEFycmF5IG9mIGdsb2JhbHMgZGVwZW5kZW50IG9uIHRoZSBlbnZpcm9ubWVudC5cXG4gKlxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbmZ1bmN0aW9uIGV4dHJhR2xvYmFscygpIHtcXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcXG4gICAgdmFyIHBhcnRzID0gcHJvY2Vzcy52ZXJzaW9uLnNwbGl0KCcuJyk7XFxuICAgIHZhciBub2RlVmVyc2lvbiA9IHBhcnRzLnJlZHVjZShmdW5jdGlvbihhLCB2KSB7XFxuICAgICAgcmV0dXJuIChhIDw8IDgpIHwgdjtcXG4gICAgfSk7XFxuXFxuICAgIC8vICdlcnJubycgd2FzIHJlbmFtZWQgdG8gcHJvY2Vzcy5fZXJybm8gaW4gdjAuOS4xMS5cXG5cXG4gICAgaWYgKG5vZGVWZXJzaW9uIDwgMHgwMDA5MGIpIHtcXG4gICAgICByZXR1cm4gWydlcnJubyddO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gW107XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4vcGVuZGluZ1xcXCI6MTUsXFxcIi4vcnVubmFibGVcXFwiOjMyLFxcXCIuL3V0aWxzXFxcIjozNixcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJkZWJ1Z1xcXCI6NDMsXFxcImV2ZW50c1xcXCI6NDd9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgU3VpdGVcXG4gKi9cXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxudmFyIEhvb2sgPSByZXF1aXJlKCcuL2hvb2snKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XFxudmFyIGluaGVyaXRzID0gdXRpbHMuaW5oZXJpdHM7XFxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6c3VpdGUnKTtcXG52YXIgbWlsbGlzZWNvbmRzID0gcmVxdWlyZSgnLi9tcycpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgU3VpdGVgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFN1aXRlO1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyBgU3VpdGVgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIHBhcmVudCBgU3VpdGVgLiBXaGVuIGEgc3VpdGVcXG4gKiB3aXRoIHRoZSBzYW1lIHRpdGxlIGlzIGFscmVhZHkgcHJlc2VudCwgdGhhdCBzdWl0ZSBpcyByZXR1cm5lZCB0byBwcm92aWRlXFxuICogbmljZXIgcmVwb3J0ZXIgYW5kIG1vcmUgZmxleGlibGUgbWV0YS10ZXN0aW5nLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtTdWl0ZX0gcGFyZW50XFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICogQHJldHVybiB7U3VpdGV9XFxuICovXFxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbihwYXJlbnQsIHRpdGxlKSB7XFxuICB2YXIgc3VpdGUgPSBuZXcgU3VpdGUodGl0bGUsIHBhcmVudC5jdHgpO1xcbiAgc3VpdGUucGFyZW50ID0gcGFyZW50O1xcbiAgdGl0bGUgPSBzdWl0ZS5mdWxsVGl0bGUoKTtcXG4gIHBhcmVudC5hZGRTdWl0ZShzdWl0ZSk7XFxuICByZXR1cm4gc3VpdGU7XFxufTtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBTdWl0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgYGN0eGAuIERlcml2ZWQgZnJvbSBbRXZlbnRFbWl0dGVyXShodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19jbGFzc19ldmVudGVtaXR0ZXIpXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGFcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtDb250ZXh0fSBwYXJlbnRDb250ZXh0XFxuICovXFxuZnVuY3Rpb24gU3VpdGUodGl0bGUsIHBhcmVudENvbnRleHQpIHtcXG4gIGlmICghdXRpbHMuaXNTdHJpbmcodGl0bGUpKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcihcXG4gICAgICAnU3VpdGUgYHRpdGxlYCBzaG91bGQgYmUgYSBcXFwic3RyaW5nXFxcIiBidXQgXFxcIicgK1xcbiAgICAgICAgdHlwZW9mIHRpdGxlICtcXG4gICAgICAgICdcXFwiIHdhcyBnaXZlbiBpbnN0ZWFkLidcXG4gICAgKTtcXG4gIH1cXG4gIHRoaXMudGl0bGUgPSB0aXRsZTtcXG4gIGZ1bmN0aW9uIENvbnRleHQoKSB7fVxcbiAgQ29udGV4dC5wcm90b3R5cGUgPSBwYXJlbnRDb250ZXh0O1xcbiAgdGhpcy5jdHggPSBuZXcgQ29udGV4dCgpO1xcbiAgdGhpcy5zdWl0ZXMgPSBbXTtcXG4gIHRoaXMudGVzdHMgPSBbXTtcXG4gIHRoaXMucGVuZGluZyA9IGZhbHNlO1xcbiAgdGhpcy5fYmVmb3JlRWFjaCA9IFtdO1xcbiAgdGhpcy5fYmVmb3JlQWxsID0gW107XFxuICB0aGlzLl9hZnRlckVhY2ggPSBbXTtcXG4gIHRoaXMuX2FmdGVyQWxsID0gW107XFxuICB0aGlzLnJvb3QgPSAhdGl0bGU7XFxuICB0aGlzLl90aW1lb3V0ID0gMjAwMDtcXG4gIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gdHJ1ZTtcXG4gIHRoaXMuX3Nsb3cgPSA3NTtcXG4gIHRoaXMuX2JhaWwgPSBmYWxzZTtcXG4gIHRoaXMuX3JldHJpZXMgPSAtMTtcXG4gIHRoaXMuX29ubHlUZXN0cyA9IFtdO1xcbiAgdGhpcy5fb25seVN1aXRlcyA9IFtdO1xcbiAgdGhpcy5kZWxheWVkID0gZmFsc2U7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgRXZlbnRFbWl0dGVyLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoU3VpdGUsIEV2ZW50RW1pdHRlcik7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgY2xvbmUgb2YgdGhpcyBgU3VpdGVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHJldHVybiB7U3VpdGV9XFxuICovXFxuU3VpdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgc3VpdGUgPSBuZXcgU3VpdGUodGhpcy50aXRsZSk7XFxuICBkZWJ1ZygnY2xvbmUnKTtcXG4gIHN1aXRlLmN0eCA9IHRoaXMuY3R4O1xcbiAgc3VpdGUudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICBzdWl0ZS5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcXG4gIHN1aXRlLmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICBzdWl0ZS5zbG93KHRoaXMuc2xvdygpKTtcXG4gIHN1aXRlLmJhaWwodGhpcy5iYWlsKCkpO1xcbiAgcmV0dXJuIHN1aXRlO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IG9yIGdldCB0aW1lb3V0IGBtc2Agb3Igc2hvcnQtaGFuZCBzdWNoIGFzIFxcXCIyc1xcXCIuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zXFxuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uKG1zKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XFxuICB9XFxuICBpZiAobXMudG9TdHJpbmcoKSA9PT0gJzAnKSB7XFxuICAgIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gZmFsc2U7XFxuICB9XFxuICBpZiAodHlwZW9mIG1zID09PSAnc3RyaW5nJykge1xcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XFxuICB9XFxuICBkZWJ1ZygndGltZW91dCAlZCcsIG1zKTtcXG4gIHRoaXMuX3RpbWVvdXQgPSBwYXJzZUludChtcywgMTApO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IG51bWJlciBvZiB0aW1lcyB0byByZXRyeSBhIGZhaWxlZCB0ZXN0LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBuXFxuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUucmV0cmllcyA9IGZ1bmN0aW9uKG4pIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fcmV0cmllcztcXG4gIH1cXG4gIGRlYnVnKCdyZXRyaWVzICVkJywgbik7XFxuICB0aGlzLl9yZXRyaWVzID0gcGFyc2VJbnQobiwgMTApIHx8IDA7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgdGltZW91dCB0byBgZW5hYmxlZGAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcXG4gKiBAcmV0dXJuIHtTdWl0ZXxib29sZWFufSBzZWxmIG9yIGVuYWJsZWRcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuZW5hYmxlVGltZW91dHMgPSBmdW5jdGlvbihlbmFibGVkKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZVRpbWVvdXRzO1xcbiAgfVxcbiAgZGVidWcoJ2VuYWJsZVRpbWVvdXRzICVzJywgZW5hYmxlZCk7XFxuICB0aGlzLl9lbmFibGVUaW1lb3V0cyA9IGVuYWJsZWQ7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgc2xvdyBgbXNgIG9yIHNob3J0LWhhbmQgc3VjaCBhcyBcXFwiMnNcXFwiLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc1xcbiAqIEByZXR1cm4ge1N1aXRlfG51bWJlcn0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLnNsb3cgPSBmdW5jdGlvbihtcykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9zbG93O1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgbXMgPSBtaWxsaXNlY29uZHMobXMpO1xcbiAgfVxcbiAgZGVidWcoJ3Nsb3cgJWQnLCBtcyk7XFxuICB0aGlzLl9zbG93ID0gbXM7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgd2hldGhlciB0byBiYWlsIGFmdGVyIGZpcnN0IGVycm9yLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtib29sZWFufSBiYWlsXFxuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYmFpbCA9IGZ1bmN0aW9uKGJhaWwpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fYmFpbDtcXG4gIH1cXG4gIGRlYnVnKCdiYWlsICVzJywgYmFpbCk7XFxuICB0aGlzLl9iYWlsID0gYmFpbDtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdGhpcyBzdWl0ZSBvciBpdHMgcGFyZW50IHN1aXRlIGlzIG1hcmtlZCBhcyBwZW5kaW5nLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uKCkge1xcbiAgcmV0dXJuIHRoaXMucGVuZGluZyB8fCAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNQZW5kaW5nKCkpO1xcbn07XFxuXFxuLyoqXFxuICogR2VuZXJpYyBob29rLWNyZWF0b3IuXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGUgLSBUaXRsZSBvZiBob29rXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBIb29rIGNhbGxiYWNrXFxuICogQHJldHVybnMge0hvb2t9IEEgbmV3IGhvb2tcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuX2NyZWF0ZUhvb2sgPSBmdW5jdGlvbih0aXRsZSwgZm4pIHtcXG4gIHZhciBob29rID0gbmV3IEhvb2sodGl0bGUsIGZuKTtcXG4gIGhvb2sucGFyZW50ID0gdGhpcztcXG4gIGhvb2sudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICBob29rLnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgaG9vay5lbmFibGVUaW1lb3V0cyh0aGlzLmVuYWJsZVRpbWVvdXRzKCkpO1xcbiAgaG9vay5zbG93KHRoaXMuc2xvdygpKTtcXG4gIGhvb2suY3R4ID0gdGhpcy5jdHg7XFxuICBob29rLmZpbGUgPSB0aGlzLmZpbGU7XFxuICByZXR1cm4gaG9vaztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBgZm4odGVzdFssIGRvbmVdKWAgYmVmb3JlIHJ1bm5pbmcgdGVzdHMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYmVmb3JlQWxsID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZm4gPSB0aXRsZTtcXG4gICAgdGl0bGUgPSBmbi5uYW1lO1xcbiAgfVxcbiAgdGl0bGUgPSAnXFxcImJlZm9yZSBhbGxcXFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xcblxcbiAgdmFyIGhvb2sgPSB0aGlzLl9jcmVhdGVIb29rKHRpdGxlLCBmbik7XFxuICB0aGlzLl9iZWZvcmVBbGwucHVzaChob29rKTtcXG4gIHRoaXMuZW1pdCgnYmVmb3JlQWxsJywgaG9vayk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBgZm4odGVzdFssIGRvbmVdKWAgYWZ0ZXIgcnVubmluZyB0ZXN0cy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5hZnRlckFsbCA9IGZ1bmN0aW9uKHRpdGxlLCBmbikge1xcbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGZuID0gdGl0bGU7XFxuICAgIHRpdGxlID0gZm4ubmFtZTtcXG4gIH1cXG4gIHRpdGxlID0gJ1xcXCJhZnRlciBhbGxcXFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xcblxcbiAgdmFyIGhvb2sgPSB0aGlzLl9jcmVhdGVIb29rKHRpdGxlLCBmbik7XFxuICB0aGlzLl9hZnRlckFsbC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdhZnRlckFsbCcsIGhvb2spO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gYGZuKHRlc3RbLCBkb25lXSlgIGJlZm9yZSBlYWNoIHRlc3QgY2FzZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZm4gPSB0aXRsZTtcXG4gICAgdGl0bGUgPSBmbi5uYW1lO1xcbiAgfVxcbiAgdGl0bGUgPSAnXFxcImJlZm9yZSBlYWNoXFxcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcXG5cXG4gIHZhciBob29rID0gdGhpcy5fY3JlYXRlSG9vayh0aXRsZSwgZm4pO1xcbiAgdGhpcy5fYmVmb3JlRWFjaC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdiZWZvcmVFYWNoJywgaG9vayk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBgZm4odGVzdFssIGRvbmVdKWAgYWZ0ZXIgZWFjaCB0ZXN0IGNhc2UuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZm4gPSB0aXRsZTtcXG4gICAgdGl0bGUgPSBmbi5uYW1lO1xcbiAgfVxcbiAgdGl0bGUgPSAnXFxcImFmdGVyIGVhY2hcXFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xcblxcbiAgdmFyIGhvb2sgPSB0aGlzLl9jcmVhdGVIb29rKHRpdGxlLCBmbik7XFxuICB0aGlzLl9hZnRlckVhY2gucHVzaChob29rKTtcXG4gIHRoaXMuZW1pdCgnYWZ0ZXJFYWNoJywgaG9vayk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEFkZCBhIHRlc3QgYHN1aXRlYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5hZGRTdWl0ZSA9IGZ1bmN0aW9uKHN1aXRlKSB7XFxuICBzdWl0ZS5wYXJlbnQgPSB0aGlzO1xcbiAgc3VpdGUudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICBzdWl0ZS5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcXG4gIHN1aXRlLmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICBzdWl0ZS5zbG93KHRoaXMuc2xvdygpKTtcXG4gIHN1aXRlLmJhaWwodGhpcy5iYWlsKCkpO1xcbiAgdGhpcy5zdWl0ZXMucHVzaChzdWl0ZSk7XFxuICB0aGlzLmVtaXQoJ3N1aXRlJywgc3VpdGUpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBBZGQgYSBgdGVzdGAgdG8gdGhpcyBzdWl0ZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7VGVzdH0gdGVzdFxcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYWRkVGVzdCA9IGZ1bmN0aW9uKHRlc3QpIHtcXG4gIHRlc3QucGFyZW50ID0gdGhpcztcXG4gIHRlc3QudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICB0ZXN0LnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgdGVzdC5lbmFibGVUaW1lb3V0cyh0aGlzLmVuYWJsZVRpbWVvdXRzKCkpO1xcbiAgdGVzdC5zbG93KHRoaXMuc2xvdygpKTtcXG4gIHRlc3QuY3R4ID0gdGhpcy5jdHg7XFxuICB0aGlzLnRlc3RzLnB1c2godGVzdCk7XFxuICB0aGlzLmVtaXQoJ3Rlc3QnLCB0ZXN0KTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIHRoZSBmdWxsIHRpdGxlIGdlbmVyYXRlZCBieSByZWN1cnNpdmVseSBjb25jYXRlbmF0aW5nIHRoZSBwYXJlbnQnc1xcbiAqIGZ1bGwgdGl0bGUuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEuU3VpdGVcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuU3VpdGUucHJvdG90eXBlLmZ1bGxUaXRsZSA9IGZ1bmN0aW9uKCkge1xcbiAgcmV0dXJuIHRoaXMudGl0bGVQYXRoKCkuam9pbignICcpO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIHRoZSB0aXRsZSBwYXRoIGdlbmVyYXRlZCBieSByZWN1cnNpdmVseSBjb25jYXRlbmF0aW5nIHRoZSBwYXJlbnQnc1xcbiAqIHRpdGxlIHBhdGguXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEuU3VpdGVcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuU3VpdGUucHJvdG90eXBlLnRpdGxlUGF0aCA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHJlc3VsdCA9IFtdO1xcbiAgaWYgKHRoaXMucGFyZW50KSB7XFxuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5wYXJlbnQudGl0bGVQYXRoKCkpO1xcbiAgfVxcbiAgaWYgKCF0aGlzLnJvb3QpIHtcXG4gICAgcmVzdWx0LnB1c2godGhpcy50aXRsZSk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIHRoZSB0b3RhbCBudW1iZXIgb2YgdGVzdHMuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEuU3VpdGVcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9XFxuICovXFxuU3VpdGUucHJvdG90eXBlLnRvdGFsID0gZnVuY3Rpb24oKSB7XFxuICByZXR1cm4gKFxcbiAgICB0aGlzLnN1aXRlcy5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBzdWl0ZSkge1xcbiAgICAgIHJldHVybiBzdW0gKyBzdWl0ZS50b3RhbCgpO1xcbiAgICB9LCAwKSArIHRoaXMudGVzdHMubGVuZ3RoXFxuICApO1xcbn07XFxuXFxuLyoqXFxuICogSXRlcmF0ZXMgdGhyb3VnaCBlYWNoIHN1aXRlIHJlY3Vyc2l2ZWx5IHRvIGZpbmQgYWxsIHRlc3RzLiBBcHBsaWVzIGFcXG4gKiBmdW5jdGlvbiBpbiB0aGUgZm9ybWF0IGBmbih0ZXN0KWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1N1aXRlfVxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5lYWNoVGVzdCA9IGZ1bmN0aW9uKGZuKSB7XFxuICB0aGlzLnRlc3RzLmZvckVhY2goZm4pO1xcbiAgdGhpcy5zdWl0ZXMuZm9yRWFjaChmdW5jdGlvbihzdWl0ZSkge1xcbiAgICBzdWl0ZS5lYWNoVGVzdChmbik7XFxuICB9KTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogVGhpcyB3aWxsIHJ1biB0aGUgcm9vdCBzdWl0ZSBpZiB3ZSBoYXBwZW4gdG8gYmUgcnVubmluZyBpbiBkZWxheWVkIG1vZGUuXFxuICovXFxuU3VpdGUucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1bigpIHtcXG4gIGlmICh0aGlzLnJvb3QpIHtcXG4gICAgdGhpcy5lbWl0KCdydW4nKTtcXG4gIH1cXG59O1xcblxcbn0se1xcXCIuL2hvb2tcXFwiOjYsXFxcIi4vbXNcXFwiOjE0LFxcXCIuL3V0aWxzXFxcIjozNixcXFwiZGVidWdcXFwiOjQzLFxcXCJldmVudHNcXFwiOjQ3fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xcbnZhciBpc1N0cmluZyA9IHV0aWxzLmlzU3RyaW5nO1xcblxcbm1vZHVsZS5leHBvcnRzID0gVGVzdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBUZXN0YCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gLlxcbiAqXFxuICogQGNsYXNzXFxuICogQGV4dGVuZHMgUnVubmFibGVcXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcbmZ1bmN0aW9uIFRlc3QodGl0bGUsIGZuKSB7XFxuICBpZiAoIWlzU3RyaW5nKHRpdGxlKSkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoXFxuICAgICAgJ1Rlc3QgYHRpdGxlYCBzaG91bGQgYmUgYSBcXFwic3RyaW5nXFxcIiBidXQgXFxcIicgK1xcbiAgICAgICAgdHlwZW9mIHRpdGxlICtcXG4gICAgICAgICdcXFwiIHdhcyBnaXZlbiBpbnN0ZWFkLidcXG4gICAgKTtcXG4gIH1cXG4gIFJ1bm5hYmxlLmNhbGwodGhpcywgdGl0bGUsIGZuKTtcXG4gIHRoaXMucGVuZGluZyA9ICFmbjtcXG4gIHRoaXMudHlwZSA9ICd0ZXN0JztcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBSdW5uYWJsZS5wcm90b3R5cGVgLlxcbiAqL1xcbnV0aWxzLmluaGVyaXRzKFRlc3QsIFJ1bm5hYmxlKTtcXG5cXG5UZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHRlc3QgPSBuZXcgVGVzdCh0aGlzLnRpdGxlLCB0aGlzLmZuKTtcXG4gIHRlc3QudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICB0ZXN0LnNsb3codGhpcy5zbG93KCkpO1xcbiAgdGVzdC5lbmFibGVUaW1lb3V0cyh0aGlzLmVuYWJsZVRpbWVvdXRzKCkpO1xcbiAgdGVzdC5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcXG4gIHRlc3QuY3VycmVudFJldHJ5KHRoaXMuY3VycmVudFJldHJ5KCkpO1xcbiAgdGVzdC5nbG9iYWxzKHRoaXMuZ2xvYmFscygpKTtcXG4gIHRlc3QucGFyZW50ID0gdGhpcy5wYXJlbnQ7XFxuICB0ZXN0LmZpbGUgPSB0aGlzLmZpbGU7XFxuICB0ZXN0LmN0eCA9IHRoaXMuY3R4O1xcbiAgcmV0dXJuIHRlc3Q7XFxufTtcXG5cXG59LHtcXFwiLi9ydW5uYWJsZVxcXCI6MzIsXFxcIi4vdXRpbHNcXFwiOjM2fV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxCdWZmZXIpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBAbW9kdWxlXFxuICovXFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTp3YXRjaCcpO1xcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XFxudmFyIGdsb2IgPSByZXF1aXJlKCdnbG9iJyk7XFxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XFxudmFyIGpvaW4gPSBwYXRoLmpvaW47XFxudmFyIGhlID0gcmVxdWlyZSgnaGUnKTtcXG5cXG4vKipcXG4gKiBJZ25vcmVkIGRpcmVjdG9yaWVzLlxcbiAqL1xcblxcbnZhciBpZ25vcmUgPSBbJ25vZGVfbW9kdWxlcycsICcuZ2l0J107XFxuXFxuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcXG5cXG4vKipcXG4gKiBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIHRoZSBnaXZlbiBzdHJpbmcgb2YgaHRtbC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSAge3N0cmluZ30gaHRtbFxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5leHBvcnRzLmVzY2FwZSA9IGZ1bmN0aW9uKGh0bWwpIHtcXG4gIHJldHVybiBoZS5lbmNvZGUoU3RyaW5nKGh0bWwpLCB7dXNlTmFtZWRSZWZlcmVuY2VzOiBmYWxzZX0pO1xcbn07XFxuXFxuLyoqXFxuICogVGVzdCBpZiB0aGUgZ2l2ZW4gb2JqIGlzIHR5cGUgb2Ygc3RyaW5nLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XFxuICovXFxuZXhwb3J0cy5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xcbn07XFxuXFxuLyoqXFxuICogV2F0Y2ggdGhlIGdpdmVuIGBmaWxlc2AgZm9yIGNoYW5nZXNcXG4gKiBhbmQgaW52b2tlIGBmbihmaWxlKWAgb24gbW9kaWZpY2F0aW9uLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtBcnJheX0gZmlsZXNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcbmV4cG9ydHMud2F0Y2ggPSBmdW5jdGlvbihmaWxlcywgZm4pIHtcXG4gIHZhciBvcHRpb25zID0ge2ludGVydmFsOiAxMDB9O1xcbiAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XFxuICAgIGRlYnVnKCdmaWxlICVzJywgZmlsZSk7XFxuICAgIGZzLndhdGNoRmlsZShmaWxlLCBvcHRpb25zLCBmdW5jdGlvbihjdXJyLCBwcmV2KSB7XFxuICAgICAgaWYgKHByZXYubXRpbWUgPCBjdXJyLm10aW1lKSB7XFxuICAgICAgICBmbihmaWxlKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBJZ25vcmVkIGZpbGVzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcXG4gKiBAcmV0dXJuIHtib29sZWFufVxcbiAqL1xcbmZ1bmN0aW9uIGlnbm9yZWQocGF0aCkge1xcbiAgcmV0dXJuICF+aWdub3JlLmluZGV4T2YocGF0aCk7XFxufVxcblxcbi8qKlxcbiAqIExvb2t1cCBmaWxlcyBpbiB0aGUgZ2l2ZW4gYGRpcmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlyXFxuICogQHBhcmFtIHtzdHJpbmdbXX0gW2V4dD1bJy5qcyddXVxcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXQ9W11dXFxuICogQHJldHVybiB7QXJyYXl9XFxuICovXFxuZXhwb3J0cy5maWxlcyA9IGZ1bmN0aW9uKGRpciwgZXh0LCByZXQpIHtcXG4gIHJldCA9IHJldCB8fCBbXTtcXG4gIGV4dCA9IGV4dCB8fCBbJ2pzJ107XFxuXFxuICB2YXIgcmUgPSBuZXcgUmVnRXhwKCdcXFxcXFxcXC4oJyArIGV4dC5qb2luKCd8JykgKyAnKSQnKTtcXG5cXG4gIGZzXFxuICAgIC5yZWFkZGlyU3luYyhkaXIpXFxuICAgIC5maWx0ZXIoaWdub3JlZClcXG4gICAgLmZvckVhY2goZnVuY3Rpb24ocGF0aCkge1xcbiAgICAgIHBhdGggPSBqb2luKGRpciwgcGF0aCk7XFxuICAgICAgaWYgKGZzLmxzdGF0U3luYyhwYXRoKS5pc0RpcmVjdG9yeSgpKSB7XFxuICAgICAgICBleHBvcnRzLmZpbGVzKHBhdGgsIGV4dCwgcmV0KTtcXG4gICAgICB9IGVsc2UgaWYgKHBhdGgubWF0Y2gocmUpKSB7XFxuICAgICAgICByZXQucHVzaChwYXRoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgcmV0dXJuIHJldDtcXG59O1xcblxcbi8qKlxcbiAqIENvbXB1dGUgYSBzbHVnIGZyb20gdGhlIGdpdmVuIGBzdHJgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5leHBvcnRzLnNsdWcgPSBmdW5jdGlvbihzdHIpIHtcXG4gIHJldHVybiBzdHJcXG4gICAgLnRvTG93ZXJDYXNlKClcXG4gICAgLnJlcGxhY2UoLyArL2csICctJylcXG4gICAgLnJlcGxhY2UoL1teLVxcXFx3XS9nLCAnJyk7XFxufTtcXG5cXG4vKipcXG4gKiBTdHJpcCB0aGUgZnVuY3Rpb24gZGVmaW5pdGlvbiBmcm9tIGBzdHJgLCBhbmQgcmUtaW5kZW50IGZvciBwcmUgd2hpdGVzcGFjZS5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZXhwb3J0cy5jbGVhbiA9IGZ1bmN0aW9uKHN0cikge1xcbiAgc3RyID0gc3RyXFxuICAgIC5yZXBsYWNlKC9cXFxcclxcXFxuP3xbXFxcXG5cXFxcdTIwMjhcXFxcdTIwMjldL2csICdcXFxcbicpXFxuICAgIC5yZXBsYWNlKC9eXFxcXHVGRUZGLywgJycpXFxuICAgIC8vICh0cmFkaXRpb25hbCktPiAgc3BhY2UvbmFtZSAgICAgcGFyYW1ldGVycyAgICBib2R5ICAgICAobGFtYmRhKS0+IHBhcmFtZXRlcnMgICAgICAgYm9keSAgIG11bHRpLXN0YXRlbWVudC9zaW5nbGUgICAgICAgICAga2VlcCBib2R5IGNvbnRlbnRcXG4gICAgLnJlcGxhY2UoXFxuICAgICAgL15mdW5jdGlvbig/OlxcXFxzKnxcXFxccytbXihdKilcXFxcKFteKV0qXFxcXClcXFxccypcXFxceygoPzoufFxcXFxuKSo/KVxcXFxzKlxcXFx9JHxeXFxcXChbXildKlxcXFwpXFxcXHMqPT5cXFxccyooPzpcXFxceygoPzoufFxcXFxuKSo/KVxcXFxzKlxcXFx9fCgoPzoufFxcXFxuKSopKSQvLFxcbiAgICAgICckMSQyJDMnXFxuICAgICk7XFxuXFxuICB2YXIgc3BhY2VzID0gc3RyLm1hdGNoKC9eXFxcXG4/KCAqKS8pWzFdLmxlbmd0aDtcXG4gIHZhciB0YWJzID0gc3RyLm1hdGNoKC9eXFxcXG4/KFxcXFx0KikvKVsxXS5sZW5ndGg7XFxuICB2YXIgcmUgPSBuZXcgUmVnRXhwKFxcbiAgICAnXlxcXFxuPycgKyAodGFicyA/ICdcXFxcdCcgOiAnICcpICsgJ3snICsgKHRhYnMgfHwgc3BhY2VzKSArICd9JyxcXG4gICAgJ2dtJ1xcbiAgKTtcXG5cXG4gIHN0ciA9IHN0ci5yZXBsYWNlKHJlLCAnJyk7XFxuXFxuICByZXR1cm4gc3RyLnRyaW0oKTtcXG59O1xcblxcbi8qKlxcbiAqIFBhcnNlIHRoZSBnaXZlbiBgcXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHFzXFxuICogQHJldHVybiB7T2JqZWN0fVxcbiAqL1xcbmV4cG9ydHMucGFyc2VRdWVyeSA9IGZ1bmN0aW9uKHFzKSB7XFxuICByZXR1cm4gcXNcXG4gICAgLnJlcGxhY2UoJz8nLCAnJylcXG4gICAgLnNwbGl0KCcmJylcXG4gICAgLnJlZHVjZShmdW5jdGlvbihvYmosIHBhaXIpIHtcXG4gICAgICB2YXIgaSA9IHBhaXIuaW5kZXhPZignPScpO1xcbiAgICAgIHZhciBrZXkgPSBwYWlyLnNsaWNlKDAsIGkpO1xcbiAgICAgIHZhciB2YWwgPSBwYWlyLnNsaWNlKCsraSk7XFxuXFxuICAgICAgLy8gRHVlIHRvIGhvdyB0aGUgVVJMU2VhcmNoUGFyYW1zIEFQSSB0cmVhdHMgc3BhY2VzXFxuICAgICAgb2JqW2tleV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsLnJlcGxhY2UoL1xcXFwrL2csICclMjAnKSk7XFxuXFxuICAgICAgcmV0dXJuIG9iajtcXG4gICAgfSwge30pO1xcbn07XFxuXFxuLyoqXFxuICogSGlnaGxpZ2h0IHRoZSBnaXZlbiBzdHJpbmcgb2YgYGpzYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBqc1xcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBoaWdobGlnaHQoanMpIHtcXG4gIHJldHVybiBqc1xcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXFxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcXG4gICAgLnJlcGxhY2UoL1xcXFwvXFxcXC8oLiopL2dtLCAnPHNwYW4gY2xhc3M9XFxcImNvbW1lbnRcXFwiPi8vJDE8L3NwYW4+JylcXG4gICAgLnJlcGxhY2UoLygnLio/JykvZ20sICc8c3BhbiBjbGFzcz1cXFwic3RyaW5nXFxcIj4kMTwvc3Bhbj4nKVxcbiAgICAucmVwbGFjZSgvKFxcXFxkK1xcXFwuXFxcXGQrKS9nbSwgJzxzcGFuIGNsYXNzPVxcXCJudW1iZXJcXFwiPiQxPC9zcGFuPicpXFxuICAgIC5yZXBsYWNlKC8oXFxcXGQrKS9nbSwgJzxzcGFuIGNsYXNzPVxcXCJudW1iZXJcXFwiPiQxPC9zcGFuPicpXFxuICAgIC5yZXBsYWNlKFxcbiAgICAgIC9cXFxcYm5ld1sgXFxcXHRdKyhcXFxcdyspL2dtLFxcbiAgICAgICc8c3BhbiBjbGFzcz1cXFwia2V5d29yZFxcXCI+bmV3PC9zcGFuPiA8c3BhbiBjbGFzcz1cXFwiaW5pdFxcXCI+JDE8L3NwYW4+J1xcbiAgICApXFxuICAgIC5yZXBsYWNlKFxcbiAgICAgIC9cXFxcYihmdW5jdGlvbnxuZXd8dGhyb3d8cmV0dXJufHZhcnxpZnxlbHNlKVxcXFxiL2dtLFxcbiAgICAgICc8c3BhbiBjbGFzcz1cXFwia2V5d29yZFxcXCI+JDE8L3NwYW4+J1xcbiAgICApO1xcbn1cXG5cXG4vKipcXG4gKiBIaWdobGlnaHQgdGhlIGNvbnRlbnRzIG9mIHRhZyBgbmFtZWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqL1xcbmV4cG9ydHMuaGlnaGxpZ2h0VGFncyA9IGZ1bmN0aW9uKG5hbWUpIHtcXG4gIHZhciBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhJykuZ2V0RWxlbWVudHNCeVRhZ05hbWUobmFtZSk7XFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xcbiAgICBjb2RlW2ldLmlubmVySFRNTCA9IGhpZ2hsaWdodChjb2RlW2ldLmlubmVySFRNTCk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBJZiBhIHZhbHVlIGNvdWxkIGhhdmUgcHJvcGVydGllcywgYW5kIGhhcyBub25lLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCxcXG4gKiB3aGljaCByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlbXB0eSB2YWx1ZS5cXG4gKlxcbiAqIEZ1bmN0aW9ucyB3LyBubyBwcm9wZXJ0aWVzIHJldHVybiBgJ1tGdW5jdGlvbl0nYFxcbiAqIEFycmF5cyB3LyBsZW5ndGggPT09IDAgcmV0dXJuIGAnW10nYFxcbiAqIE9iamVjdHMgdy8gbm8gcHJvcGVydGllcyByZXR1cm4gYCd7fSdgXFxuICogQWxsIGVsc2U6IHJldHVybiByZXN1bHQgb2YgYHZhbHVlLnRvU3RyaW5nKClgXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlSGludCBUaGUgdHlwZSBvZiB0aGUgdmFsdWVcXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGVtcHR5UmVwcmVzZW50YXRpb24odmFsdWUsIHR5cGVIaW50KSB7XFxuICBzd2l0Y2ggKHR5cGVIaW50KSB7XFxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcXG4gICAgICByZXR1cm4gJ1tGdW5jdGlvbl0nO1xcbiAgICBjYXNlICdvYmplY3QnOlxcbiAgICAgIHJldHVybiAne30nO1xcbiAgICBjYXNlICdhcnJheSc6XFxuICAgICAgcmV0dXJuICdbXSc7XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFRha2VzIHNvbWUgdmFyaWFibGUgYW5kIGFza3MgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKWAgd2hhdCBpdCB0aGlua3MgaXRcXG4gKiBpcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L3RvU3RyaW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb21wdXRlZCB0eXBlXFxuICogQGV4YW1wbGVcXG4gKiB0eXBlKHt9KSAvLyAnb2JqZWN0J1xcbiAqIHR5cGUoW10pIC8vICdhcnJheSdcXG4gKiB0eXBlKDEpIC8vICdudW1iZXInXFxuICogdHlwZShmYWxzZSkgLy8gJ2Jvb2xlYW4nXFxuICogdHlwZShJbmZpbml0eSkgLy8gJ251bWJlcidcXG4gKiB0eXBlKG51bGwpIC8vICdudWxsJ1xcbiAqIHR5cGUobmV3IERhdGUoKSkgLy8gJ2RhdGUnXFxuICogdHlwZSgvZm9vLykgLy8gJ3JlZ2V4cCdcXG4gKiB0eXBlKCd0eXBlJykgLy8gJ3N0cmluZydcXG4gKiB0eXBlKGdsb2JhbCkgLy8gJ2dsb2JhbCdcXG4gKiB0eXBlKG5ldyBTdHJpbmcoJ2ZvbycpIC8vICdvYmplY3QnXFxuICovXFxudmFyIHR5cGUgPSAoZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gdHlwZSh2YWx1ZSkge1xcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcXG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xcbiAgICByZXR1cm4gJ251bGwnO1xcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XFxuICAgIHJldHVybiAnYnVmZmVyJztcXG4gIH1cXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXFxuICAgIC5jYWxsKHZhbHVlKVxcbiAgICAucmVwbGFjZSgvXlxcXFxbLitcXFxccyguKz8pXSQvLCAnJDEnKVxcbiAgICAudG9Mb3dlckNhc2UoKTtcXG59KTtcXG5cXG4vKipcXG4gKiBTdHJpbmdpZnkgYHZhbHVlYC4gRGlmZmVyZW50IGJlaGF2aW9yIGRlcGVuZGluZyBvbiB0eXBlIG9mIHZhbHVlOlxcbiAqXFxuICogLSBJZiBgdmFsdWVgIGlzIHVuZGVmaW5lZCBvciBudWxsLCByZXR1cm4gYCdbdW5kZWZpbmVkXSdgIG9yIGAnW251bGxdJ2AsIHJlc3BlY3RpdmVseS5cXG4gKiAtIElmIGB2YWx1ZWAgaXMgbm90IGFuIG9iamVjdCwgZnVuY3Rpb24gb3IgYXJyYXksIHJldHVybiByZXN1bHQgb2YgYHZhbHVlLnRvU3RyaW5nKClgIHdyYXBwZWQgaW4gZG91YmxlLXF1b3Rlcy5cXG4gKiAtIElmIGB2YWx1ZWAgaXMgYW4gKmVtcHR5KiBvYmplY3QsIGZ1bmN0aW9uLCBvciBhcnJheSwgcmV0dXJuIHJlc3VsdCBvZiBmdW5jdGlvblxcbiAqICAge0BsaW5rIGVtcHR5UmVwcmVzZW50YXRpb259LlxcbiAqIC0gSWYgYHZhbHVlYCBoYXMgcHJvcGVydGllcywgY2FsbCB7QGxpbmsgZXhwb3J0cy5jYW5vbmljYWxpemV9IG9uIGl0LCB0aGVuIHJldHVybiByZXN1bHQgb2ZcXG4gKiAgIEpTT04uc3RyaW5naWZ5KCkuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAc2VlIGV4cG9ydHMudHlwZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgdmFyIHR5cGVIaW50ID0gdHlwZSh2YWx1ZSk7XFxuXFxuICBpZiAoIX5bJ29iamVjdCcsICdhcnJheScsICdmdW5jdGlvbiddLmluZGV4T2YodHlwZUhpbnQpKSB7XFxuICAgIGlmICh0eXBlSGludCA9PT0gJ2J1ZmZlcicpIHtcXG4gICAgICB2YXIganNvbiA9IEJ1ZmZlci5wcm90b3R5cGUudG9KU09OLmNhbGwodmFsdWUpO1xcbiAgICAgIC8vIEJhc2VkIG9uIHRoZSB0b0pTT04gcmVzdWx0XFxuICAgICAgcmV0dXJuIGpzb25TdHJpbmdpZnkoXFxuICAgICAgICBqc29uLmRhdGEgJiYganNvbi50eXBlID8ganNvbi5kYXRhIDoganNvbixcXG4gICAgICAgIDJcXG4gICAgICApLnJlcGxhY2UoLywoXFxcXG58JCkvZywgJyQxJyk7XFxuICAgIH1cXG5cXG4gICAgLy8gSUU3L0lFOCBoYXMgYSBiaXphcnJlIFN0cmluZyBjb25zdHJ1Y3RvcjsgbmVlZHMgdG8gYmUgY29lcmNlZFxcbiAgICAvLyBpbnRvIGFuIGFycmF5IGFuZCBiYWNrIHRvIG9iai5cXG4gICAgaWYgKHR5cGVIaW50ID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XFxuICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnJykucmVkdWNlKGZ1bmN0aW9uKGFjYywgY2hhciwgaWR4KSB7XFxuICAgICAgICBhY2NbaWR4XSA9IGNoYXI7XFxuICAgICAgICByZXR1cm4gYWNjO1xcbiAgICAgIH0sIHt9KTtcXG4gICAgICB0eXBlSGludCA9ICdvYmplY3QnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBqc29uU3RyaW5naWZ5KHZhbHVlKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkge1xcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBwcm9wKSkge1xcbiAgICAgIHJldHVybiBqc29uU3RyaW5naWZ5KFxcbiAgICAgICAgZXhwb3J0cy5jYW5vbmljYWxpemUodmFsdWUsIG51bGwsIHR5cGVIaW50KSxcXG4gICAgICAgIDJcXG4gICAgICApLnJlcGxhY2UoLywoXFxcXG58JCkvZywgJyQxJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBlbXB0eVJlcHJlc2VudGF0aW9uKHZhbHVlLCB0eXBlSGludCk7XFxufTtcXG5cXG4vKipcXG4gKiBsaWtlIEpTT04uc3RyaW5naWZ5IGJ1dCBtb3JlIHNlbnNlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9ICBvYmplY3RcXG4gKiBAcGFyYW0ge251bWJlcj19IHNwYWNlc1xcbiAqIEBwYXJhbSB7bnVtYmVyPX0gZGVwdGhcXG4gKiBAcmV0dXJucyB7Kn1cXG4gKi9cXG5mdW5jdGlvbiBqc29uU3RyaW5naWZ5KG9iamVjdCwgc3BhY2VzLCBkZXB0aCkge1xcbiAgaWYgKHR5cGVvZiBzcGFjZXMgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIC8vIHByaW1pdGl2ZSB0eXBlc1xcbiAgICByZXR1cm4gX3N0cmluZ2lmeShvYmplY3QpO1xcbiAgfVxcblxcbiAgZGVwdGggPSBkZXB0aCB8fCAxO1xcbiAgdmFyIHNwYWNlID0gc3BhY2VzICogZGVwdGg7XFxuICB2YXIgc3RyID0gQXJyYXkuaXNBcnJheShvYmplY3QpID8gJ1snIDogJ3snO1xcbiAgdmFyIGVuZCA9IEFycmF5LmlzQXJyYXkob2JqZWN0KSA/ICddJyA6ICd9JztcXG4gIHZhciBsZW5ndGggPVxcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcXG4gICAgICA/IG9iamVjdC5sZW5ndGhcXG4gICAgICA6IE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoO1xcbiAgLy8gYC5yZXBlYXQoKWAgcG9seWZpbGxcXG4gIGZ1bmN0aW9uIHJlcGVhdChzLCBuKSB7XFxuICAgIHJldHVybiBuZXcgQXJyYXkobikuam9pbihzKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIF9zdHJpbmdpZnkodmFsKSB7XFxuICAgIHN3aXRjaCAodHlwZSh2YWwpKSB7XFxuICAgICAgY2FzZSAnbnVsbCc6XFxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcXG4gICAgICAgIHZhbCA9ICdbJyArIHZhbCArICddJztcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ2FycmF5JzpcXG4gICAgICBjYXNlICdvYmplY3QnOlxcbiAgICAgICAgdmFsID0ganNvblN0cmluZ2lmeSh2YWwsIHNwYWNlcywgZGVwdGggKyAxKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XFxuICAgICAgY2FzZSAnc3ltYm9sJzpcXG4gICAgICBjYXNlICdudW1iZXInOlxcbiAgICAgICAgdmFsID1cXG4gICAgICAgICAgdmFsID09PSAwICYmIDEgLyB2YWwgPT09IC1JbmZpbml0eSAvLyBgLTBgXFxuICAgICAgICAgICAgPyAnLTAnXFxuICAgICAgICAgICAgOiB2YWwudG9TdHJpbmcoKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ2RhdGUnOlxcbiAgICAgICAgdmFyIHNEYXRlID0gaXNOYU4odmFsLmdldFRpbWUoKSkgPyB2YWwudG9TdHJpbmcoKSA6IHZhbC50b0lTT1N0cmluZygpO1xcbiAgICAgICAgdmFsID0gJ1tEYXRlOiAnICsgc0RhdGUgKyAnXSc7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdidWZmZXInOlxcbiAgICAgICAgdmFyIGpzb24gPSB2YWwudG9KU09OKCk7XFxuICAgICAgICAvLyBCYXNlZCBvbiB0aGUgdG9KU09OIHJlc3VsdFxcbiAgICAgICAganNvbiA9IGpzb24uZGF0YSAmJiBqc29uLnR5cGUgPyBqc29uLmRhdGEgOiBqc29uO1xcbiAgICAgICAgdmFsID0gJ1tCdWZmZXI6ICcgKyBqc29uU3RyaW5naWZ5KGpzb24sIDIsIGRlcHRoICsgMSkgKyAnXSc7XFxuICAgICAgICBicmVhaztcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgdmFsID1cXG4gICAgICAgICAgdmFsID09PSAnW0Z1bmN0aW9uXScgfHwgdmFsID09PSAnW0NpcmN1bGFyXSdcXG4gICAgICAgICAgICA/IHZhbFxcbiAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkodmFsKTsgLy8gc3RyaW5nXFxuICAgIH1cXG4gICAgcmV0dXJuIHZhbDtcXG4gIH1cXG5cXG4gIGZvciAodmFyIGkgaW4gb2JqZWN0KSB7XFxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaSkpIHtcXG4gICAgICBjb250aW51ZTsgLy8gbm90IG15IGJ1c2luZXNzXFxuICAgIH1cXG4gICAgLS1sZW5ndGg7XFxuICAgIHN0ciArPVxcbiAgICAgICdcXFxcbiAnICtcXG4gICAgICByZXBlYXQoJyAnLCBzcGFjZSkgK1xcbiAgICAgIChBcnJheS5pc0FycmF5KG9iamVjdCkgPyAnJyA6ICdcXFwiJyArIGkgKyAnXFxcIjogJykgKyAvLyBrZXlcXG4gICAgICBfc3RyaW5naWZ5KG9iamVjdFtpXSkgKyAvLyB2YWx1ZVxcbiAgICAgIChsZW5ndGggPyAnLCcgOiAnJyk7IC8vIGNvbW1hXFxuICB9XFxuXFxuICByZXR1cm4gKFxcbiAgICBzdHIgK1xcbiAgICAvLyBbXSwge31cXG4gICAgKHN0ci5sZW5ndGggIT09IDEgPyAnXFxcXG4nICsgcmVwZWF0KCcgJywgLS1zcGFjZSkgKyBlbmQgOiBlbmQpXFxuICApO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBuZXcgVGhpbmcgdGhhdCBoYXMgdGhlIGtleXMgaW4gc29ydGVkIG9yZGVyLiBSZWN1cnNpdmUuXFxuICpcXG4gKiBJZiB0aGUgVGhpbmcuLi5cXG4gKiAtIGhhcyBhbHJlYWR5IGJlZW4gc2VlbiwgcmV0dXJuIHN0cmluZyBgJ1tDaXJjdWxhcl0nYFxcbiAqIC0gaXMgYHVuZGVmaW5lZGAsIHJldHVybiBzdHJpbmcgYCdbdW5kZWZpbmVkXSdgXFxuICogLSBpcyBgbnVsbGAsIHJldHVybiB2YWx1ZSBgbnVsbGBcXG4gKiAtIGlzIHNvbWUgb3RoZXIgcHJpbWl0aXZlLCByZXR1cm4gdGhlIHZhbHVlXFxuICogLSBpcyBub3QgYSBwcmltaXRpdmUgb3IgYW4gYEFycmF5YCwgYE9iamVjdGAsIG9yIGBGdW5jdGlvbmAsIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIFRoaW5nJ3MgYHRvU3RyaW5nKClgIG1ldGhvZFxcbiAqIC0gaXMgYSBub24tZW1wdHkgYEFycmF5YCwgYE9iamVjdGAsIG9yIGBGdW5jdGlvbmAsIHJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBhZ2Fpbi5cXG4gKiAtIGlzIGFuIGVtcHR5IGBBcnJheWAsIGBPYmplY3RgLCBvciBgRnVuY3Rpb25gLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBlbXB0eVJlcHJlc2VudGF0aW9uKClgXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAc2VlIHtAbGluayBleHBvcnRzLnN0cmluZ2lmeX1cXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoaW5nIHRvIGluc3BlY3QuICBNYXkgb3IgbWF5IG5vdCBoYXZlIHByb3BlcnRpZXMuXFxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrPVtdXSBTdGFjayBvZiBzZWVuIHZhbHVlc1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZUhpbnRdIFR5cGUgaGludFxcbiAqIEByZXR1cm4geyhPYmplY3R8QXJyYXl8RnVuY3Rpb258c3RyaW5nfHVuZGVmaW5lZCl9XFxuICovXFxuZXhwb3J0cy5jYW5vbmljYWxpemUgPSBmdW5jdGlvbiBjYW5vbmljYWxpemUodmFsdWUsIHN0YWNrLCB0eXBlSGludCkge1xcbiAgdmFyIGNhbm9uaWNhbGl6ZWRPYmo7XFxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xcbiAgdmFyIHByb3A7XFxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXFxuICB0eXBlSGludCA9IHR5cGVIaW50IHx8IHR5cGUodmFsdWUpO1xcbiAgZnVuY3Rpb24gd2l0aFN0YWNrKHZhbHVlLCBmbikge1xcbiAgICBzdGFjay5wdXNoKHZhbHVlKTtcXG4gICAgZm4oKTtcXG4gICAgc3RhY2sucG9wKCk7XFxuICB9XFxuXFxuICBzdGFjayA9IHN0YWNrIHx8IFtdO1xcblxcbiAgaWYgKHN0YWNrLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xcbiAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xcbiAgfVxcblxcbiAgc3dpdGNoICh0eXBlSGludCkge1xcbiAgICBjYXNlICd1bmRlZmluZWQnOlxcbiAgICBjYXNlICdidWZmZXInOlxcbiAgICBjYXNlICdudWxsJzpcXG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWU7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2FycmF5JzpcXG4gICAgICB3aXRoU3RhY2sodmFsdWUsIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHZhbHVlLm1hcChmdW5jdGlvbihpdGVtKSB7XFxuICAgICAgICAgIHJldHVybiBleHBvcnRzLmNhbm9uaWNhbGl6ZShpdGVtLCBzdGFjayk7XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xcbiAgICAgIGZvciAocHJvcCBpbiB2YWx1ZSkge1xcbiAgICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICAgIC8qIGVzbGludC1lbmFibGUgZ3VhcmQtZm9yLWluICovXFxuICAgICAgaWYgKCFjYW5vbmljYWxpemVkT2JqKSB7XFxuICAgICAgICBjYW5vbmljYWxpemVkT2JqID0gZW1wdHlSZXByZXNlbnRhdGlvbih2YWx1ZSwgdHlwZUhpbnQpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICAvKiBmYWxscyB0aHJvdWdoICovXFxuICAgIGNhc2UgJ29iamVjdCc6XFxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IGNhbm9uaWNhbGl6ZWRPYmogfHwge307XFxuICAgICAgd2l0aFN0YWNrKHZhbHVlLCBmdW5jdGlvbigpIHtcXG4gICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKVxcbiAgICAgICAgICAuc29ydCgpXFxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xcbiAgICAgICAgICAgIGNhbm9uaWNhbGl6ZWRPYmpba2V5XSA9IGV4cG9ydHMuY2Fub25pY2FsaXplKHZhbHVlW2tleV0sIHN0YWNrKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2RhdGUnOlxcbiAgICBjYXNlICdudW1iZXInOlxcbiAgICBjYXNlICdyZWdleHAnOlxcbiAgICBjYXNlICdib29sZWFuJzpcXG4gICAgY2FzZSAnc3ltYm9sJzpcXG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWU7XFxuICAgICAgYnJlYWs7XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHZhbHVlICsgJyc7XFxuICB9XFxuXFxuICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcXG59O1xcblxcbi8qKlxcbiAqIExvb2t1cCBmaWxlIG5hbWVzIGF0IHRoZSBnaXZlbiBgcGF0aGAuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEudXRpbHNcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGggQmFzZSBwYXRoIHRvIHN0YXJ0IHNlYXJjaGluZyBmcm9tLlxcbiAqIEBwYXJhbSB7c3RyaW5nW119IGV4dGVuc2lvbnMgRmlsZSBleHRlbnNpb25zIHRvIGxvb2sgZm9yLlxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVjdXJzaXZlIFdoZXRoZXIgb3Igbm90IHRvIHJlY3Vyc2UgaW50byBzdWJkaXJlY3Rvcmllcy5cXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2YgcGF0aHMuXFxuICovXFxuZXhwb3J0cy5sb29rdXBGaWxlcyA9IGZ1bmN0aW9uIGxvb2t1cEZpbGVzKGZpbGVwYXRoLCBleHRlbnNpb25zLCByZWN1cnNpdmUpIHtcXG4gIHZhciBmaWxlcyA9IFtdO1xcblxcbiAgaWYgKCFmcy5leGlzdHNTeW5jKGZpbGVwYXRoKSkge1xcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhmaWxlcGF0aCArICcuanMnKSkge1xcbiAgICAgIGZpbGVwYXRoICs9ICcuanMnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZpbGVzID0gZ2xvYi5zeW5jKGZpbGVwYXRoKTtcXG4gICAgICBpZiAoIWZpbGVzLmxlbmd0aCkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJjYW5ub3QgcmVzb2x2ZSBwYXRoIChvciBwYXR0ZXJuKSAnXFxcIiArIGZpbGVwYXRoICsgXFxcIidcXFwiKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGZpbGVzO1xcbiAgICB9XFxuICB9XFxuXFxuICB0cnkge1xcbiAgICB2YXIgc3RhdCA9IGZzLnN0YXRTeW5jKGZpbGVwYXRoKTtcXG4gICAgaWYgKHN0YXQuaXNGaWxlKCkpIHtcXG4gICAgICByZXR1cm4gZmlsZXBhdGg7XFxuICAgIH1cXG4gIH0gY2F0Y2ggKGVycikge1xcbiAgICAvLyBpZ25vcmUgZXJyb3JcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgZnMucmVhZGRpclN5bmMoZmlsZXBhdGgpLmZvckVhY2goZnVuY3Rpb24oZmlsZSkge1xcbiAgICBmaWxlID0gcGF0aC5qb2luKGZpbGVwYXRoLCBmaWxlKTtcXG4gICAgdHJ5IHtcXG4gICAgICB2YXIgc3RhdCA9IGZzLnN0YXRTeW5jKGZpbGUpO1xcbiAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcXG4gICAgICAgIGlmIChyZWN1cnNpdmUpIHtcXG4gICAgICAgICAgZmlsZXMgPSBmaWxlcy5jb25jYXQobG9va3VwRmlsZXMoZmlsZSwgZXh0ZW5zaW9ucywgcmVjdXJzaXZlKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAvLyBpZ25vcmUgZXJyb3JcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgaWYgKCFleHRlbnNpb25zKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcbiAgICAgICAgJ2V4dGVuc2lvbnMgcGFyYW1ldGVyIHJlcXVpcmVkIHdoZW4gZmlsZXBhdGggaXMgYSBkaXJlY3RvcnknXFxuICAgICAgKTtcXG4gICAgfVxcbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKCdcXFxcXFxcXC4oPzonICsgZXh0ZW5zaW9ucy5qb2luKCd8JykgKyAnKSQnKTtcXG4gICAgaWYgKCFzdGF0LmlzRmlsZSgpIHx8ICFyZS50ZXN0KGZpbGUpIHx8IHBhdGguYmFzZW5hbWUoZmlsZSlbMF0gPT09ICcuJykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBmaWxlcy5wdXNoKGZpbGUpO1xcbiAgfSk7XFxuXFxuICByZXR1cm4gZmlsZXM7XFxufTtcXG5cXG4vKipcXG4gKiBHZW5lcmF0ZSBhbiB1bmRlZmluZWQgZXJyb3Igd2l0aCBhIG1lc3NhZ2Ugd2FybmluZyB0aGUgdXNlci5cXG4gKlxcbiAqIEByZXR1cm4ge0Vycm9yfVxcbiAqL1xcblxcbmV4cG9ydHMudW5kZWZpbmVkRXJyb3IgPSBmdW5jdGlvbigpIHtcXG4gIHJldHVybiBuZXcgRXJyb3IoXFxuICAgICdDYXVnaHQgdW5kZWZpbmVkIGVycm9yLCBkaWQgeW91IHRocm93IHdpdGhvdXQgc3BlY2lmeWluZyB3aGF0PydcXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBHZW5lcmF0ZSBhbiB1bmRlZmluZWQgZXJyb3IgaWYgYGVycmAgaXMgbm90IGRlZmluZWQuXFxuICpcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKiBAcmV0dXJuIHtFcnJvcn1cXG4gKi9cXG5cXG5leHBvcnRzLmdldEVycm9yID0gZnVuY3Rpb24oZXJyKSB7XFxuICByZXR1cm4gZXJyIHx8IGV4cG9ydHMudW5kZWZpbmVkRXJyb3IoKTtcXG59O1xcblxcbi8qKlxcbiAqIEBzdW1tYXJ5XFxuICogVGhpcyBGaWx0ZXIgYmFzZWQgb24gYG1vY2hhLWNsZWFuYCBtb2R1bGUuKHNlZTogYGdpdGh1Yi5jb20vcnN0YWNydXovbW9jaGEtY2xlYW5gKVxcbiAqIEBkZXNjcmlwdGlvblxcbiAqIFdoZW4gaW52b2tpbmcgdGhpcyBmdW5jdGlvbiB5b3UgZ2V0IGEgZmlsdGVyIGZ1bmN0aW9uIHRoYXQgZ2V0IHRoZSBFcnJvci5zdGFjayBhcyBhbiBpbnB1dCxcXG4gKiBhbmQgcmV0dXJuIGEgcHJldHRpZnkgb3V0cHV0LlxcbiAqIChpLmU6IHN0cmlwIE1vY2hhIGFuZCBpbnRlcm5hbCBub2RlIGZ1bmN0aW9ucyBmcm9tIHN0YWNrIHRyYWNlKS5cXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XFxuICovXFxuZXhwb3J0cy5zdGFja1RyYWNlRmlsdGVyID0gZnVuY3Rpb24oKSB7XFxuICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggYHByb2Nlc3MuYnJvd3NlcmBcXG4gIHZhciBpcyA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB7bm9kZTogdHJ1ZX0gOiB7YnJvd3NlcjogdHJ1ZX07XFxuICB2YXIgc2xhc2ggPSBwYXRoLnNlcDtcXG4gIHZhciBjd2Q7XFxuICBpZiAoaXMubm9kZSkge1xcbiAgICBjd2QgPSBwcm9jZXNzLmN3ZCgpICsgc2xhc2g7XFxuICB9IGVsc2Uge1xcbiAgICBjd2QgPSAodHlwZW9mIGxvY2F0aW9uID09PSAndW5kZWZpbmVkJ1xcbiAgICAgID8gd2luZG93LmxvY2F0aW9uXFxuICAgICAgOiBsb2NhdGlvblxcbiAgICApLmhyZWYucmVwbGFjZSgvXFxcXC9bXi9dKiQvLCAnLycpO1xcbiAgICBzbGFzaCA9ICcvJztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGlzTW9jaGFJbnRlcm5hbChsaW5lKSB7XFxuICAgIHJldHVybiAoXFxuICAgICAgfmxpbmUuaW5kZXhPZignbm9kZV9tb2R1bGVzJyArIHNsYXNoICsgJ21vY2hhJyArIHNsYXNoKSB8fFxcbiAgICAgIH5saW5lLmluZGV4T2YoJ25vZGVfbW9kdWxlcycgKyBzbGFzaCArICdtb2NoYS5qcycpIHx8XFxuICAgICAgfmxpbmUuaW5kZXhPZignYm93ZXJfY29tcG9uZW50cycgKyBzbGFzaCArICdtb2NoYS5qcycpIHx8XFxuICAgICAgfmxpbmUuaW5kZXhPZihzbGFzaCArICdtb2NoYS5qcycpXFxuICAgICk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpc05vZGVJbnRlcm5hbChsaW5lKSB7XFxuICAgIHJldHVybiAoXFxuICAgICAgfmxpbmUuaW5kZXhPZignKHRpbWVycy5qczonKSB8fFxcbiAgICAgIH5saW5lLmluZGV4T2YoJyhldmVudHMuanM6JykgfHxcXG4gICAgICB+bGluZS5pbmRleE9mKCcobm9kZS5qczonKSB8fFxcbiAgICAgIH5saW5lLmluZGV4T2YoJyhtb2R1bGUuanM6JykgfHxcXG4gICAgICB+bGluZS5pbmRleE9mKCdHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5uZXh0IChuYXRpdmUpJykgfHxcXG4gICAgICBmYWxzZVxcbiAgICApO1xcbiAgfVxcblxcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YWNrKSB7XFxuICAgIHN0YWNrID0gc3RhY2suc3BsaXQoJ1xcXFxuJyk7XFxuXFxuICAgIHN0YWNrID0gc3RhY2sucmVkdWNlKGZ1bmN0aW9uKGxpc3QsIGxpbmUpIHtcXG4gICAgICBpZiAoaXNNb2NoYUludGVybmFsKGxpbmUpKSB7XFxuICAgICAgICByZXR1cm4gbGlzdDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGlzLm5vZGUgJiYgaXNOb2RlSW50ZXJuYWwobGluZSkpIHtcXG4gICAgICAgIHJldHVybiBsaXN0O1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBDbGVhbiB1cCBjd2QoYWJzb2x1dGUpXFxuICAgICAgaWYgKC9cXFxcKD8uKzpcXFxcZCs6XFxcXGQrXFxcXCk/JC8udGVzdChsaW5lKSkge1xcbiAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgnKCcgKyBjd2QsICcoJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGxpc3QucHVzaChsaW5lKTtcXG4gICAgICByZXR1cm4gbGlzdDtcXG4gICAgfSwgW10pO1xcblxcbiAgICByZXR1cm4gc3RhY2suam9pbignXFxcXG4nKTtcXG4gIH07XFxufTtcXG5cXG4vKipcXG4gKiBDcnVkZSwgYnV0IGVmZmVjdGl2ZS5cXG4gKiBAYXBpXFxuICogQHBhcmFtIHsqfSB2YWx1ZVxcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCBgdmFsdWVgIGlzIGEgUHJvbWlzZVxcbiAqL1xcbmV4cG9ydHMuaXNQcm9taXNlID0gZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XFxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcXG59O1xcblxcbi8qKlxcbiAqIEl0J3MgYSBub29wLlxcbiAqIEBhcGlcXG4gKi9cXG5leHBvcnRzLm5vb3AgPSBmdW5jdGlvbigpIHt9O1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHJlcXVpcmUoXFxcImJ1ZmZlclxcXCIpLkJ1ZmZlcilcXG59LHtcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJidWZmZXJcXFwiOjQxLFxcXCJkZWJ1Z1xcXCI6NDMsXFxcImZzXFxcIjo0MCxcXFwiZ2xvYlxcXCI6NDAsXFxcImhlXFxcIjo0OCxcXFwicGF0aFxcXCI6NDAsXFxcInV0aWxcXFwiOjc2fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0J1xcblxcbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcXG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XFxuXFxudmFyIGxvb2t1cCA9IFtdXFxudmFyIHJldkxvb2t1cCA9IFtdXFxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxcblxcbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXFxuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcXG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxcbn1cXG5cXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXFxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xcblxcbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcXG5cXG4gIGlmIChsZW4gJSA0ID4gMCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxcbiAgfVxcblxcbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXFxuXFxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxcbiAgICA/IDBcXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcXG5cXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cXG59XFxuXFxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXFxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxcbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxcbn1cXG5cXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XFxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cXG59XFxuXFxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xcbiAgdmFyIHRtcFxcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXFxuXFxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxcblxcbiAgdmFyIGN1ckJ5dGUgPSAwXFxuXFxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXFxuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxcbiAgICA/IHZhbGlkTGVuIC0gNFxcbiAgICA6IHZhbGlkTGVuXFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XFxuICAgIHRtcCA9XFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcXG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcXG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXFxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXFxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXFxuICB9XFxuXFxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XFxuICAgIHRtcCA9XFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcXG4gIH1cXG5cXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcXG4gICAgdG1wID1cXG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXFxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXFxuICB9XFxuXFxuICByZXR1cm4gYXJyXFxufVxcblxcbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XFxuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cXG59XFxuXFxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XFxuICB2YXIgdG1wXFxuICB2YXIgb3V0cHV0ID0gW11cXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XFxuICAgIHRtcCA9XFxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXFxuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXFxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxcbiAgfVxcbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xcbiAgdmFyIHRtcFxcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXFxuICB2YXIgcGFydHMgPSBbXVxcbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXFxuXFxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXFxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XFxuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxcbiAgICApKVxcbiAgfVxcblxcbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcXG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cXG4gICAgcGFydHMucHVzaChcXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcXG4gICAgICAnPT0nXFxuICAgIClcXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxcbiAgICBwYXJ0cy5wdXNoKFxcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcXG4gICAgICAnPSdcXG4gICAgKVxcbiAgfVxcblxcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXFxufVxcblxcbn0se31dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5cXG59LHt9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG52YXIgV3JpdGFibGVTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5Xcml0YWJsZVxcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0c1xcblxcbm1vZHVsZS5leHBvcnRzID0gQnJvd3NlclN0ZG91dFxcblxcblxcbmluaGVyaXRzKEJyb3dzZXJTdGRvdXQsIFdyaXRhYmxlU3RyZWFtKVxcblxcbmZ1bmN0aW9uIEJyb3dzZXJTdGRvdXQob3B0cykge1xcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJyb3dzZXJTdGRvdXQpKSByZXR1cm4gbmV3IEJyb3dzZXJTdGRvdXQob3B0cylcXG5cXG4gIG9wdHMgPSBvcHRzIHx8IHt9XFxuICBXcml0YWJsZVN0cmVhbS5jYWxsKHRoaXMsIG9wdHMpXFxuICB0aGlzLmxhYmVsID0gKG9wdHMubGFiZWwgIT09IHVuZGVmaW5lZCkgPyBvcHRzLmxhYmVsIDogJ3N0ZG91dCdcXG59XFxuXFxuQnJvd3NlclN0ZG91dC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmtzLCBlbmNvZGluZywgY2IpIHtcXG4gIHZhciBvdXRwdXQgPSBjaHVua3MudG9TdHJpbmcgPyBjaHVua3MudG9TdHJpbmcoKSA6IGNodW5rc1xcbiAgaWYgKHRoaXMubGFiZWwgPT09IGZhbHNlKSB7XFxuICAgIGNvbnNvbGUubG9nKG91dHB1dClcXG4gIH0gZWxzZSB7XFxuICAgIGNvbnNvbGUubG9nKHRoaXMubGFiZWwrJzonLCBvdXRwdXQpXFxuICB9XFxuICBwcm9jZXNzLm5leHRUaWNrKGNiKVxcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJzdHJlYW1cXFwiOjcxLFxcXCJ1dGlsXFxcIjo3Nn1dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5hcmd1bWVudHNbNF1bMzhdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKVxcbn0se1xcXCJkdXBcXFwiOjM4fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qIVxcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxcbiAqXFxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cXG4gKiBAbGljZW5zZSAgTUlUXFxuICovXFxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cXG5cXG4ndXNlIHN0cmljdCdcXG5cXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxcblxcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXFxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxcblxcbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXFxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXFxuXFxuLyoqXFxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcXG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXFxuICpcXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxcbiAqXFxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXFxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcXG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cXG4gKi9cXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcXG5cXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgY29uc29sZS5lcnJvcihcXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xcbiAgKVxcbn1cXG5cXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XFxuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XFxuICB0cnkge1xcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XFxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXFxuICB9IGNhdGNoIChlKSB7XFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcbn1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcXG4gIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xcbiAgICAgIHJldHVybiB1bmRlZmluZWRcXG4gICAgfVxcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcXG4gIH1cXG59KVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XFxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxcbiAgICB9XFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcXG4gIH1cXG59KVxcblxcbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XFxuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXFxuICB9XFxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXFxuICByZXR1cm4gYnVmXFxufVxcblxcbi8qKlxcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXFxuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcXG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxcbiAqXFxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxcbiAqL1xcblxcbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIC8vIENvbW1vbiBjYXNlLlxcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XFxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXFxuICAgICAgKVxcbiAgICB9XFxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXFxuICB9XFxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xcbiAgICB2YWx1ZTogbnVsbCxcXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcXG4gICAgd3JpdGFibGU6IGZhbHNlXFxuICB9KVxcbn1cXG5cXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cXG5cXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XFxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwidmFsdWVcXFwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcXG4gIH1cXG5cXG4gIGlmIChpc0FycmF5QnVmZmVyKHZhbHVlKSB8fCAodmFsdWUgJiYgaXNBcnJheUJ1ZmZlcih2YWx1ZS5idWZmZXIpKSkge1xcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXFxuICB9XFxuXFxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcXG4gIH1cXG5cXG4gIHJldHVybiBmcm9tT2JqZWN0KHZhbHVlKVxcbn1cXG5cXG4vKipcXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxcbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXFxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXFxuICoqL1xcbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1ZzpcXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxcblxcbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcXG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcInNpemVcXFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFxcInNpemVcXFwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XFxuICBhc3NlcnRTaXplKHNpemUpXFxuICBpZiAoc2l6ZSA8PSAwKSB7XFxuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcXG4gIH1cXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcXG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXFxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXFxuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXFxuICB9XFxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXFxufVxcblxcbi8qKlxcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXFxuICoqL1xcbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxcbn1cXG5cXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xcbiAgYXNzZXJ0U2l6ZShzaXplKVxcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcXG59XFxuXFxuLyoqXFxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cXG4gKiAqL1xcbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XFxuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcXG59XFxuLyoqXFxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXFxuICovXFxuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XFxuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcXG59XFxuXFxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XFxuICAgIGVuY29kaW5nID0gJ3V0ZjgnXFxuICB9XFxuXFxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXFxuICB9XFxuXFxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxcblxcbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxcblxcbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XFxuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxcbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcXG4gIH1cXG5cXG4gIHJldHVybiBidWZcXG59XFxuXFxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcXG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxcbiAgfVxcbiAgcmV0dXJuIGJ1Zlxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFxcIm9mZnNldFxcXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcXG4gIH1cXG5cXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcXCJsZW5ndGhcXFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXFxuICB9XFxuXFxuICB2YXIgYnVmXFxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcXG4gIH0gZWxzZSB7XFxuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXFxuICB9XFxuXFxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcXG4gIHJldHVybiBidWZcXG59XFxuXFxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcXG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxcblxcbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgIHJldHVybiBidWZcXG4gICAgfVxcblxcbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcXG4gICAgcmV0dXJuIGJ1ZlxcbiAgfVxcblxcbiAgaWYgKG9iaikge1xcbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XFxuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXFxuICAgIH1cXG5cXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxcbiAgICB9XFxuICB9XFxuXFxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4nKVxcbn1cXG5cXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcXG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxcbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXFxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcXG4gIH1cXG4gIHJldHVybiBsZW5ndGggfCAwXFxufVxcblxcbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXFxuICAgIGxlbmd0aCA9IDBcXG4gIH1cXG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcXG59XFxuXFxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcXG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWVcXG59XFxuXFxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxcbiAgfVxcblxcbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXFxuXFxuICB2YXIgeCA9IGEubGVuZ3RoXFxuICB2YXIgeSA9IGIubGVuZ3RoXFxuXFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xcbiAgICAgIHggPSBhW2ldXFxuICAgICAgeSA9IGJbaV1cXG4gICAgICBicmVha1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxcbiAgcmV0dXJuIDBcXG59XFxuXFxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcXG4gICAgY2FzZSAnaGV4JzpcXG4gICAgY2FzZSAndXRmOCc6XFxuICAgIGNhc2UgJ3V0Zi04JzpcXG4gICAgY2FzZSAnYXNjaWknOlxcbiAgICBjYXNlICdsYXRpbjEnOlxcbiAgICBjYXNlICdiaW5hcnknOlxcbiAgICBjYXNlICdiYXNlNjQnOlxcbiAgICBjYXNlICd1Y3MyJzpcXG4gICAgY2FzZSAndWNzLTInOlxcbiAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgIHJldHVybiB0cnVlXFxuICAgIGRlZmF1bHQ6XFxuICAgICAgcmV0dXJuIGZhbHNlXFxuICB9XFxufVxcblxcbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJsaXN0XFxcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxcbiAgfVxcblxcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XFxuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcXG4gIH1cXG5cXG4gIHZhciBpXFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcXG4gICAgbGVuZ3RoID0gMFxcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcXG4gIHZhciBwb3MgPSAwXFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxcbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZikpIHtcXG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXFxuICAgIH1cXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJsaXN0XFxcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxcbiAgICB9XFxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxcbiAgfVxcbiAgcmV0dXJuIGJ1ZmZlclxcbn1cXG5cXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcXG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcXG4gIH1cXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0FycmF5QnVmZmVyKHN0cmluZykpIHtcXG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXFxuICB9XFxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcXG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcXG4gIH1cXG5cXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxcblxcbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXFxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxcbiAgZm9yICg7Oykge1xcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XFxuICAgICAgY2FzZSAnYXNjaWknOlxcbiAgICAgIGNhc2UgJ2xhdGluMSc6XFxuICAgICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgICAgIHJldHVybiBsZW5cXG4gICAgICBjYXNlICd1dGY4JzpcXG4gICAgICBjYXNlICd1dGYtOCc6XFxuICAgICAgY2FzZSB1bmRlZmluZWQ6XFxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcXG4gICAgICBjYXNlICd1Y3MyJzpcXG4gICAgICBjYXNlICd1Y3MtMic6XFxuICAgICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcXG4gICAgICBjYXNlICdoZXgnOlxcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXFxuICAgIH1cXG4gIH1cXG59XFxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXFxuXFxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcXG5cXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXFxcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcXFwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcXG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXFxuXFxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xcbiAgICBzdGFydCA9IDBcXG4gIH1cXG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXFxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxcbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuICcnXFxuICB9XFxuXFxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcXG4gIH1cXG5cXG4gIGlmIChlbmQgPD0gMCkge1xcbiAgICByZXR1cm4gJydcXG4gIH1cXG5cXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXFxuICBlbmQgPj4+PSAwXFxuICBzdGFydCA+Pj49IDBcXG5cXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcXG4gICAgcmV0dXJuICcnXFxuICB9XFxuXFxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xcblxcbiAgd2hpbGUgKHRydWUpIHtcXG4gICAgc3dpdGNoIChlbmNvZGluZykge1xcbiAgICAgIGNhc2UgJ2hleCc6XFxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICd1dGY4JzpcXG4gICAgICBjYXNlICd1dGYtOCc6XFxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgY2FzZSAnYXNjaWknOlxcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICdsYXRpbjEnOlxcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XFxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICdiYXNlNjQnOlxcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgY2FzZSAndWNzMic6XFxuICAgICAgY2FzZSAndWNzLTInOlxcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcXG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXFxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXFxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXFxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXFxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxcblxcbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcXG4gIHZhciBpID0gYltuXVxcbiAgYltuXSA9IGJbbV1cXG4gIGJbbV0gPSBpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcXG4gIH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcXG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcXG4gIH1cXG4gIHJldHVybiB0aGlzXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcXG4gIH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcXG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXFxuICB9XFxuICByZXR1cm4gdGhpc1xcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XFxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXFxuICB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XFxuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXFxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXFxuICB9XFxuICByZXR1cm4gdGhpc1xcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xcblxcbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXFxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcXG4gIHZhciBzdHIgPSAnJ1xcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcXG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xcbiAgfVxcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXFxuICB9XFxuXFxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xcbiAgICBzdGFydCA9IDBcXG4gIH1cXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxcbiAgfVxcbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHRoaXNTdGFydCA9IDBcXG4gIH1cXG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcXG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXFxuICB9XFxuXFxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXFxuICB9XFxuXFxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XFxuICAgIHJldHVybiAwXFxuICB9XFxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcXG4gICAgcmV0dXJuIC0xXFxuICB9XFxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XFxuICAgIHJldHVybiAxXFxuICB9XFxuXFxuICBzdGFydCA+Pj49IDBcXG4gIGVuZCA+Pj49IDBcXG4gIHRoaXNTdGFydCA+Pj49IDBcXG4gIHRoaXNFbmQgPj4+PSAwXFxuXFxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxcblxcbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcXG5cXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XFxuICAgICAgeCA9IHRoaXNDb3B5W2ldXFxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cXG4gICAgICBicmVha1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxcbiAgcmV0dXJuIDBcXG59XFxuXFxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXFxuLy9cXG4vLyBBcmd1bWVudHM6XFxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXFxuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcXG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxcblxcbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcXG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcXG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XFxuICAgIGJ5dGVPZmZzZXQgPSAwXFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XFxuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcXG4gIH1cXG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcXFwiZm9vXFxcIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXFxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxcbiAgfVxcblxcbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XFxuICAgIGlmIChkaXIpIHJldHVybiAtMVxcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxcbiAgICBlbHNlIHJldHVybiAtMVxcbiAgfVxcblxcbiAgLy8gTm9ybWFsaXplIHZhbFxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XFxuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXFxuICB9XFxuXFxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XFxuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcXG4gICAgICByZXR1cm4gLTFcXG4gICAgfVxcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgaWYgKGRpcikge1xcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxcbiAgfVxcblxcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcXG59XFxuXFxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xcbiAgdmFyIGluZGV4U2l6ZSA9IDFcXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxcblxcbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcXG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcXG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcXG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcXG4gICAgICAgIHJldHVybiAtMVxcbiAgICAgIH1cXG4gICAgICBpbmRleFNpemUgPSAyXFxuICAgICAgYXJyTGVuZ3RoIC89IDJcXG4gICAgICB2YWxMZW5ndGggLz0gMlxcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcXG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xcbiAgICAgIHJldHVybiBidWZbaV1cXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgaVxcbiAgaWYgKGRpcikge1xcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcXG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcXG4gICAgICB9XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XFxuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcXG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcXG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxcbiAgICAgICAgICBicmVha1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiAtMVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcXG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcXG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcXG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcXG59XFxuXFxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcXG4gIGlmICghbGVuZ3RoKSB7XFxuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xcbiAgfSBlbHNlIHtcXG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxcblxcbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcXG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxcbiAgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXFxuICB9XFxuICByZXR1cm4gaVxcbn1cXG5cXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGVuY29kaW5nID0gJ3V0ZjgnXFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXFxuICAgIG9mZnNldCA9IDBcXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xcbiAgICBlbmNvZGluZyA9IG9mZnNldFxcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxcbiAgICBvZmZzZXQgPSAwXFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XFxuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHRocm93IG5ldyBFcnJvcihcXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXFxuICAgIClcXG4gIH1cXG5cXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXFxuXFxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxcbiAgfVxcblxcbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcXG5cXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXFxuICBmb3IgKDs7KSB7XFxuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcXG4gICAgICBjYXNlICdoZXgnOlxcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAndXRmOCc6XFxuICAgICAgY2FzZSAndXRmLTgnOlxcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAnbGF0aW4xJzpcXG4gICAgICBjYXNlICdiaW5hcnknOlxcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXFxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBjYXNlICd1Y3MyJzpcXG4gICAgICBjYXNlICd1Y3MtMic6XFxuICAgICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxcbiAgICB9XFxuICB9XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcXG4gIHJldHVybiB7XFxuICAgIHR5cGU6ICdCdWZmZXInLFxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcXG4gIHZhciByZXMgPSBbXVxcblxcbiAgdmFyIGkgPSBzdGFydFxcbiAgd2hpbGUgKGkgPCBlbmQpIHtcXG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxcbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcXG4gICAgICA6IDFcXG5cXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcXG5cXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcXG4gICAgICAgIGNhc2UgMTpcXG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcXG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAzOlxcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXFxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcXG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxcbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XFxuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXFxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXFxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcXG4gICAgfVxcblxcbiAgICByZXMucHVzaChjb2RlUG9pbnQpXFxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxcbiAgfVxcblxcbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXFxufVxcblxcbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XFxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXFxuXFxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XFxuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXFxuICB9XFxuXFxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFxcXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcXFwiLlxcbiAgdmFyIHJlcyA9ICcnXFxuICB2YXIgaSA9IDBcXG4gIHdoaWxlIChpIDwgbGVuKSB7XFxuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxcbiAgICAgIFN0cmluZyxcXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXFxuICAgIClcXG4gIH1cXG4gIHJldHVybiByZXNcXG59XFxuXFxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgcmV0ID0gJydcXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcXG5cXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XFxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXFxuICB9XFxuICByZXR1cm4gcmV0XFxufVxcblxcbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciByZXQgPSAnJ1xcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxcblxcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxcbiAgfVxcbiAgcmV0dXJuIHJldFxcbn1cXG5cXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxcblxcbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxcblxcbiAgdmFyIG91dCA9ICcnXFxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxcbiAgfVxcbiAgcmV0dXJuIG91dFxcbn1cXG5cXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXFxuICB2YXIgcmVzID0gJydcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcXG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcXG4gIH1cXG4gIHJldHVybiByZXNcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XFxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcXG4gIHN0YXJ0ID0gfn5zdGFydFxcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxcblxcbiAgaWYgKHN0YXJ0IDwgMCkge1xcbiAgICBzdGFydCArPSBsZW5cXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XFxuICAgIHN0YXJ0ID0gbGVuXFxuICB9XFxuXFxuICBpZiAoZW5kIDwgMCkge1xcbiAgICBlbmQgKz0gbGVuXFxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xcbiAgICBlbmQgPSBsZW5cXG4gIH1cXG5cXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcXG5cXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXFxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcXG4gIHJldHVybiBuZXdCdWZcXG59XFxuXFxuLypcXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cXG4gKi9cXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcXG5cXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cXG4gIHZhciBtdWwgPSAxXFxuICB2YXIgaSA9IDBcXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXFxuICB9XFxuXFxuICByZXR1cm4gdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcXG4gIH1cXG5cXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cXG4gIHZhciBtdWwgPSAxXFxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxcbiAgfVxcblxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG5cXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcXG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG5cXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXFxuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxcblxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBpID0gMFxcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcXG4gIH1cXG4gIG11bCAqPSAweDgwXFxuXFxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxcblxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcXG5cXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXFxuICB9XFxuICBtdWwgKj0gMHg4MFxcblxcbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcXG5cXG4gIHJldHVybiB2YWxcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXFxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXFxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXFxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXFxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG5cXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxcbn1cXG5cXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwiYnVmZmVyXFxcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcXCJ2YWx1ZVxcXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXFxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXFxuICB9XFxuXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIGkgPSAwXFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxcbiAgfVxcblxcbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcXG4gIH1cXG5cXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcXG4gIHZhciBtdWwgPSAxXFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXFxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXFxuICB9XFxuXFxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICByZXR1cm4gb2Zmc2V0ICsgMVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXFxuICByZXR1cm4gb2Zmc2V0ICsgMlxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICByZXR1cm4gb2Zmc2V0ICsgMlxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXFxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxcbiAgcmV0dXJuIG9mZnNldCArIDRcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXFxuXFxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxcbiAgfVxcblxcbiAgdmFyIGkgPSAwXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIHN1YiA9IDBcXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcXG4gICAgICBzdWIgPSAxXFxuICAgIH1cXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxcbiAgfVxcblxcbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXFxuXFxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxcbiAgfVxcblxcbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBzdWIgPSAwXFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXFxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcXG4gICAgICBzdWIgPSAxXFxuICAgIH1cXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxcbiAgfVxcblxcbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gIHJldHVybiBvZmZzZXQgKyAxXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXFxuICByZXR1cm4gb2Zmc2V0ICsgMlxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxcbiAgcmV0dXJuIG9mZnNldCArIDJcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXFxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXFxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXFxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXFxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XFxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXFxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXFxufVxcblxcbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcXG4gIH1cXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxcbiAgcmV0dXJuIG9mZnNldCArIDRcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXFxufVxcblxcbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcXG4gIH1cXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxcbiAgcmV0dXJuIG9mZnNldCArIDhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXFxufVxcblxcbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxcblxcbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXFxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxcblxcbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXFxuICB9XFxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxcblxcbiAgLy8gQXJlIHdlIG9vYj9cXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxcbiAgfVxcblxcbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XFxuXFxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXFxuICAgICAgdGFyZ2V0LFxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXFxuICAgICAgdGFyZ2V0U3RhcnRcXG4gICAgKVxcbiAgfVxcblxcbiAgcmV0dXJuIGxlblxcbn1cXG5cXG4vLyBVc2FnZTpcXG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XFxuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XFxuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgZW5jb2RpbmcgPSBzdGFydFxcbiAgICAgIHN0YXJ0ID0gMFxcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICBlbmNvZGluZyA9IGVuZFxcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXFxuICAgIH1cXG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxcbiAgICB9XFxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXFxuICAgIH1cXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcXG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXFxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cXG4gICAgICAgIHZhbCA9IGNvZGVcXG4gICAgICB9XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcXG4gICAgdmFsID0gdmFsICYgMjU1XFxuICB9XFxuXFxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcXG4gIH1cXG5cXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcXG4gICAgcmV0dXJuIHRoaXNcXG4gIH1cXG5cXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcXG5cXG4gIGlmICghdmFsKSB2YWwgPSAwXFxuXFxuICB2YXIgaVxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcXG4gICAgICB0aGlzW2ldID0gdmFsXFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXFxuICAgICAgPyB2YWxcXG4gICAgICA6IG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZylcXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxcbiAgICBpZiAobGVuID09PSAwKSB7XFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFxcXCInICsgdmFsICtcXG4gICAgICAgICdcXFwiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFxcXCJ2YWx1ZVxcXCInKVxcbiAgICB9XFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XFxuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXNcXG59XFxuXFxuLy8gSEVMUEVSIEZVTkNUSU9OU1xcbi8vID09PT09PT09PT09PT09PT1cXG5cXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXFxuXFxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXFxcbiBhbmQgXFxcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcXG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXFxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXFxuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcXG4gICAgc3RyID0gc3RyICsgJz0nXFxuICB9XFxuICByZXR1cm4gc3RyXFxufVxcblxcbmZ1bmN0aW9uIHRvSGV4IChuKSB7XFxuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxcbn1cXG5cXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxcbiAgdmFyIGNvZGVQb2ludFxcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxcbiAgdmFyIGJ5dGVzID0gW11cXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcXG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcXG5cXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XFxuICAgICAgICAvLyBubyBsZWFkIHlldFxcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxcbiAgICAgICAgICBjb250aW51ZVxcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XFxuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXFxuICAgICAgICAgIGNvbnRpbnVlXFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyB2YWxpZCBsZWFkXFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XFxuXFxuICAgICAgICBjb250aW51ZVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XFxuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XFxuICAgICAgICBjb250aW51ZVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XFxuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxcbiAgICB9XFxuXFxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXFxuXFxuICAgIC8vIGVuY29kZSB1dGY4XFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XFxuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXFxuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXFxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcXG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcXG4gICAgICBieXRlcy5wdXNoKFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxcbiAgICAgIClcXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXFxuICAgICAgYnl0ZXMucHVzaChcXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcXG4gICAgICApXFxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcXG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcXG4gICAgICBieXRlcy5wdXNoKFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcXG4gICAgICApXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gYnl0ZXNcXG59XFxuXFxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcXG4gIHZhciBieXRlQXJyYXkgPSBbXVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcXG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXFxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcXG4gIH1cXG4gIHJldHVybiBieXRlQXJyYXlcXG59XFxuXFxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcXG4gIHZhciBjLCBoaSwgbG9cXG4gIHZhciBieXRlQXJyYXkgPSBbXVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcXG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXFxuXFxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxcbiAgICBoaSA9IGMgPj4gOFxcbiAgICBsbyA9IGMgJSAyNTZcXG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXFxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxcbiAgfVxcblxcbiAgcmV0dXJuIGJ5dGVBcnJheVxcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcXG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcXG59XFxuXFxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XFxuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXFxuICB9XFxuICByZXR1cm4gaVxcbn1cXG5cXG4vLyBBcnJheUJ1ZmZlcnMgZnJvbSBhbm90aGVyIGNvbnRleHQgKGkuZS4gYW4gaWZyYW1lKSBkbyBub3QgcGFzcyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrXFxuLy8gYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIgKG9iaikge1xcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJlxcbiAgICAgIHR5cGVvZiBvYmouYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpXFxufVxcblxcbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcXG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxcbn1cXG5cXG59LHtcXFwiYmFzZTY0LWpzXFxcIjozNyxcXFwiaWVlZTc1NFxcXCI6NDl9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChCdWZmZXIpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxcblxcbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XFxuICBpZiAoQXJyYXkuaXNBcnJheSkge1xcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xcbiAgfVxcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XFxufVxcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XFxuXFxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcXG59XFxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XFxuXFxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XFxuXFxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XFxuICByZXR1cm4gYXJnID09IG51bGw7XFxufVxcbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcXG5cXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcXG59XFxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xcblxcbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xcbn1cXG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XFxuXFxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XFxufVxcbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcXG5cXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcXG59XFxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xcblxcbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XFxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcXG59XFxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xcblxcbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xcblxcbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XFxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcXG59XFxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XFxuXFxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XFxuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XFxufVxcbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XFxuXFxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xcbn1cXG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xcblxcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xcbn1cXG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XFxuXFxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcXG5cXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XFxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMse1xcXCJpc0J1ZmZlclxcXCI6cmVxdWlyZShcXFwiLi4vLi4vaXMtYnVmZmVyL2luZGV4LmpzXFxcIil9KVxcbn0se1xcXCIuLi8uLi9pcy1idWZmZXIvaW5kZXguanNcXFwiOjUxfV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuLyoqXFxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxcbiAqXFxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcXG5leHBvcnRzLmxvZyA9IGxvZztcXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XFxuZXhwb3J0cy5sb2FkID0gbG9hZDtcXG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcXG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXFxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXFxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XFxuXFxuLyoqXFxuICogQ29sb3JzLlxcbiAqL1xcblxcbmV4cG9ydHMuY29sb3JzID0gW1xcbiAgJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLFxcbiAgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLFxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxcbiAgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLFxcbiAgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLFxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxcbiAgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLFxcbiAgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLFxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxcbiAgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLFxcbiAgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ1xcbl07XFxuXFxuLyoqXFxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cXG4gKiB0byBzdXBwb3J0IFxcXCIlY1xcXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxcbiAqXFxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcXG4gKi9cXG5cXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XFxuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XFxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxcbiAgLy8gZXhwbGljaXRseVxcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXFxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFxcXC8oXFxcXGQrKS8pKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXFxuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcXG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXFxcLyhcXFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcXFwvKFxcXFxkKykvKSk7XFxufVxcblxcbi8qKlxcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cXG4gKi9cXG5cXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcXG4gIH0gY2F0Y2ggKGVycikge1xcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XFxuICB9XFxufTtcXG5cXG5cXG4vKipcXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xcblxcbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXFxuICAgICsgdGhpcy5uYW1lc3BhY2VcXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXFxuICAgICsgYXJnc1swXVxcbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XFxuXFxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xcblxcbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcXG5cXG4gIC8vIHRoZSBmaW5hbCBcXFwiJWNcXFwiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xcbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXFxuICB2YXIgaW5kZXggPSAwO1xcbiAgdmFyIGxhc3RDID0gMDtcXG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcXG4gICAgaW5kZXgrKztcXG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XFxuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXFxuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcXG4gICAgICBsYXN0QyA9IGluZGV4O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcXG59XFxuXFxuLyoqXFxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXFxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFxcXCJmdW5jdGlvblxcXCIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIGxvZygpIHtcXG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXFxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxcbiAgICAmJiBjb25zb2xlLmxvZ1xcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcXG59XFxuXFxuLyoqXFxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xcbiAgdHJ5IHtcXG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XFxuICAgIH1cXG4gIH0gY2F0Y2goZSkge31cXG59XFxuXFxuLyoqXFxuICogTG9hZCBgbmFtZXNwYWNlc2AuXFxuICpcXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuZnVuY3Rpb24gbG9hZCgpIHtcXG4gIHZhciByO1xcbiAgdHJ5IHtcXG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcXG4gIH0gY2F0Y2goZSkge31cXG5cXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XFxuICB9XFxuXFxuICByZXR1cm4gcjtcXG59XFxuXFxuLyoqXFxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cXG4gKi9cXG5cXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xcblxcbi8qKlxcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cXG4gKlxcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXFxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cXG4gKlxcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XFxuICB0cnkge1xcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcXG4gIH0gY2F0Y2ggKGUpIHt9XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuL2RlYnVnXFxcIjo0NCxcXFwiX3Byb2Nlc3NcXFwiOjU2fV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcblxcbi8qKlxcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxcbiAqXFxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XFxuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XFxuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcXG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcXG5cXG4vKipcXG4gKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXFxuICovXFxuZXhwb3J0cy5pbnN0YW5jZXMgPSBbXTtcXG5cXG4vKipcXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cXG4gKi9cXG5cXG5leHBvcnRzLm5hbWVzID0gW107XFxuZXhwb3J0cy5za2lwcyA9IFtdO1xcblxcbi8qKlxcbiAqIE1hcCBvZiBzcGVjaWFsIFxcXCIlblxcXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFxcXCJmb3JtYXRcXFwiIGFyZ3VtZW50LlxcbiAqXFxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXFxcIm5cXFwiIGFuZCBcXFwiTlxcXCIuXFxuICovXFxuXFxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XFxuXFxuLyoqXFxuICogU2VsZWN0IGEgY29sb3IuXFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxcbiAqIEByZXR1cm4ge051bWJlcn1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcXG4gIHZhciBoYXNoID0gMCwgaTtcXG5cXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcXG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxcbiAgfVxcblxcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcXG59XFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXFxuICogQHJldHVybiB7RnVuY3Rpb259XFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcXG5cXG4gIHZhciBwcmV2VGltZTtcXG5cXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xcbiAgICAvLyBkaXNhYmxlZD9cXG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XFxuXFxuICAgIHZhciBzZWxmID0gZGVidWc7XFxuXFxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XFxuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XFxuICAgIHNlbGYuZGlmZiA9IG1zO1xcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcXG4gICAgc2VsZi5jdXJyID0gY3VycjtcXG4gICAgcHJldlRpbWUgPSBjdXJyO1xcblxcbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XFxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcXG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xcbiAgICB9XFxuXFxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcXG5cXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXFxuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xcbiAgICB9XFxuXFxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXFxuICAgIHZhciBpbmRleCA9IDA7XFxuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XFxuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xcbiAgICAgIGluZGV4Kys7XFxuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XFxuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XFxuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XFxuXFxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XFxuICAgICAgICBpbmRleC0tO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbWF0Y2g7XFxuICAgIH0pO1xcblxcbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcXG5cXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XFxuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xcbiAgfVxcblxcbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcXG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcXG4gIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xcblxcbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XFxuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XFxuICB9XFxuXFxuICBleHBvcnRzLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcXG5cXG4gIHJldHVybiBkZWJ1ZztcXG59XFxuXFxuZnVuY3Rpb24gZGVzdHJveSAoKSB7XFxuICB2YXIgaW5kZXggPSBleHBvcnRzLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcXG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcXG5cXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcXG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcXG5cXG4gIHZhciBpO1xcbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXFxccyxdKy8pO1xcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcXG5cXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcXFwqL2csICcuKj8nKTtcXG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGluc3RhbmNlID0gZXhwb3J0cy5pbnN0YW5jZXNbaV07XFxuICAgIGluc3RhbmNlLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIGRpc2FibGUoKSB7XFxuICBleHBvcnRzLmVuYWJsZSgnJyk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXFxuICogQHJldHVybiB7Qm9vbGVhbn1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xcbiAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcbiAgdmFyIGksIGxlbjtcXG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfVxcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBmYWxzZTtcXG59XFxuXFxuLyoqXFxuICogQ29lcmNlIGB2YWxgLlxcbiAqXFxuICogQHBhcmFtIHtNaXhlZH0gdmFsXFxuICogQHJldHVybiB7TWl4ZWR9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xcbiAgcmV0dXJuIHZhbDtcXG59XFxuXFxufSx7XFxcIm1zXFxcIjo1NH1dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKiFcXG5cXG4gZGlmZiB2My41LjBcXG5cXG5Tb2Z0d2FyZSBMaWNlbnNlIEFncmVlbWVudCAoQlNEIExpY2Vuc2UpXFxuXFxuQ29weXJpZ2h0IChjKSAyMDA5LTIwMTUsIEtldmluIERlY2tlciA8a3BkZWNrZXJAZ21haWwuY29tPlxcblxcbkFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuXFxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBvZiB0aGlzIHNvZnR3YXJlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcXG5cXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcXG4gIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGVcXG4gIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxcblxcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxcbiAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZVxcbiAgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyXFxuICBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxcblxcbiogTmVpdGhlciB0aGUgbmFtZSBvZiBLZXZpbiBEZWNrZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHNcXG4gIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcXG4gIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3JcXG4gIHdyaXR0ZW4gcGVybWlzc2lvbi5cXG5cXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFxcXCJBUyBJU1xcXCIgQU5EIEFOWSBFWFBSRVNTIE9SXFxuSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcXG5DT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXFxuREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxcbkRBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSXFxuSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVFxcbk9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cXG5AbGljZW5zZVxcbiovXFxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcXG5cXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XFxuXFx0ZWxzZSBpZihmYWxzZSlcXG5cXHRcXHRkZWZpbmUoW10sIGZhY3RvcnkpO1xcblxcdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxcblxcdFxcdGV4cG9ydHNbXFxcIkpzRGlmZlxcXCJdID0gZmFjdG9yeSgpO1xcblxcdGVsc2VcXG5cXHRcXHRyb290W1xcXCJKc0RpZmZcXFwiXSA9IGZhY3RvcnkoKTtcXG59KSh0aGlzLCBmdW5jdGlvbigpIHtcXG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxcbi8qKioqKiovIFxcdC8vIFRoZSBtb2R1bGUgY2FjaGVcXG4vKioqKioqLyBcXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xcblxcbi8qKioqKiovIFxcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXFxuLyoqKioqKi8gXFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xcblxcbi8qKioqKiovIFxcdFxcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxcbi8qKioqKiovIFxcdFxcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxcbi8qKioqKiovIFxcdFxcdFxcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xcblxcbi8qKioqKiovIFxcdFxcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXFxuLyoqKioqKi8gXFx0XFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xcbi8qKioqKiovIFxcdFxcdFxcdGV4cG9ydHM6IHt9LFxcbi8qKioqKiovIFxcdFxcdFxcdGlkOiBtb2R1bGVJZCxcXG4vKioqKioqLyBcXHRcXHRcXHRsb2FkZWQ6IGZhbHNlXFxuLyoqKioqKi8gXFx0XFx0fTtcXG5cXG4vKioqKioqLyBcXHRcXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cXG4vKioqKioqLyBcXHRcXHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcXG5cXG4vKioqKioqLyBcXHRcXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXFxuLyoqKioqKi8gXFx0XFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XFxuXFxuLyoqKioqKi8gXFx0XFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcXG4vKioqKioqLyBcXHRcXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XFxuLyoqKioqKi8gXFx0fVxcblxcblxcbi8qKioqKiovIFxcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcXG5cXG4vKioqKioqLyBcXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XFxuXFxuLyoqKioqKi8gXFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcXFwiXFxcIjtcXG5cXG4vKioqKioqLyBcXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcXG4vKioqKioqLyBcXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXG4vKioqKioqLyB9KVxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyoqKioqKi8gKFtcXG4vKiAwICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLmNhbm9uaWNhbGl6ZSA9IGV4cG9ydHMuY29udmVydENoYW5nZXNUb1hNTCA9IGV4cG9ydHMuY29udmVydENoYW5nZXNUb0RNUCA9IGV4cG9ydHMubWVyZ2UgPSBleHBvcnRzLnBhcnNlUGF0Y2ggPSBleHBvcnRzLmFwcGx5UGF0Y2hlcyA9IGV4cG9ydHMuYXBwbHlQYXRjaCA9IGV4cG9ydHMuY3JlYXRlUGF0Y2ggPSBleHBvcnRzLmNyZWF0ZVR3b0ZpbGVzUGF0Y2ggPSBleHBvcnRzLnN0cnVjdHVyZWRQYXRjaCA9IGV4cG9ydHMuZGlmZkFycmF5cyA9IGV4cG9ydHMuZGlmZkpzb24gPSBleHBvcnRzLmRpZmZDc3MgPSBleHBvcnRzLmRpZmZTZW50ZW5jZXMgPSBleHBvcnRzLmRpZmZUcmltbWVkTGluZXMgPSBleHBvcnRzLmRpZmZMaW5lcyA9IGV4cG9ydHMuZGlmZldvcmRzV2l0aFNwYWNlID0gZXhwb3J0cy5kaWZmV29yZHMgPSBleHBvcnRzLmRpZmZDaGFycyA9IGV4cG9ydHMuRGlmZiA9IHVuZGVmaW5lZDtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19jaGFyYWN0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3dvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2xpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3NlbnRlbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19jc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2pzb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19hcHBseSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3BhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fbWVyZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19jcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19kbXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL194bWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcblxcdC8qIFNlZSBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zIG9mIHVzZSAqL1xcblxcblxcdC8qXFxuXFx0ICogVGV4dCBkaWZmIGltcGxlbWVudGF0aW9uLlxcblxcdCAqXFxuXFx0ICogVGhpcyBsaWJyYXJ5IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgQVBJUzpcXG5cXHQgKiBKc0RpZmYuZGlmZkNoYXJzOiBDaGFyYWN0ZXIgYnkgY2hhcmFjdGVyIGRpZmZcXG5cXHQgKiBKc0RpZmYuZGlmZldvcmRzOiBXb3JkIChhcyBkZWZpbmVkIGJ5IFxcXFxiIHJlZ2V4KSBkaWZmIHdoaWNoIGlnbm9yZXMgd2hpdGVzcGFjZVxcblxcdCAqIEpzRGlmZi5kaWZmTGluZXM6IExpbmUgYmFzZWQgZGlmZlxcblxcdCAqXFxuXFx0ICogSnNEaWZmLmRpZmZDc3M6IERpZmYgdGFyZ2V0ZWQgYXQgQ1NTIGNvbnRlbnRcXG5cXHQgKlxcblxcdCAqIFRoZXNlIG1ldGhvZHMgYXJlIGJhc2VkIG9uIHRoZSBpbXBsZW1lbnRhdGlvbiBwcm9wb3NlZCBpblxcblxcdCAqIFxcXCJBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgaXRzIFZhcmlhdGlvbnNcXFwiIChNeWVycywgMTk4NikuXFxuXFx0ICogaHR0cDovL2NpdGVzZWVyeC5pc3QucHN1LmVkdS92aWV3ZG9jL3N1bW1hcnk/ZG9pPTEwLjEuMS40LjY5MjdcXG5cXHQgKi9cXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL0RpZmYgPSBfYmFzZTJbJ2RlZmF1bHQnXTtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmQ2hhcnMgPSBfY2hhcmFjdGVyLmRpZmZDaGFycztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmV29yZHMgPSBfd29yZC5kaWZmV29yZHM7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZldvcmRzV2l0aFNwYWNlID0gX3dvcmQuZGlmZldvcmRzV2l0aFNwYWNlO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZMaW5lcyA9IF9saW5lLmRpZmZMaW5lcztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmVHJpbW1lZExpbmVzID0gX2xpbmUuZGlmZlRyaW1tZWRMaW5lcztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmU2VudGVuY2VzID0gX3NlbnRlbmNlLmRpZmZTZW50ZW5jZXM7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkNzcyA9IF9jc3MuZGlmZkNzcztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmSnNvbiA9IF9qc29uLmRpZmZKc29uO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZBcnJheXMgPSBfYXJyYXkuZGlmZkFycmF5cztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9zdHJ1Y3R1cmVkUGF0Y2ggPSBfY3JlYXRlLnN0cnVjdHVyZWRQYXRjaDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jcmVhdGVUd29GaWxlc1BhdGNoID0gX2NyZWF0ZS5jcmVhdGVUd29GaWxlc1BhdGNoO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NyZWF0ZVBhdGNoID0gX2NyZWF0ZS5jcmVhdGVQYXRjaDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9hcHBseVBhdGNoID0gX2FwcGx5LmFwcGx5UGF0Y2g7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovYXBwbHlQYXRjaGVzID0gX2FwcGx5LmFwcGx5UGF0Y2hlcztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9wYXJzZVBhdGNoID0gX3BhcnNlLnBhcnNlUGF0Y2g7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovbWVyZ2UgPSBfbWVyZ2UubWVyZ2U7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY29udmVydENoYW5nZXNUb0RNUCA9IF9kbXAuY29udmVydENoYW5nZXNUb0RNUDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jb252ZXJ0Q2hhbmdlc1RvWE1MID0gX3htbC5jb252ZXJ0Q2hhbmdlc1RvWE1MO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Nhbm9uaWNhbGl6ZSA9IF9qc29uLmNhbm9uaWNhbGl6ZTtcXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAxICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzWydkZWZhdWx0J10gPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL0RpZmY7XFxuXFx0ZnVuY3Rpb24gRGlmZigpIHt9XFxuXFxuXFx0RGlmZi5wcm90b3R5cGUgPSB7XFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZjogZnVuY3Rpb24gZGlmZihvbGRTdHJpbmcsIG5ld1N0cmluZykge1xcblxcdCAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIC8qaXN0YW5idWwgaWdub3JlIGVuZCovb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XFxuXFxuXFx0ICAgIHZhciBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XFxuXFx0ICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdCAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcXG5cXHQgICAgICBvcHRpb25zID0ge307XFxuXFx0ICAgIH1cXG5cXHQgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcXG5cXG5cXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcblxcdCAgICBmdW5jdGlvbiBkb25lKHZhbHVlKSB7XFxuXFx0ICAgICAgaWYgKGNhbGxiYWNrKSB7XFxuXFx0ICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCB2YWx1ZSk7XFxuXFx0ICAgICAgICB9LCAwKTtcXG5cXHQgICAgICAgIHJldHVybiB0cnVlO1xcblxcdCAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICByZXR1cm4gdmFsdWU7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIEFsbG93IHN1YmNsYXNzZXMgdG8gbWFzc2FnZSB0aGUgaW5wdXQgcHJpb3IgdG8gcnVubmluZ1xcblxcdCAgICBvbGRTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChvbGRTdHJpbmcpO1xcblxcdCAgICBuZXdTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChuZXdTdHJpbmcpO1xcblxcblxcdCAgICBvbGRTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUob2xkU3RyaW5nKSk7XFxuXFx0ICAgIG5ld1N0cmluZyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShuZXdTdHJpbmcpKTtcXG5cXG5cXHQgICAgdmFyIG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsXFxuXFx0ICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoO1xcblxcdCAgICB2YXIgZWRpdExlbmd0aCA9IDE7XFxuXFx0ICAgIHZhciBtYXhFZGl0TGVuZ3RoID0gbmV3TGVuICsgb2xkTGVuO1xcblxcdCAgICB2YXIgYmVzdFBhdGggPSBbeyBuZXdQb3M6IC0xLCBjb21wb25lbnRzOiBbXSB9XTtcXG5cXG5cXHQgICAgLy8gU2VlZCBlZGl0TGVuZ3RoID0gMCwgaS5lLiB0aGUgY29udGVudCBzdGFydHMgd2l0aCB0aGUgc2FtZSB2YWx1ZXNcXG5cXHQgICAgdmFyIG9sZFBvcyA9IHRoaXMuZXh0cmFjdENvbW1vbihiZXN0UGF0aFswXSwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIDApO1xcblxcdCAgICBpZiAoYmVzdFBhdGhbMF0ubmV3UG9zICsgMSA+PSBuZXdMZW4gJiYgb2xkUG9zICsgMSA+PSBvbGRMZW4pIHtcXG5cXHQgICAgICAvLyBJZGVudGl0eSBwZXIgdGhlIGVxdWFsaXR5IGFuZCB0b2tlbml6ZXJcXG5cXHQgICAgICByZXR1cm4gZG9uZShbeyB2YWx1ZTogdGhpcy5qb2luKG5ld1N0cmluZyksIGNvdW50OiBuZXdTdHJpbmcubGVuZ3RoIH1dKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyBNYWluIHdvcmtlciBtZXRob2QuIGNoZWNrcyBhbGwgcGVybXV0YXRpb25zIG9mIGEgZ2l2ZW4gZWRpdCBsZW5ndGggZm9yIGFjY2VwdGFuY2UuXFxuXFx0ICAgIGZ1bmN0aW9uIGV4ZWNFZGl0TGVuZ3RoKCkge1xcblxcdCAgICAgIGZvciAodmFyIGRpYWdvbmFsUGF0aCA9IC0xICogZWRpdExlbmd0aDsgZGlhZ29uYWxQYXRoIDw9IGVkaXRMZW5ndGg7IGRpYWdvbmFsUGF0aCArPSAyKSB7XFxuXFx0ICAgICAgICB2YXIgYmFzZVBhdGggPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcdCAgICAgICAgdmFyIGFkZFBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSxcXG5cXHQgICAgICAgICAgICByZW1vdmVQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoICsgMV0sXFxuXFx0ICAgICAgICAgICAgX29sZFBvcyA9IChyZW1vdmVQYXRoID8gcmVtb3ZlUGF0aC5uZXdQb3MgOiAwKSAtIGRpYWdvbmFsUGF0aDtcXG5cXHQgICAgICAgIGlmIChhZGRQYXRoKSB7XFxuXFx0ICAgICAgICAgIC8vIE5vIG9uZSBlbHNlIGlzIGdvaW5nIHRvIGF0dGVtcHQgdG8gdXNlIHRoaXMgdmFsdWUsIGNsZWFyIGl0XFxuXFx0ICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aCAtIDFdID0gdW5kZWZpbmVkO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIGNhbkFkZCA9IGFkZFBhdGggJiYgYWRkUGF0aC5uZXdQb3MgKyAxIDwgbmV3TGVuLFxcblxcdCAgICAgICAgICAgIGNhblJlbW92ZSA9IHJlbW92ZVBhdGggJiYgMCA8PSBfb2xkUG9zICYmIF9vbGRQb3MgPCBvbGRMZW47XFxuXFx0ICAgICAgICBpZiAoIWNhbkFkZCAmJiAhY2FuUmVtb3ZlKSB7XFxuXFx0ICAgICAgICAgIC8vIElmIHRoaXMgcGF0aCBpcyBhIHRlcm1pbmFsIHRoZW4gcHJ1bmVcXG5cXHQgICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoXSA9IHVuZGVmaW5lZDtcXG5cXHQgICAgICAgICAgY29udGludWU7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAvLyBTZWxlY3QgdGhlIGRpYWdvbmFsIHRoYXQgd2Ugd2FudCB0byBicmFuY2ggZnJvbS4gV2Ugc2VsZWN0IHRoZSBwcmlvclxcblxcdCAgICAgICAgLy8gcGF0aCB3aG9zZSBwb3NpdGlvbiBpbiB0aGUgbmV3IHN0cmluZyBpcyB0aGUgZmFydGhlc3QgZnJvbSB0aGUgb3JpZ2luXFxuXFx0ICAgICAgICAvLyBhbmQgZG9lcyBub3QgcGFzcyB0aGUgYm91bmRzIG9mIHRoZSBkaWZmIGdyYXBoXFxuXFx0ICAgICAgICBpZiAoIWNhbkFkZCB8fCBjYW5SZW1vdmUgJiYgYWRkUGF0aC5uZXdQb3MgPCByZW1vdmVQYXRoLm5ld1Bvcykge1xcblxcdCAgICAgICAgICBiYXNlUGF0aCA9IGNsb25lUGF0aChyZW1vdmVQYXRoKTtcXG5cXHQgICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHVuZGVmaW5lZCwgdHJ1ZSk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICBiYXNlUGF0aCA9IGFkZFBhdGg7IC8vIE5vIG5lZWQgdG8gY2xvbmUsIHdlJ3ZlIHB1bGxlZCBpdCBmcm9tIHRoZSBsaXN0XFxuXFx0ICAgICAgICAgIGJhc2VQYXRoLm5ld1BvcysrO1xcblxcdCAgICAgICAgICBzZWxmLnB1c2hDb21wb25lbnQoYmFzZVBhdGguY29tcG9uZW50cywgdHJ1ZSwgdW5kZWZpbmVkKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIF9vbGRQb3MgPSBzZWxmLmV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBkaWFnb25hbFBhdGgpO1xcblxcblxcdCAgICAgICAgLy8gSWYgd2UgaGF2ZSBoaXQgdGhlIGVuZCBvZiBib3RoIHN0cmluZ3MsIHRoZW4gd2UgYXJlIGRvbmVcXG5cXHQgICAgICAgIGlmIChiYXNlUGF0aC5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBfb2xkUG9zICsgMSA+PSBvbGRMZW4pIHtcXG5cXHQgICAgICAgICAgcmV0dXJuIGRvbmUoYnVpbGRWYWx1ZXMoc2VsZiwgYmFzZVBhdGguY29tcG9uZW50cywgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIHNlbGYudXNlTG9uZ2VzdFRva2VuKSk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAvLyBPdGhlcndpc2UgdHJhY2sgdGhpcyBwYXRoIGFzIGEgcG90ZW50aWFsIGNhbmRpZGF0ZSBhbmQgY29udGludWUuXFxuXFx0ICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSBiYXNlUGF0aDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgZWRpdExlbmd0aCsrO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIFBlcmZvcm1zIHRoZSBsZW5ndGggb2YgZWRpdCBpdGVyYXRpb24uIElzIGEgYml0IGZ1Z2x5IGFzIHRoaXMgaGFzIHRvIHN1cHBvcnQgdGhlXFxuXFx0ICAgIC8vIHN5bmMgYW5kIGFzeW5jIG1vZGUgd2hpY2ggaXMgbmV2ZXIgZnVuLiBMb29wcyBvdmVyIGV4ZWNFZGl0TGVuZ3RoIHVudGlsIGEgdmFsdWVcXG5cXHQgICAgLy8gaXMgcHJvZHVjZWQuXFxuXFx0ICAgIGlmIChjYWxsYmFjaykge1xcblxcdCAgICAgIChmdW5jdGlvbiBleGVjKCkge1xcblxcdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4sIGJ1dCB3ZSB3YW50IHRvIGJlIHNhZmUuXFxuXFx0ICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXFxuXFx0ICAgICAgICAgIGlmIChlZGl0TGVuZ3RoID4gbWF4RWRpdExlbmd0aCkge1xcblxcdCAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xcblxcdCAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgIGlmICghZXhlY0VkaXRMZW5ndGgoKSkge1xcblxcdCAgICAgICAgICAgIGV4ZWMoKTtcXG5cXHQgICAgICAgICAgfVxcblxcdCAgICAgICAgfSwgMCk7XFxuXFx0ICAgICAgfSkoKTtcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICB3aGlsZSAoZWRpdExlbmd0aCA8PSBtYXhFZGl0TGVuZ3RoKSB7XFxuXFx0ICAgICAgICB2YXIgcmV0ID0gZXhlY0VkaXRMZW5ndGgoKTtcXG5cXHQgICAgICAgIGlmIChyZXQpIHtcXG5cXHQgICAgICAgICAgcmV0dXJuIHJldDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH0sXFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIC8qaXN0YW5idWwgaWdub3JlIGVuZCovcHVzaENvbXBvbmVudDogZnVuY3Rpb24gcHVzaENvbXBvbmVudChjb21wb25lbnRzLCBhZGRlZCwgcmVtb3ZlZCkge1xcblxcdCAgICB2YXIgbGFzdCA9IGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXTtcXG5cXHQgICAgaWYgKGxhc3QgJiYgbGFzdC5hZGRlZCA9PT0gYWRkZWQgJiYgbGFzdC5yZW1vdmVkID09PSByZW1vdmVkKSB7XFxuXFx0ICAgICAgLy8gV2UgbmVlZCB0byBjbG9uZSBoZXJlIGFzIHRoZSBjb21wb25lbnQgY2xvbmUgb3BlcmF0aW9uIGlzIGp1c3RcXG5cXHQgICAgICAvLyBhcyBzaGFsbG93IGFycmF5IGNsb25lXFxuXFx0ICAgICAgY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdID0geyBjb3VudDogbGFzdC5jb3VudCArIDEsIGFkZGVkOiBhZGRlZCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIGNvbXBvbmVudHMucHVzaCh7IGNvdW50OiAxLCBhZGRlZDogYWRkZWQsIHJlbW92ZWQ6IHJlbW92ZWQgfSk7XFxuXFx0ICAgIH1cXG5cXHQgIH0sXFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZXh0cmFjdENvbW1vbjogZnVuY3Rpb24gZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCkge1xcblxcdCAgICB2YXIgbmV3TGVuID0gbmV3U3RyaW5nLmxlbmd0aCxcXG5cXHQgICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGgsXFxuXFx0ICAgICAgICBuZXdQb3MgPSBiYXNlUGF0aC5uZXdQb3MsXFxuXFx0ICAgICAgICBvbGRQb3MgPSBuZXdQb3MgLSBkaWFnb25hbFBhdGgsXFxuXFx0ICAgICAgICBjb21tb25Db3VudCA9IDA7XFxuXFx0ICAgIHdoaWxlIChuZXdQb3MgKyAxIDwgbmV3TGVuICYmIG9sZFBvcyArIDEgPCBvbGRMZW4gJiYgdGhpcy5lcXVhbHMobmV3U3RyaW5nW25ld1BvcyArIDFdLCBvbGRTdHJpbmdbb2xkUG9zICsgMV0pKSB7XFxuXFx0ICAgICAgbmV3UG9zKys7XFxuXFx0ICAgICAgb2xkUG9zKys7XFxuXFx0ICAgICAgY29tbW9uQ291bnQrKztcXG5cXHQgICAgfVxcblxcblxcdCAgICBpZiAoY29tbW9uQ291bnQpIHtcXG5cXHQgICAgICBiYXNlUGF0aC5jb21wb25lbnRzLnB1c2goeyBjb3VudDogY29tbW9uQ291bnQgfSk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgYmFzZVBhdGgubmV3UG9zID0gbmV3UG9zO1xcblxcdCAgICByZXR1cm4gb2xkUG9zO1xcblxcdCAgfSxcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9lcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhsZWZ0LCByaWdodCkge1xcblxcdCAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhcmF0b3IpIHtcXG5cXHQgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNvbXBhcmF0b3IobGVmdCwgcmlnaHQpO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCB0aGlzLm9wdGlvbnMuaWdub3JlQ2FzZSAmJiBsZWZ0LnRvTG93ZXJDYXNlKCkgPT09IHJpZ2h0LnRvTG93ZXJDYXNlKCk7XFxuXFx0ICAgIH1cXG5cXHQgIH0sXFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIC8qaXN0YW5idWwgaWdub3JlIGVuZCovcmVtb3ZlRW1wdHk6IGZ1bmN0aW9uIHJlbW92ZUVtcHR5KGFycmF5KSB7XFxuXFx0ICAgIHZhciByZXQgPSBbXTtcXG5cXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgIGlmIChhcnJheVtpXSkge1xcblxcdCAgICAgICAgcmV0LnB1c2goYXJyYXlbaV0pO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgICByZXR1cm4gcmV0O1xcblxcdCAgfSxcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jYXN0SW5wdXQ6IGZ1bmN0aW9uIGNhc3RJbnB1dCh2YWx1ZSkge1xcblxcdCAgICByZXR1cm4gdmFsdWU7XFxuXFx0ICB9LFxcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3Rva2VuaXplOiBmdW5jdGlvbiB0b2tlbml6ZSh2YWx1ZSkge1xcblxcdCAgICByZXR1cm4gdmFsdWUuc3BsaXQoJycpO1xcblxcdCAgfSxcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9qb2luOiBmdW5jdGlvbiBqb2luKGNoYXJzKSB7XFxuXFx0ICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIGJ1aWxkVmFsdWVzKGRpZmYsIGNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCB1c2VMb25nZXN0VG9rZW4pIHtcXG5cXHQgIHZhciBjb21wb25lbnRQb3MgPSAwLFxcblxcdCAgICAgIGNvbXBvbmVudExlbiA9IGNvbXBvbmVudHMubGVuZ3RoLFxcblxcdCAgICAgIG5ld1BvcyA9IDAsXFxuXFx0ICAgICAgb2xkUG9zID0gMDtcXG5cXG5cXHQgIGZvciAoOyBjb21wb25lbnRQb3MgPCBjb21wb25lbnRMZW47IGNvbXBvbmVudFBvcysrKSB7XFxuXFx0ICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XFxuXFx0ICAgIGlmICghY29tcG9uZW50LnJlbW92ZWQpIHtcXG5cXHQgICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCAmJiB1c2VMb25nZXN0VG9rZW4pIHtcXG5cXHQgICAgICAgIHZhciB2YWx1ZSA9IG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCk7XFxuXFx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbiAodmFsdWUsIGkpIHtcXG5cXHQgICAgICAgICAgdmFyIG9sZFZhbHVlID0gb2xkU3RyaW5nW29sZFBvcyArIGldO1xcblxcdCAgICAgICAgICByZXR1cm4gb2xkVmFsdWUubGVuZ3RoID4gdmFsdWUubGVuZ3RoID8gb2xkVmFsdWUgOiB2YWx1ZTtcXG5cXHQgICAgICAgIH0pO1xcblxcblxcdCAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKHZhbHVlKTtcXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCkpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBuZXdQb3MgKz0gY29tcG9uZW50LmNvdW50O1xcblxcblxcdCAgICAgIC8vIENvbW1vbiBjYXNlXFxuXFx0ICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQpIHtcXG5cXHQgICAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbihvbGRTdHJpbmcuc2xpY2Uob2xkUG9zLCBvbGRQb3MgKyBjb21wb25lbnQuY291bnQpKTtcXG5cXHQgICAgICBvbGRQb3MgKz0gY29tcG9uZW50LmNvdW50O1xcblxcblxcdCAgICAgIC8vIFJldmVyc2UgYWRkIGFuZCByZW1vdmUgc28gcmVtb3ZlcyBhcmUgb3V0cHV0IGZpcnN0IHRvIG1hdGNoIGNvbW1vbiBjb252ZW50aW9uXFxuXFx0ICAgICAgLy8gVGhlIGRpZmZpbmcgYWxnb3JpdGhtIGlzIHRpZWQgdG8gYWRkIHRoZW4gcmVtb3ZlIG91dHB1dCBhbmQgdGhpcyBpcyB0aGUgc2ltcGxlc3RcXG5cXHQgICAgICAvLyByb3V0ZSB0byBnZXQgdGhlIGRlc2lyZWQgb3V0cHV0IHdpdGggbWluaW1hbCBvdmVyaGVhZC5cXG5cXHQgICAgICBpZiAoY29tcG9uZW50UG9zICYmIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0uYWRkZWQpIHtcXG5cXHQgICAgICAgIHZhciB0bXAgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdO1xcblxcdCAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXSA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcXG5cXHQgICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zXSA9IHRtcDtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIC8vIFNwZWNpYWwgY2FzZSBoYW5kbGUgZm9yIHdoZW4gb25lIHRlcm1pbmFsIGlzIGlnbm9yZWQgKGkuZS4gd2hpdGVzcGFjZSkuXFxuXFx0ICAvLyBGb3IgdGhpcyBjYXNlIHdlIG1lcmdlIHRoZSB0ZXJtaW5hbCBpbnRvIHRoZSBwcmlvciBzdHJpbmcgYW5kIGRyb3AgdGhlIGNoYW5nZS5cXG5cXHQgIC8vIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIHN0cmluZyBtb2RlLlxcblxcdCAgdmFyIGxhc3RDb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDFdO1xcblxcdCAgaWYgKGNvbXBvbmVudExlbiA+IDEgJiYgdHlwZW9mIGxhc3RDb21wb25lbnQudmFsdWUgPT09ICdzdHJpbmcnICYmIChsYXN0Q29tcG9uZW50LmFkZGVkIHx8IGxhc3RDb21wb25lbnQucmVtb3ZlZCkgJiYgZGlmZi5lcXVhbHMoJycsIGxhc3RDb21wb25lbnQudmFsdWUpKSB7XFxuXFx0ICAgIGNvbXBvbmVudHNbY29tcG9uZW50TGVuIC0gMl0udmFsdWUgKz0gbGFzdENvbXBvbmVudC52YWx1ZTtcXG5cXHQgICAgY29tcG9uZW50cy5wb3AoKTtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiBjb21wb25lbnRzO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBjbG9uZVBhdGgocGF0aCkge1xcblxcdCAgcmV0dXJuIHsgbmV3UG9zOiBwYXRoLm5ld1BvcywgY29tcG9uZW50czogcGF0aC5jb21wb25lbnRzLnNsaWNlKDApIH07XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDIgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuY2hhcmFjdGVyRGlmZiA9IHVuZGVmaW5lZDtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZDaGFycyA9IGRpZmZDaGFycztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcblxcdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciBjaGFyYWN0ZXJEaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY2hhcmFjdGVyRGlmZiA9IG5ldyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UyWydkZWZhdWx0J10gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oKTtcXG5cXHRmdW5jdGlvbiBkaWZmQ2hhcnMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcXG5cXHQgIHJldHVybiBjaGFyYWN0ZXJEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAzICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLndvcmREaWZmID0gdW5kZWZpbmVkO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZldvcmRzID0gZGlmZldvcmRzO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZXb3Jkc1dpdGhTcGFjZSA9IGRpZmZXb3Jkc1dpdGhTcGFjZTtcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fcGFyYW1zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovIC8vIEJhc2VkIG9uIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX3NjcmlwdF9pbl9Vbmljb2RlXFxuXFx0Ly9cXG5cXHQvLyBSYW5nZXMgYW5kIGV4Y2VwdGlvbnM6XFxuXFx0Ly8gTGF0aW4tMSBTdXBwbGVtZW50LCAwMDgw4oCTMDBGRlxcblxcdC8vICAtIFUrMDBENyAgw5cgTXVsdGlwbGljYXRpb24gc2lnblxcblxcdC8vICAtIFUrMDBGNyAgw7cgRGl2aXNpb24gc2lnblxcblxcdC8vIExhdGluIEV4dGVuZGVkLUEsIDAxMDDigJMwMTdGXFxuXFx0Ly8gTGF0aW4gRXh0ZW5kZWQtQiwgMDE4MOKAkzAyNEZcXG5cXHQvLyBJUEEgRXh0ZW5zaW9ucywgMDI1MOKAkzAyQUZcXG5cXHQvLyBTcGFjaW5nIE1vZGlmaWVyIExldHRlcnMsIDAyQjDigJMwMkZGXFxuXFx0Ly8gIC0gVSswMkM3ICDLhyAmIzcxMTsgIENhcm9uXFxuXFx0Ly8gIC0gVSswMkQ4ICDLmCAmIzcyODsgIEJyZXZlXFxuXFx0Ly8gIC0gVSswMkQ5ICDLmSAmIzcyOTsgIERvdCBBYm92ZVxcblxcdC8vICAtIFUrMDJEQSAgy5ogJiM3MzA7ICBSaW5nIEFib3ZlXFxuXFx0Ly8gIC0gVSswMkRCICDLmyAmIzczMTsgIE9nb25la1xcblxcdC8vICAtIFUrMDJEQyAgy5wgJiM3MzI7ICBTbWFsbCBUaWxkZVxcblxcdC8vICAtIFUrMDJERCAgy50gJiM3MzM7ICBEb3VibGUgQWN1dGUgQWNjZW50XFxuXFx0Ly8gTGF0aW4gRXh0ZW5kZWQgQWRkaXRpb25hbCwgMUUwMOKAkzFFRkZcXG5cXHR2YXIgZXh0ZW5kZWRXb3JkQ2hhcnMgPSAvXltBLVphLXpcXFxceEMwLVxcXFx1MDJDNlxcXFx1MDJDOC1cXFxcdTAyRDdcXFxcdTAyREUtXFxcXHUwMkZGXFxcXHUxRTAwLVxcXFx1MUVGRl0rJC87XFxuXFxuXFx0dmFyIHJlV2hpdGVzcGFjZSA9IC9cXFxcUy87XFxuXFxuXFx0dmFyIHdvcmREaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovd29yZERpZmYgPSBuZXcgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCk7XFxuXFx0d29yZERpZmYuZXF1YWxzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XFxuXFx0ICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUNhc2UpIHtcXG5cXHQgICAgbGVmdCA9IGxlZnQudG9Mb3dlckNhc2UoKTtcXG5cXHQgICAgcmlnaHQgPSByaWdodC50b0xvd2VyQ2FzZSgpO1xcblxcdCAgfVxcblxcdCAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IHRoaXMub3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlICYmICFyZVdoaXRlc3BhY2UudGVzdChsZWZ0KSAmJiAhcmVXaGl0ZXNwYWNlLnRlc3QocmlnaHQpO1xcblxcdH07XFxuXFx0d29yZERpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG5cXHQgIHZhciB0b2tlbnMgPSB2YWx1ZS5zcGxpdCgvKFxcXFxzK3xcXFxcYikvKTtcXG5cXG5cXHQgIC8vIEpvaW4gdGhlIGJvdW5kYXJ5IHNwbGl0cyB0aGF0IHdlIGRvIG5vdCBjb25zaWRlciB0byBiZSBib3VuZGFyaWVzLiBUaGlzIGlzIHByaW1hcmlseSB0aGUgZXh0ZW5kZWQgTGF0aW4gY2hhcmFjdGVyIHNldC5cXG5cXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aCAtIDE7IGkrKykge1xcblxcdCAgICAvLyBJZiB3ZSBoYXZlIGFuIGVtcHR5IHN0cmluZyBpbiB0aGUgbmV4dCBmaWVsZCBhbmQgd2UgaGF2ZSBvbmx5IHdvcmQgY2hhcnMgYmVmb3JlIGFuZCBhZnRlciwgbWVyZ2VcXG5cXHQgICAgaWYgKCF0b2tlbnNbaSArIDFdICYmIHRva2Vuc1tpICsgMl0gJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaV0pICYmIGV4dGVuZGVkV29yZENoYXJzLnRlc3QodG9rZW5zW2kgKyAyXSkpIHtcXG5cXHQgICAgICB0b2tlbnNbaV0gKz0gdG9rZW5zW2kgKyAyXTtcXG5cXHQgICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAyKTtcXG5cXHQgICAgICBpLS07XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiB0b2tlbnM7XFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBkaWZmV29yZHMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcXG5cXHQgIG9wdGlvbnMgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9wYXJhbXMuZ2VuZXJhdGVPcHRpb25zKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyhvcHRpb25zLCB7IGlnbm9yZVdoaXRlc3BhY2U6IHRydWUgfSk7XFxuXFx0ICByZXR1cm4gd29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGRpZmZXb3Jkc1dpdGhTcGFjZShvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xcblxcdCAgcmV0dXJuIHdvcmREaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiA0ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2dlbmVyYXRlT3B0aW9ucyA9IGdlbmVyYXRlT3B0aW9ucztcXG5cXHRmdW5jdGlvbiBnZW5lcmF0ZU9wdGlvbnMob3B0aW9ucywgZGVmYXVsdHMpIHtcXG5cXHQgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdCAgICBkZWZhdWx0cy5jYWxsYmFjayA9IG9wdGlvbnM7XFxuXFx0ICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcXG5cXHQgICAgZm9yICh2YXIgbmFtZSBpbiBvcHRpb25zKSB7XFxuXFx0ICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG5cXHQgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xcblxcdCAgICAgICAgZGVmYXVsdHNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdCAgcmV0dXJuIGRlZmF1bHRzO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiA1ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLmxpbmVEaWZmID0gdW5kZWZpbmVkO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkxpbmVzID0gZGlmZkxpbmVzO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZUcmltbWVkTGluZXMgPSBkaWZmVHJpbW1lZExpbmVzO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19wYXJhbXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgbGluZURpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9saW5lRGlmZiA9IG5ldyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UyWydkZWZhdWx0J10gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oKTtcXG5cXHRsaW5lRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdCAgdmFyIHJldExpbmVzID0gW10sXFxuXFx0ICAgICAgbGluZXNBbmROZXdsaW5lcyA9IHZhbHVlLnNwbGl0KC8oXFxcXG58XFxcXHJcXFxcbikvKTtcXG5cXG5cXHQgIC8vIElnbm9yZSB0aGUgZmluYWwgZW1wdHkgdG9rZW4gdGhhdCBvY2N1cnMgaWYgdGhlIHN0cmluZyBlbmRzIHdpdGggYSBuZXcgbGluZVxcblxcdCAgaWYgKCFsaW5lc0FuZE5ld2xpbmVzW2xpbmVzQW5kTmV3bGluZXMubGVuZ3RoIC0gMV0pIHtcXG5cXHQgICAgbGluZXNBbmROZXdsaW5lcy5wb3AoKTtcXG5cXHQgIH1cXG5cXG5cXHQgIC8vIE1lcmdlIHRoZSBjb250ZW50IGFuZCBsaW5lIHNlcGFyYXRvcnMgaW50byBzaW5nbGUgdG9rZW5zXFxuXFx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzQW5kTmV3bGluZXMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgdmFyIGxpbmUgPSBsaW5lc0FuZE5ld2xpbmVzW2ldO1xcblxcblxcdCAgICBpZiAoaSAlIDIgJiYgIXRoaXMub3B0aW9ucy5uZXdsaW5lSXNUb2tlbikge1xcblxcdCAgICAgIHJldExpbmVzW3JldExpbmVzLmxlbmd0aCAtIDFdICs9IGxpbmU7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlKSB7XFxuXFx0ICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIHJldExpbmVzLnB1c2gobGluZSk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiByZXRMaW5lcztcXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIGRpZmZMaW5lcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcXG5cXHQgIHJldHVybiBsaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XFxuXFx0fVxcblxcdGZ1bmN0aW9uIGRpZmZUcmltbWVkTGluZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XFxuXFx0ICB2YXIgb3B0aW9ucyA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX3BhcmFtcy5nZW5lcmF0ZU9wdGlvbnMpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKGNhbGxiYWNrLCB7IGlnbm9yZVdoaXRlc3BhY2U6IHRydWUgfSk7XFxuXFx0ICByZXR1cm4gbGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDYgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuc2VudGVuY2VEaWZmID0gdW5kZWZpbmVkO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZlNlbnRlbmNlcyA9IGRpZmZTZW50ZW5jZXM7XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcXG5cXG5cXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgc2VudGVuY2VEaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovc2VudGVuY2VEaWZmID0gbmV3IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZTJbJ2RlZmF1bHQnXSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLygpO1xcblxcdHNlbnRlbmNlRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdCAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oXFxcXFMuKz9bLiE/XSkoPz1cXFxccyt8JCkvKTtcXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIGRpZmZTZW50ZW5jZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XFxuXFx0ICByZXR1cm4gc2VudGVuY2VEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogNyAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy5jc3NEaWZmID0gdW5kZWZpbmVkO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkNzcyA9IGRpZmZDc3M7XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcXG5cXG5cXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgY3NzRGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Nzc0RpZmYgPSBuZXcgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCk7XFxuXFx0Y3NzRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdCAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oW3t9OjssXXxcXFxccyspLyk7XFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBkaWZmQ3NzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xcblxcdCAgcmV0dXJuIGNzc0RpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiA4ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLmpzb25EaWZmID0gdW5kZWZpbmVkO1xcblxcblxcdHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07XFxuXFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmSnNvbiA9IGRpZmZKc29uO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Nhbm9uaWNhbGl6ZSA9IGNhbm9uaWNhbGl6ZTtcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciBvYmplY3RQcm90b3R5cGVUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XFxuXFxuXFx0dmFyIGpzb25EaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovanNvbkRpZmYgPSBuZXcgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCk7XFxuXFx0Ly8gRGlzY3JpbWluYXRlIGJldHdlZW4gdHdvIGxpbmVzIG9mIHByZXR0eS1wcmludGVkLCBzZXJpYWxpemVkIEpTT04gd2hlcmUgb25lIG9mIHRoZW0gaGFzIGFcXG5cXHQvLyBkYW5nbGluZyBjb21tYSBhbmQgdGhlIG90aGVyIGRvZXNuJ3QuIFR1cm5zIG91dCBpbmNsdWRpbmcgdGhlIGRhbmdsaW5nIGNvbW1hIHlpZWxkcyB0aGUgbmljZXN0IG91dHB1dDpcXG5cXHRqc29uRGlmZi51c2VMb25nZXN0VG9rZW4gPSB0cnVlO1xcblxcblxcdGpzb25EaWZmLnRva2VuaXplID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19saW5lLmxpbmVEaWZmIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLnRva2VuaXplO1xcblxcdGpzb25EaWZmLmNhc3RJbnB1dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfb3B0aW9ucyA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovdGhpcy5vcHRpb25zLFxcblxcdCAgICAgIHVuZGVmaW5lZFJlcGxhY2VtZW50ID0gX29wdGlvbnMudW5kZWZpbmVkUmVwbGFjZW1lbnQsXFxuXFx0ICAgICAgX29wdGlvbnMkc3RyaW5naWZ5UmVwID0gX29wdGlvbnMuc3RyaW5naWZ5UmVwbGFjZXIsXFxuXFx0ICAgICAgc3RyaW5naWZ5UmVwbGFjZXIgPSBfb3B0aW9ucyRzdHJpbmdpZnlSZXAgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChrLCB2KSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCove1xcblxcdCAgICByZXR1cm4gKC8qaXN0YW5idWwgaWdub3JlIGVuZCovdHlwZW9mIHYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkUmVwbGFjZW1lbnQgOiB2XFxuXFx0ICAgICk7XFxuXFx0ICB9IDogX29wdGlvbnMkc3RyaW5naWZ5UmVwO1xcblxcblxcblxcdCAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KGNhbm9uaWNhbGl6ZSh2YWx1ZSwgbnVsbCwgbnVsbCwgc3RyaW5naWZ5UmVwbGFjZXIpLCBzdHJpbmdpZnlSZXBsYWNlciwgJyAgJyk7XFxuXFx0fTtcXG5cXHRqc29uRGlmZi5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcXG5cXHQgIHJldHVybiAoLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLnByb3RvdHlwZS5lcXVhbHMuY2FsbChqc29uRGlmZiwgbGVmdC5yZXBsYWNlKC8sKFtcXFxcclxcXFxuXSkvZywgJyQxJyksIHJpZ2h0LnJlcGxhY2UoLywoW1xcXFxyXFxcXG5dKS9nLCAnJDEnKSlcXG5cXHQgICk7XFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBkaWZmSnNvbihvbGRPYmosIG5ld09iaiwgb3B0aW9ucykge1xcblxcdCAgcmV0dXJuIGpzb25EaWZmLmRpZmYob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpO1xcblxcdH1cXG5cXG5cXHQvLyBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIHByZXNlbmNlIG9mIGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgYmFpbGluZyBvdXQgd2hlbiBlbmNvdW50ZXJpbmcgYW5cXG5cXHQvLyBvYmplY3QgdGhhdCBpcyBhbHJlYWR5IG9uIHRoZSBcXFwic3RhY2tcXFwiIG9mIGl0ZW1zIGJlaW5nIHByb2Nlc3NlZC4gQWNjZXB0cyBhbiBvcHRpb25hbCByZXBsYWNlclxcblxcdGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZShvYmosIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwga2V5KSB7XFxuXFx0ICBzdGFjayA9IHN0YWNrIHx8IFtdO1xcblxcdCAgcmVwbGFjZW1lbnRTdGFjayA9IHJlcGxhY2VtZW50U3RhY2sgfHwgW107XFxuXFxuXFx0ICBpZiAocmVwbGFjZXIpIHtcXG5cXHQgICAgb2JqID0gcmVwbGFjZXIoa2V5LCBvYmopO1xcblxcdCAgfVxcblxcblxcdCAgdmFyIGkgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdCAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSArPSAxKSB7XFxuXFx0ICAgIGlmIChzdGFja1tpXSA9PT0gb2JqKSB7XFxuXFx0ICAgICAgcmV0dXJuIHJlcGxhY2VtZW50U3RhY2tbaV07XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIHZhciBjYW5vbmljYWxpemVkT2JqID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQgIGlmICgnW29iamVjdCBBcnJheV0nID09PSBvYmplY3RQcm90b3R5cGVUb1N0cmluZy5jYWxsKG9iaikpIHtcXG5cXHQgICAgc3RhY2sucHVzaChvYmopO1xcblxcdCAgICBjYW5vbmljYWxpemVkT2JqID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xcblxcdCAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XFxuXFx0ICAgIGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpICs9IDEpIHtcXG5cXHQgICAgICBjYW5vbmljYWxpemVkT2JqW2ldID0gY2Fub25pY2FsaXplKG9ialtpXSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpO1xcblxcdCAgICB9XFxuXFx0ICAgIHN0YWNrLnBvcCgpO1xcblxcdCAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xcblxcdCAgICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmIChvYmogJiYgb2JqLnRvSlNPTikge1xcblxcdCAgICBvYmogPSBvYmoudG9KU09OKCk7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAoIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8odHlwZW9mIC8qaXN0YW5idWwgaWdub3JlIGVuZCovb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XFxuXFx0ICAgIHN0YWNrLnB1c2gob2JqKTtcXG5cXHQgICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xcblxcdCAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XFxuXFx0ICAgIHZhciBzb3J0ZWRLZXlzID0gW10sXFxuXFx0ICAgICAgICBfa2V5ID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXHQgICAgZm9yIChfa2V5IGluIG9iaikge1xcblxcdCAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXFxuXFx0ICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShfa2V5KSkge1xcblxcdCAgICAgICAgc29ydGVkS2V5cy5wdXNoKF9rZXkpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgICBzb3J0ZWRLZXlzLnNvcnQoKTtcXG5cXHQgICAgZm9yIChpID0gMDsgaSA8IHNvcnRlZEtleXMubGVuZ3RoOyBpICs9IDEpIHtcXG5cXHQgICAgICBfa2V5ID0gc29ydGVkS2V5c1tpXTtcXG5cXHQgICAgICBjYW5vbmljYWxpemVkT2JqW19rZXldID0gY2Fub25pY2FsaXplKG9ialtfa2V5XSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBfa2V5KTtcXG5cXHQgICAgfVxcblxcdCAgICBzdGFjay5wb3AoKTtcXG5cXHQgICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcXG5cXHQgIH0gZWxzZSB7XFxuXFx0ICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBvYmo7XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogOSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy5hcnJheURpZmYgPSB1bmRlZmluZWQ7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmQXJyYXlzID0gZGlmZkFycmF5cztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcblxcdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciBhcnJheURpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9hcnJheURpZmYgPSBuZXcgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCk7XFxuXFx0YXJyYXlEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuXFx0ICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcXG5cXHR9O1xcblxcdGFycmF5RGlmZi5qb2luID0gYXJyYXlEaWZmLnJlbW92ZUVtcHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuXFx0ICByZXR1cm4gdmFsdWU7XFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBkaWZmQXJyYXlzKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjaykge1xcblxcdCAgcmV0dXJuIGFycmF5RGlmZi5kaWZmKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjayk7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDEwICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2FwcGx5UGF0Y2ggPSBhcHBseVBhdGNoO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2FwcGx5UGF0Y2hlcyA9IGFwcGx5UGF0Y2hlcztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19wYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Rpc3RhbmNlSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9kaXN0YW5jZUl0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc3RhbmNlSXRlcmF0b3IpO1xcblxcblxcdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Z1bmN0aW9uIGFwcGx5UGF0Y2goc291cmNlLCB1bmlEaWZmKSB7XFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIC8qaXN0YW5idWwgaWdub3JlIGVuZCovb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XFxuXFxuXFx0ICBpZiAodHlwZW9mIHVuaURpZmYgPT09ICdzdHJpbmcnKSB7XFxuXFx0ICAgIHVuaURpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9wYXJzZS5wYXJzZVBhdGNoKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyh1bmlEaWZmKTtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmIChBcnJheS5pc0FycmF5KHVuaURpZmYpKSB7XFxuXFx0ICAgIGlmICh1bmlEaWZmLmxlbmd0aCA+IDEpIHtcXG5cXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FwcGx5UGF0Y2ggb25seSB3b3JrcyB3aXRoIGEgc2luZ2xlIGlucHV0LicpO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIHVuaURpZmYgPSB1bmlEaWZmWzBdO1xcblxcdCAgfVxcblxcblxcdCAgLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIGlucHV0XFxuXFx0ICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xcXFxyXFxcXG58W1xcXFxuXFxcXHZcXFxcZlxcXFxyXFxcXHg4NV0vKSxcXG5cXHQgICAgICBkZWxpbWl0ZXJzID0gc291cmNlLm1hdGNoKC9cXFxcclxcXFxufFtcXFxcblxcXFx2XFxcXGZcXFxcclxcXFx4ODVdL2cpIHx8IFtdLFxcblxcdCAgICAgIGh1bmtzID0gdW5pRGlmZi5odW5rcyxcXG5cXHQgICAgICBjb21wYXJlTGluZSA9IG9wdGlvbnMuY29tcGFyZUxpbmUgfHwgZnVuY3Rpb24gKGxpbmVOdW1iZXIsIGxpbmUsIG9wZXJhdGlvbiwgcGF0Y2hDb250ZW50KSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCove1xcblxcdCAgICByZXR1cm4gKC8qaXN0YW5idWwgaWdub3JlIGVuZCovbGluZSA9PT0gcGF0Y2hDb250ZW50XFxuXFx0ICAgICk7XFxuXFx0ICB9LFxcblxcdCAgICAgIGVycm9yQ291bnQgPSAwLFxcblxcdCAgICAgIGZ1enpGYWN0b3IgPSBvcHRpb25zLmZ1enpGYWN0b3IgfHwgMCxcXG5cXHQgICAgICBtaW5MaW5lID0gMCxcXG5cXHQgICAgICBvZmZzZXQgPSAwLFxcblxcdCAgICAgIHJlbW92ZUVPRk5MID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyxcXG5cXHQgICAgICBhZGRFT0ZOTCA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92b2lkIDAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0ICAvKipcXG5cXHQgICAqIENoZWNrcyBpZiB0aGUgaHVuayBleGFjdGx5IGZpdHMgb24gdGhlIHByb3ZpZGVkIGxvY2F0aW9uXFxuXFx0ICAgKi9cXG5cXHQgIGZ1bmN0aW9uIGh1bmtGaXRzKGh1bmssIHRvUG9zKSB7XFxuXFx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xcblxcdCAgICAgIHZhciBsaW5lID0gaHVuay5saW5lc1tqXSxcXG5cXHQgICAgICAgICAgb3BlcmF0aW9uID0gbGluZS5sZW5ndGggPiAwID8gbGluZVswXSA6ICcgJyxcXG5cXHQgICAgICAgICAgY29udGVudCA9IGxpbmUubGVuZ3RoID4gMCA/IGxpbmUuc3Vic3RyKDEpIDogbGluZTtcXG5cXG5cXHQgICAgICBpZiAob3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnLScpIHtcXG5cXHQgICAgICAgIC8vIENvbnRleHQgc2FuaXR5IGNoZWNrXFxuXFx0ICAgICAgICBpZiAoIWNvbXBhcmVMaW5lKHRvUG9zICsgMSwgbGluZXNbdG9Qb3NdLCBvcGVyYXRpb24sIGNvbnRlbnQpKSB7XFxuXFx0ICAgICAgICAgIGVycm9yQ291bnQrKztcXG5cXG5cXHQgICAgICAgICAgaWYgKGVycm9yQ291bnQgPiBmdXp6RmFjdG9yKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0b1BvcysrO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcblxcdCAgICByZXR1cm4gdHJ1ZTtcXG5cXHQgIH1cXG5cXG5cXHQgIC8vIFNlYXJjaCBiZXN0IGZpdCBvZmZzZXRzIGZvciBlYWNoIGh1bmsgYmFzZWQgb24gdGhlIHByZXZpb3VzIG9uZXNcXG5cXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgaHVua3MubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgdmFyIGh1bmsgPSBodW5rc1tpXSxcXG5cXHQgICAgICAgIG1heExpbmUgPSBsaW5lcy5sZW5ndGggLSBodW5rLm9sZExpbmVzLFxcblxcdCAgICAgICAgbG9jYWxPZmZzZXQgPSAwLFxcblxcdCAgICAgICAgdG9Qb3MgPSBvZmZzZXQgKyBodW5rLm9sZFN0YXJ0IC0gMTtcXG5cXG5cXHQgICAgdmFyIGl0ZXJhdG9yID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfZGlzdGFuY2VJdGVyYXRvcjJbJ2RlZmF1bHQnXSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8odG9Qb3MsIG1pbkxpbmUsIG1heExpbmUpO1xcblxcblxcdCAgICBmb3IgKDsgbG9jYWxPZmZzZXQgIT09IHVuZGVmaW5lZDsgbG9jYWxPZmZzZXQgPSBpdGVyYXRvcigpKSB7XFxuXFx0ICAgICAgaWYgKGh1bmtGaXRzKGh1bmssIHRvUG9zICsgbG9jYWxPZmZzZXQpKSB7XFxuXFx0ICAgICAgICBodW5rLm9mZnNldCA9IG9mZnNldCArPSBsb2NhbE9mZnNldDtcXG5cXHQgICAgICAgIGJyZWFrO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcblxcdCAgICBpZiAobG9jYWxPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xcblxcdCAgICAgIHJldHVybiBmYWxzZTtcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyBTZXQgbG93ZXIgdGV4dCBsaW1pdCB0byBlbmQgb2YgdGhlIGN1cnJlbnQgaHVuaywgc28gbmV4dCBvbmVzIGRvbid0IHRyeVxcblxcdCAgICAvLyB0byBmaXQgb3ZlciBhbHJlYWR5IHBhdGNoZWQgdGV4dFxcblxcdCAgICBtaW5MaW5lID0gaHVuay5vZmZzZXQgKyBodW5rLm9sZFN0YXJ0ICsgaHVuay5vbGRMaW5lcztcXG5cXHQgIH1cXG5cXG5cXHQgIC8vIEFwcGx5IHBhdGNoIGh1bmtzXFxuXFx0ICB2YXIgZGlmZk9mZnNldCA9IDA7XFxuXFx0ICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaHVua3MubGVuZ3RoOyBfaSsrKSB7XFxuXFx0ICAgIHZhciBfaHVuayA9IGh1bmtzW19pXSxcXG5cXHQgICAgICAgIF90b1BvcyA9IF9odW5rLm9sZFN0YXJ0ICsgX2h1bmsub2Zmc2V0ICsgZGlmZk9mZnNldCAtIDE7XFxuXFx0ICAgIGRpZmZPZmZzZXQgKz0gX2h1bmsubmV3TGluZXMgLSBfaHVuay5vbGRMaW5lcztcXG5cXG5cXHQgICAgaWYgKF90b1BvcyA8IDApIHtcXG5cXHQgICAgICAvLyBDcmVhdGluZyBhIG5ldyBmaWxlXFxuXFx0ICAgICAgX3RvUG9zID0gMDtcXG5cXHQgICAgfVxcblxcblxcdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9odW5rLmxpbmVzLmxlbmd0aDsgaisrKSB7XFxuXFx0ICAgICAgdmFyIGxpbmUgPSBfaHVuay5saW5lc1tqXSxcXG5cXHQgICAgICAgICAgb3BlcmF0aW9uID0gbGluZS5sZW5ndGggPiAwID8gbGluZVswXSA6ICcgJyxcXG5cXHQgICAgICAgICAgY29udGVudCA9IGxpbmUubGVuZ3RoID4gMCA/IGxpbmUuc3Vic3RyKDEpIDogbGluZSxcXG5cXHQgICAgICAgICAgZGVsaW1pdGVyID0gX2h1bmsubGluZWRlbGltaXRlcnNbal07XFxuXFxuXFx0ICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJyAnKSB7XFxuXFx0ICAgICAgICBfdG9Qb3MrKztcXG5cXHQgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJy0nKSB7XFxuXFx0ICAgICAgICBsaW5lcy5zcGxpY2UoX3RvUG9zLCAxKTtcXG5cXHQgICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKF90b1BvcywgMSk7XFxuXFx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xcblxcdCAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnKycpIHtcXG5cXHQgICAgICAgIGxpbmVzLnNwbGljZShfdG9Qb3MsIDAsIGNvbnRlbnQpO1xcblxcdCAgICAgICAgZGVsaW1pdGVycy5zcGxpY2UoX3RvUG9zLCAwLCBkZWxpbWl0ZXIpO1xcblxcdCAgICAgICAgX3RvUG9zKys7XFxuXFx0ICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICdcXFxcXFxcXCcpIHtcXG5cXHQgICAgICAgIHZhciBwcmV2aW91c09wZXJhdGlvbiA9IF9odW5rLmxpbmVzW2ogLSAxXSA/IF9odW5rLmxpbmVzW2ogLSAxXVswXSA6IG51bGw7XFxuXFx0ICAgICAgICBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICcrJykge1xcblxcdCAgICAgICAgICByZW1vdmVFT0ZOTCA9IHRydWU7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzT3BlcmF0aW9uID09PSAnLScpIHtcXG5cXHQgICAgICAgICAgYWRkRU9GTkwgPSB0cnVlO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgLy8gSGFuZGxlIEVPRk5MIGluc2VydGlvbi9yZW1vdmFsXFxuXFx0ICBpZiAocmVtb3ZlRU9GTkwpIHtcXG5cXHQgICAgd2hpbGUgKCFsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkge1xcblxcdCAgICAgIGxpbmVzLnBvcCgpO1xcblxcdCAgICAgIGRlbGltaXRlcnMucG9wKCk7XFxuXFx0ICAgIH1cXG5cXHQgIH0gZWxzZSBpZiAoYWRkRU9GTkwpIHtcXG5cXHQgICAgbGluZXMucHVzaCgnJyk7XFxuXFx0ICAgIGRlbGltaXRlcnMucHVzaCgnXFxcXG4nKTtcXG5cXHQgIH1cXG5cXHQgIGZvciAodmFyIF9rID0gMDsgX2sgPCBsaW5lcy5sZW5ndGggLSAxOyBfaysrKSB7XFxuXFx0ICAgIGxpbmVzW19rXSA9IGxpbmVzW19rXSArIGRlbGltaXRlcnNbX2tdO1xcblxcdCAgfVxcblxcdCAgcmV0dXJuIGxpbmVzLmpvaW4oJycpO1xcblxcdH1cXG5cXG5cXHQvLyBXcmFwcGVyIHRoYXQgc3VwcG9ydHMgbXVsdGlwbGUgZmlsZSBwYXRjaGVzIHZpYSBjYWxsYmFja3MuXFxuXFx0ZnVuY3Rpb24gYXBwbHlQYXRjaGVzKHVuaURpZmYsIG9wdGlvbnMpIHtcXG5cXHQgIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcXG5cXHQgICAgdW5pRGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX3BhcnNlLnBhcnNlUGF0Y2gpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKHVuaURpZmYpO1xcblxcdCAgfVxcblxcblxcdCAgdmFyIGN1cnJlbnRJbmRleCA9IDA7XFxuXFx0ICBmdW5jdGlvbiBwcm9jZXNzSW5kZXgoKSB7XFxuXFx0ICAgIHZhciBpbmRleCA9IHVuaURpZmZbY3VycmVudEluZGV4KytdO1xcblxcdCAgICBpZiAoIWluZGV4KSB7XFxuXFx0ICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICBvcHRpb25zLmxvYWRGaWxlKGluZGV4LCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XFxuXFx0ICAgICAgaWYgKGVycikge1xcblxcdCAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoZXJyKTtcXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgdmFyIHVwZGF0ZWRDb250ZW50ID0gYXBwbHlQYXRjaChkYXRhLCBpbmRleCwgb3B0aW9ucyk7XFxuXFx0ICAgICAgb3B0aW9ucy5wYXRjaGVkKGluZGV4LCB1cGRhdGVkQ29udGVudCwgZnVuY3Rpb24gKGVycikge1xcblxcdCAgICAgICAgaWYgKGVycikge1xcblxcdCAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZShlcnIpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgcHJvY2Vzc0luZGV4KCk7XFxuXFx0ICAgICAgfSk7XFxuXFx0ICAgIH0pO1xcblxcdCAgfVxcblxcdCAgcHJvY2Vzc0luZGV4KCk7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDExICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3BhcnNlUGF0Y2ggPSBwYXJzZVBhdGNoO1xcblxcdGZ1bmN0aW9uIHBhcnNlUGF0Y2godW5pRGlmZikge1xcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL29wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xcblxcblxcdCAgdmFyIGRpZmZzdHIgPSB1bmlEaWZmLnNwbGl0KC9cXFxcclxcXFxufFtcXFxcblxcXFx2XFxcXGZcXFxcclxcXFx4ODVdLyksXFxuXFx0ICAgICAgZGVsaW1pdGVycyA9IHVuaURpZmYubWF0Y2goL1xcXFxyXFxcXG58W1xcXFxuXFxcXHZcXFxcZlxcXFxyXFxcXHg4NV0vZykgfHwgW10sXFxuXFx0ICAgICAgbGlzdCA9IFtdLFxcblxcdCAgICAgIGkgPSAwO1xcblxcblxcdCAgZnVuY3Rpb24gcGFyc2VJbmRleCgpIHtcXG5cXHQgICAgdmFyIGluZGV4ID0ge307XFxuXFx0ICAgIGxpc3QucHVzaChpbmRleCk7XFxuXFxuXFx0ICAgIC8vIFBhcnNlIGRpZmYgbWV0YWRhdGFcXG5cXHQgICAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xcblxcdCAgICAgIHZhciBsaW5lID0gZGlmZnN0cltpXTtcXG5cXG5cXHQgICAgICAvLyBGaWxlIGhlYWRlciBmb3VuZCwgZW5kIHBhcnNpbmcgZGlmZiBtZXRhZGF0YVxcblxcdCAgICAgIGlmICgvXihcXFxcLVxcXFwtXFxcXC18XFxcXCtcXFxcK1xcXFwrfEBAKVxcXFxzLy50ZXN0KGxpbmUpKSB7XFxuXFx0ICAgICAgICBicmVhaztcXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgLy8gRGlmZiBpbmRleFxcblxcdCAgICAgIHZhciBoZWFkZXIgPSAvXig/OkluZGV4OnxkaWZmKD86IC1yIFxcXFx3KykrKVxcXFxzKyguKz8pXFxcXHMqJC8uZXhlYyhsaW5lKTtcXG5cXHQgICAgICBpZiAoaGVhZGVyKSB7XFxuXFx0ICAgICAgICBpbmRleC5pbmRleCA9IGhlYWRlclsxXTtcXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgaSsrO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIFBhcnNlIGZpbGUgaGVhZGVycyBpZiB0aGV5IGFyZSBkZWZpbmVkLiBVbmlmaWVkIGRpZmYgcmVxdWlyZXMgdGhlbSwgYnV0XFxuXFx0ICAgIC8vIHRoZXJlJ3Mgbm8gdGVjaG5pY2FsIGlzc3VlcyB0byBoYXZlIGFuIGlzb2xhdGVkIGh1bmsgd2l0aG91dCBmaWxlIGhlYWRlclxcblxcdCAgICBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpO1xcblxcdCAgICBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpO1xcblxcblxcdCAgICAvLyBQYXJzZSBodW5rc1xcblxcdCAgICBpbmRleC5odW5rcyA9IFtdO1xcblxcblxcdCAgICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XFxuXFx0ICAgICAgdmFyIF9saW5lID0gZGlmZnN0cltpXTtcXG5cXG5cXHQgICAgICBpZiAoL14oSW5kZXg6fGRpZmZ8XFxcXC1cXFxcLVxcXFwtfFxcXFwrXFxcXCtcXFxcKylcXFxccy8udGVzdChfbGluZSkpIHtcXG5cXHQgICAgICAgIGJyZWFrO1xcblxcdCAgICAgIH0gZWxzZSBpZiAoL15AQC8udGVzdChfbGluZSkpIHtcXG5cXHQgICAgICAgIGluZGV4Lmh1bmtzLnB1c2gocGFyc2VIdW5rKCkpO1xcblxcdCAgICAgIH0gZWxzZSBpZiAoX2xpbmUgJiYgb3B0aW9ucy5zdHJpY3QpIHtcXG5cXHQgICAgICAgIC8vIElnbm9yZSB1bmV4cGVjdGVkIGNvbnRlbnQgdW5sZXNzIGluIHN0cmljdCBtb2RlXFxuXFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGluZSAnICsgKGkgKyAxKSArICcgJyArIEpTT04uc3RyaW5naWZ5KF9saW5lKSk7XFxuXFx0ICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIGkrKztcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIC8vIFBhcnNlcyB0aGUgLS0tIGFuZCArKysgaGVhZGVycywgaWYgbm9uZSBhcmUgZm91bmQsIG5vIGxpbmVzXFxuXFx0ICAvLyBhcmUgY29uc3VtZWQuXFxuXFx0ICBmdW5jdGlvbiBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpIHtcXG5cXHQgICAgdmFyIGZpbGVIZWFkZXIgPSAvXigtLS18XFxcXCtcXFxcK1xcXFwrKVxcXFxzKyguKikkLy5leGVjKGRpZmZzdHJbaV0pO1xcblxcdCAgICBpZiAoZmlsZUhlYWRlcikge1xcblxcdCAgICAgIHZhciBrZXlQcmVmaXggPSBmaWxlSGVhZGVyWzFdID09PSAnLS0tJyA/ICdvbGQnIDogJ25ldyc7XFxuXFx0ICAgICAgdmFyIGRhdGEgPSBmaWxlSGVhZGVyWzJdLnNwbGl0KCdcXFxcdCcsIDIpO1xcblxcdCAgICAgIHZhciBmaWxlTmFtZSA9IGRhdGFbMF0ucmVwbGFjZSgvXFxcXFxcXFxcXFxcXFxcXC9nLCAnXFxcXFxcXFwnKTtcXG5cXHQgICAgICBpZiAoL15cXFwiLipcXFwiJC8udGVzdChmaWxlTmFtZSkpIHtcXG5cXHQgICAgICAgIGZpbGVOYW1lID0gZmlsZU5hbWUuc3Vic3RyKDEsIGZpbGVOYW1lLmxlbmd0aCAtIDIpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBpbmRleFtrZXlQcmVmaXggKyAnRmlsZU5hbWUnXSA9IGZpbGVOYW1lO1xcblxcdCAgICAgIGluZGV4W2tleVByZWZpeCArICdIZWFkZXInXSA9IChkYXRhWzFdIHx8ICcnKS50cmltKCk7XFxuXFxuXFx0ICAgICAgaSsrO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBQYXJzZXMgYSBodW5rXFxuXFx0ICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIGEgaHVuay5cXG5cXHQgIGZ1bmN0aW9uIHBhcnNlSHVuaygpIHtcXG5cXHQgICAgdmFyIGNodW5rSGVhZGVySW5kZXggPSBpLFxcblxcdCAgICAgICAgY2h1bmtIZWFkZXJMaW5lID0gZGlmZnN0cltpKytdLFxcblxcdCAgICAgICAgY2h1bmtIZWFkZXIgPSBjaHVua0hlYWRlckxpbmUuc3BsaXQoL0BAIC0oXFxcXGQrKSg/OiwoXFxcXGQrKSk/IFxcXFwrKFxcXFxkKykoPzosKFxcXFxkKykpPyBAQC8pO1xcblxcblxcdCAgICB2YXIgaHVuayA9IHtcXG5cXHQgICAgICBvbGRTdGFydDogK2NodW5rSGVhZGVyWzFdLFxcblxcdCAgICAgIG9sZExpbmVzOiArY2h1bmtIZWFkZXJbMl0gfHwgMSxcXG5cXHQgICAgICBuZXdTdGFydDogK2NodW5rSGVhZGVyWzNdLFxcblxcdCAgICAgIG5ld0xpbmVzOiArY2h1bmtIZWFkZXJbNF0gfHwgMSxcXG5cXHQgICAgICBsaW5lczogW10sXFxuXFx0ICAgICAgbGluZWRlbGltaXRlcnM6IFtdXFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHZhciBhZGRDb3VudCA9IDAsXFxuXFx0ICAgICAgICByZW1vdmVDb3VudCA9IDA7XFxuXFx0ICAgIGZvciAoOyBpIDwgZGlmZnN0ci5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggJy0tLScgY291bGQgYmUgbWlzdGFrZW4gZm9yIHRoZSBcXFwicmVtb3ZlIGxpbmVcXFwiIG9wZXJhdGlvblxcblxcdCAgICAgIC8vIEJ1dCB0aGV5IGNvdWxkIGJlIHRoZSBoZWFkZXIgZm9yIHRoZSBuZXh0IGZpbGUuIFRoZXJlZm9yZSBwcnVuZSBzdWNoIGNhc2VzIG91dC5cXG5cXHQgICAgICBpZiAoZGlmZnN0cltpXS5pbmRleE9mKCctLS0gJykgPT09IDAgJiYgaSArIDIgPCBkaWZmc3RyLmxlbmd0aCAmJiBkaWZmc3RyW2kgKyAxXS5pbmRleE9mKCcrKysgJykgPT09IDAgJiYgZGlmZnN0cltpICsgMl0uaW5kZXhPZignQEAnKSA9PT0gMCkge1xcblxcdCAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIHZhciBvcGVyYXRpb24gPSBkaWZmc3RyW2ldLmxlbmd0aCA9PSAwICYmIGkgIT0gZGlmZnN0ci5sZW5ndGggLSAxID8gJyAnIDogZGlmZnN0cltpXVswXTtcXG5cXG5cXHQgICAgICBpZiAob3BlcmF0aW9uID09PSAnKycgfHwgb3BlcmF0aW9uID09PSAnLScgfHwgb3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnXFxcXFxcXFwnKSB7XFxuXFx0ICAgICAgICBodW5rLmxpbmVzLnB1c2goZGlmZnN0cltpXSk7XFxuXFx0ICAgICAgICBodW5rLmxpbmVkZWxpbWl0ZXJzLnB1c2goZGVsaW1pdGVyc1tpXSB8fCAnXFxcXG4nKTtcXG5cXG5cXHQgICAgICAgIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xcblxcdCAgICAgICAgICBhZGRDb3VudCsrO1xcblxcdCAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICctJykge1xcblxcdCAgICAgICAgICByZW1vdmVDb3VudCsrO1xcblxcdCAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcgJykge1xcblxcdCAgICAgICAgICBhZGRDb3VudCsrO1xcblxcdCAgICAgICAgICByZW1vdmVDb3VudCsrO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICBicmVhaztcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gSGFuZGxlIHRoZSBlbXB0eSBibG9jayBjb3VudCBjYXNlXFxuXFx0ICAgIGlmICghYWRkQ291bnQgJiYgaHVuay5uZXdMaW5lcyA9PT0gMSkge1xcblxcdCAgICAgIGh1bmsubmV3TGluZXMgPSAwO1xcblxcdCAgICB9XFxuXFx0ICAgIGlmICghcmVtb3ZlQ291bnQgJiYgaHVuay5vbGRMaW5lcyA9PT0gMSkge1xcblxcdCAgICAgIGh1bmsub2xkTGluZXMgPSAwO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIFBlcmZvcm0gb3B0aW9uYWwgc2FuaXR5IGNoZWNraW5nXFxuXFx0ICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xcblxcdCAgICAgIGlmIChhZGRDb3VudCAhPT0gaHVuay5uZXdMaW5lcykge1xcblxcdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRlZCBsaW5lIGNvdW50IGRpZCBub3QgbWF0Y2ggZm9yIGh1bmsgYXQgbGluZSAnICsgKGNodW5rSGVhZGVySW5kZXggKyAxKSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIGlmIChyZW1vdmVDb3VudCAhPT0gaHVuay5vbGRMaW5lcykge1xcblxcdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdmVkIGxpbmUgY291bnQgZGlkIG5vdCBtYXRjaCBmb3IgaHVuayBhdCBsaW5lICcgKyAoY2h1bmtIZWFkZXJJbmRleCArIDEpKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgcmV0dXJuIGh1bms7XFxuXFx0ICB9XFxuXFxuXFx0ICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XFxuXFx0ICAgIHBhcnNlSW5kZXgoKTtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiBsaXN0O1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAxMiAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFxuXFx0ZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9mdW5jdGlvbiAoc3RhcnQsIG1pbkxpbmUsIG1heExpbmUpIHtcXG5cXHQgIHZhciB3YW50Rm9yd2FyZCA9IHRydWUsXFxuXFx0ICAgICAgYmFja3dhcmRFeGhhdXN0ZWQgPSBmYWxzZSxcXG5cXHQgICAgICBmb3J3YXJkRXhoYXVzdGVkID0gZmFsc2UsXFxuXFx0ICAgICAgbG9jYWxPZmZzZXQgPSAxO1xcblxcblxcdCAgcmV0dXJuIGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xcblxcdCAgICBpZiAod2FudEZvcndhcmQgJiYgIWZvcndhcmRFeGhhdXN0ZWQpIHtcXG5cXHQgICAgICBpZiAoYmFja3dhcmRFeGhhdXN0ZWQpIHtcXG5cXHQgICAgICAgIGxvY2FsT2Zmc2V0Kys7XFxuXFx0ICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIHdhbnRGb3J3YXJkID0gZmFsc2U7XFxuXFx0ICAgICAgfVxcblxcblxcdCAgICAgIC8vIENoZWNrIGlmIHRyeWluZyB0byBmaXQgYmV5b25kIHRleHQgbGVuZ3RoLCBhbmQgaWYgbm90LCBjaGVjayBpdCBmaXRzXFxuXFx0ICAgICAgLy8gYWZ0ZXIgb2Zmc2V0IGxvY2F0aW9uIChvciBkZXNpcmVkIGxvY2F0aW9uIG9uIGZpcnN0IGl0ZXJhdGlvbilcXG5cXHQgICAgICBpZiAoc3RhcnQgKyBsb2NhbE9mZnNldCA8PSBtYXhMaW5lKSB7XFxuXFx0ICAgICAgICByZXR1cm4gbG9jYWxPZmZzZXQ7XFxuXFx0ICAgICAgfVxcblxcblxcdCAgICAgIGZvcndhcmRFeGhhdXN0ZWQgPSB0cnVlO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGlmICghYmFja3dhcmRFeGhhdXN0ZWQpIHtcXG5cXHQgICAgICBpZiAoIWZvcndhcmRFeGhhdXN0ZWQpIHtcXG5cXHQgICAgICAgIHdhbnRGb3J3YXJkID0gdHJ1ZTtcXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZWZvcmUgdGV4dCBiZWdpbm5pbmcsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcXG5cXHQgICAgICAvLyBiZWZvcmUgb2Zmc2V0IGxvY2F0aW9uXFxuXFx0ICAgICAgaWYgKG1pbkxpbmUgPD0gc3RhcnQgLSBsb2NhbE9mZnNldCkge1xcblxcdCAgICAgICAgcmV0dXJuIC1sb2NhbE9mZnNldCsrO1xcblxcdCAgICAgIH1cXG5cXG5cXHQgICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IHRydWU7XFxuXFx0ICAgICAgcmV0dXJuIGl0ZXJhdG9yKCk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gV2UgdHJpZWQgdG8gZml0IGh1bmsgYmVmb3JlIHRleHQgYmVnaW5uaW5nIGFuZCBiZXlvbmQgdGV4dCBsZW5ndGgsIHRoZW5cXG5cXHQgICAgLy8gaHVuayBjYW4ndCBmaXQgb24gdGhlIHRleHQuIFJldHVybiB1bmRlZmluZWRcXG5cXHQgIH07XFxuXFx0fTtcXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAxMyAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jYWxjTGluZUNvdW50ID0gY2FsY0xpbmVDb3VudDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9tZXJnZSA9IG1lcmdlO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3BhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9mdW5jdGlvbiBjYWxjTGluZUNvdW50KGh1bmspIHtcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2NhbGNPbGROZXdMaW5lQ291bnQgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NhbGNPbGROZXdMaW5lQ291bnQoaHVuay5saW5lcyksXFxuXFx0ICAgICAgb2xkTGluZXMgPSBfY2FsY09sZE5ld0xpbmVDb3VudC5vbGRMaW5lcyxcXG5cXHQgICAgICBuZXdMaW5lcyA9IF9jYWxjT2xkTmV3TGluZUNvdW50Lm5ld0xpbmVzO1xcblxcblxcdCAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQpIHtcXG5cXHQgICAgaHVuay5vbGRMaW5lcyA9IG9sZExpbmVzO1xcblxcdCAgfSBlbHNlIHtcXG5cXHQgICAgZGVsZXRlIGh1bmsub2xkTGluZXM7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCkge1xcblxcdCAgICBodW5rLm5ld0xpbmVzID0gbmV3TGluZXM7XFxuXFx0ICB9IGVsc2Uge1xcblxcdCAgICBkZWxldGUgaHVuay5uZXdMaW5lcztcXG5cXHQgIH1cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gbWVyZ2UobWluZSwgdGhlaXJzLCBiYXNlKSB7XFxuXFx0ICBtaW5lID0gbG9hZFBhdGNoKG1pbmUsIGJhc2UpO1xcblxcdCAgdGhlaXJzID0gbG9hZFBhdGNoKHRoZWlycywgYmFzZSk7XFxuXFxuXFx0ICB2YXIgcmV0ID0ge307XFxuXFxuXFx0ICAvLyBGb3IgaW5kZXggd2UganVzdCBsZXQgaXQgcGFzcyB0aHJvdWdoIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhbnkgbmVjZXNzYXJ5IG1lYW5pbmcuXFxuXFx0ICAvLyBMZWF2aW5nIHNhbml0eSBjaGVja3Mgb24gdGhpcyB0byB0aGUgQVBJIGNvbnN1bWVyIHRoYXQgbWF5IGtub3cgbW9yZSBhYm91dCB0aGVcXG5cXHQgIC8vIG1lYW5pbmcgaW4gdGhlaXIgb3duIGNvbnRleHQuXFxuXFx0ICBpZiAobWluZS5pbmRleCB8fCB0aGVpcnMuaW5kZXgpIHtcXG5cXHQgICAgcmV0LmluZGV4ID0gbWluZS5pbmRleCB8fCB0aGVpcnMuaW5kZXg7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAobWluZS5uZXdGaWxlTmFtZSB8fCB0aGVpcnMubmV3RmlsZU5hbWUpIHtcXG5cXHQgICAgaWYgKCFmaWxlTmFtZUNoYW5nZWQobWluZSkpIHtcXG5cXHQgICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIG91cnMsIHVzZSB0aGVpcnMgKGFuZCBvdXJzIGlmIHRoZWlycyBkb2VzIG5vdCBleGlzdClcXG5cXHQgICAgICByZXQub2xkRmlsZU5hbWUgPSB0aGVpcnMub2xkRmlsZU5hbWUgfHwgbWluZS5vbGRGaWxlTmFtZTtcXG5cXHQgICAgICByZXQubmV3RmlsZU5hbWUgPSB0aGVpcnMubmV3RmlsZU5hbWUgfHwgbWluZS5uZXdGaWxlTmFtZTtcXG5cXHQgICAgICByZXQub2xkSGVhZGVyID0gdGhlaXJzLm9sZEhlYWRlciB8fCBtaW5lLm9sZEhlYWRlcjtcXG5cXHQgICAgICByZXQubmV3SGVhZGVyID0gdGhlaXJzLm5ld0hlYWRlciB8fCBtaW5lLm5ld0hlYWRlcjtcXG5cXHQgICAgfSBlbHNlIGlmICghZmlsZU5hbWVDaGFuZ2VkKHRoZWlycykpIHtcXG5cXHQgICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIHRoZWlycywgdXNlIG91cnNcXG5cXHQgICAgICByZXQub2xkRmlsZU5hbWUgPSBtaW5lLm9sZEZpbGVOYW1lO1xcblxcdCAgICAgIHJldC5uZXdGaWxlTmFtZSA9IG1pbmUubmV3RmlsZU5hbWU7XFxuXFx0ICAgICAgcmV0Lm9sZEhlYWRlciA9IG1pbmUub2xkSGVhZGVyO1xcblxcdCAgICAgIHJldC5uZXdIZWFkZXIgPSBtaW5lLm5ld0hlYWRlcjtcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICAvLyBCb3RoIGNoYW5nZWQuLi4gZmlndXJlIGl0IG91dFxcblxcdCAgICAgIHJldC5vbGRGaWxlTmFtZSA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5vbGRGaWxlTmFtZSwgdGhlaXJzLm9sZEZpbGVOYW1lKTtcXG5cXHQgICAgICByZXQubmV3RmlsZU5hbWUgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUubmV3RmlsZU5hbWUsIHRoZWlycy5uZXdGaWxlTmFtZSk7XFxuXFx0ICAgICAgcmV0Lm9sZEhlYWRlciA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5vbGRIZWFkZXIsIHRoZWlycy5vbGRIZWFkZXIpO1xcblxcdCAgICAgIHJldC5uZXdIZWFkZXIgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUubmV3SGVhZGVyLCB0aGVpcnMubmV3SGVhZGVyKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgcmV0Lmh1bmtzID0gW107XFxuXFxuXFx0ICB2YXIgbWluZUluZGV4ID0gMCxcXG5cXHQgICAgICB0aGVpcnNJbmRleCA9IDAsXFxuXFx0ICAgICAgbWluZU9mZnNldCA9IDAsXFxuXFx0ICAgICAgdGhlaXJzT2Zmc2V0ID0gMDtcXG5cXG5cXHQgIHdoaWxlIChtaW5lSW5kZXggPCBtaW5lLmh1bmtzLmxlbmd0aCB8fCB0aGVpcnNJbmRleCA8IHRoZWlycy5odW5rcy5sZW5ndGgpIHtcXG5cXHQgICAgdmFyIG1pbmVDdXJyZW50ID0gbWluZS5odW5rc1ttaW5lSW5kZXhdIHx8IHsgb2xkU3RhcnQ6IEluZmluaXR5IH0sXFxuXFx0ICAgICAgICB0aGVpcnNDdXJyZW50ID0gdGhlaXJzLmh1bmtzW3RoZWlyc0luZGV4XSB8fCB7IG9sZFN0YXJ0OiBJbmZpbml0eSB9O1xcblxcblxcdCAgICBpZiAoaHVua0JlZm9yZShtaW5lQ3VycmVudCwgdGhlaXJzQ3VycmVudCkpIHtcXG5cXHQgICAgICAvLyBUaGlzIHBhdGNoIGRvZXMgbm90IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIG90aGVycywgeWF5LlxcblxcdCAgICAgIHJldC5odW5rcy5wdXNoKGNsb25lSHVuayhtaW5lQ3VycmVudCwgbWluZU9mZnNldCkpO1xcblxcdCAgICAgIG1pbmVJbmRleCsrO1xcblxcdCAgICAgIHRoZWlyc09mZnNldCArPSBtaW5lQ3VycmVudC5uZXdMaW5lcyAtIG1pbmVDdXJyZW50Lm9sZExpbmVzO1xcblxcdCAgICB9IGVsc2UgaWYgKGh1bmtCZWZvcmUodGhlaXJzQ3VycmVudCwgbWluZUN1cnJlbnQpKSB7XFxuXFx0ICAgICAgLy8gVGhpcyBwYXRjaCBkb2VzIG5vdCBvdmVybGFwIHdpdGggYW55IG9mIHRoZSBvdGhlcnMsIHlheS5cXG5cXHQgICAgICByZXQuaHVua3MucHVzaChjbG9uZUh1bmsodGhlaXJzQ3VycmVudCwgdGhlaXJzT2Zmc2V0KSk7XFxuXFx0ICAgICAgdGhlaXJzSW5kZXgrKztcXG5cXHQgICAgICBtaW5lT2Zmc2V0ICs9IHRoZWlyc0N1cnJlbnQubmV3TGluZXMgLSB0aGVpcnNDdXJyZW50Lm9sZExpbmVzO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIC8vIE92ZXJsYXAsIG1lcmdlIGFzIGJlc3Qgd2UgY2FuXFxuXFx0ICAgICAgdmFyIG1lcmdlZEh1bmsgPSB7XFxuXFx0ICAgICAgICBvbGRTdGFydDogTWF0aC5taW4obWluZUN1cnJlbnQub2xkU3RhcnQsIHRoZWlyc0N1cnJlbnQub2xkU3RhcnQpLFxcblxcdCAgICAgICAgb2xkTGluZXM6IDAsXFxuXFx0ICAgICAgICBuZXdTdGFydDogTWF0aC5taW4obWluZUN1cnJlbnQubmV3U3RhcnQgKyBtaW5lT2Zmc2V0LCB0aGVpcnNDdXJyZW50Lm9sZFN0YXJ0ICsgdGhlaXJzT2Zmc2V0KSxcXG5cXHQgICAgICAgIG5ld0xpbmVzOiAwLFxcblxcdCAgICAgICAgbGluZXM6IFtdXFxuXFx0ICAgICAgfTtcXG5cXHQgICAgICBtZXJnZUxpbmVzKG1lcmdlZEh1bmssIG1pbmVDdXJyZW50Lm9sZFN0YXJ0LCBtaW5lQ3VycmVudC5saW5lcywgdGhlaXJzQ3VycmVudC5vbGRTdGFydCwgdGhlaXJzQ3VycmVudC5saW5lcyk7XFxuXFx0ICAgICAgdGhlaXJzSW5kZXgrKztcXG5cXHQgICAgICBtaW5lSW5kZXgrKztcXG5cXG5cXHQgICAgICByZXQuaHVua3MucHVzaChtZXJnZWRIdW5rKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIHJldDtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gbG9hZFBhdGNoKHBhcmFtLCBiYXNlKSB7XFxuXFx0ICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xcblxcdCAgICBpZiAoL15AQC9tLnRlc3QocGFyYW0pIHx8IC9eSW5kZXg6L20udGVzdChwYXJhbSkpIHtcXG5cXHQgICAgICByZXR1cm4gKC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX3BhcnNlLnBhcnNlUGF0Y2gpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKHBhcmFtKVswXVxcblxcdCAgICAgICk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgaWYgKCFiYXNlKSB7XFxuXFx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBiYXNlIHJlZmVyZW5jZSBvciBwYXNzIGluIGEgcGF0Y2gnKTtcXG5cXHQgICAgfVxcblxcdCAgICByZXR1cm4gKC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX2NyZWF0ZS5zdHJ1Y3R1cmVkUGF0Y2gpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBiYXNlLCBwYXJhbSlcXG5cXHQgICAgKTtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiBwYXJhbTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gZmlsZU5hbWVDaGFuZ2VkKHBhdGNoKSB7XFxuXFx0ICByZXR1cm4gcGF0Y2gubmV3RmlsZU5hbWUgJiYgcGF0Y2gubmV3RmlsZU5hbWUgIT09IHBhdGNoLm9sZEZpbGVOYW1lO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBzZWxlY3RGaWVsZChpbmRleCwgbWluZSwgdGhlaXJzKSB7XFxuXFx0ICBpZiAobWluZSA9PT0gdGhlaXJzKSB7XFxuXFx0ICAgIHJldHVybiBtaW5lO1xcblxcdCAgfSBlbHNlIHtcXG5cXHQgICAgaW5kZXguY29uZmxpY3QgPSB0cnVlO1xcblxcdCAgICByZXR1cm4geyBtaW5lOiBtaW5lLCB0aGVpcnM6IHRoZWlycyB9O1xcblxcdCAgfVxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBodW5rQmVmb3JlKHRlc3QsIGNoZWNrKSB7XFxuXFx0ICByZXR1cm4gdGVzdC5vbGRTdGFydCA8IGNoZWNrLm9sZFN0YXJ0ICYmIHRlc3Qub2xkU3RhcnQgKyB0ZXN0Lm9sZExpbmVzIDwgY2hlY2sub2xkU3RhcnQ7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGNsb25lSHVuayhodW5rLCBvZmZzZXQpIHtcXG5cXHQgIHJldHVybiB7XFxuXFx0ICAgIG9sZFN0YXJ0OiBodW5rLm9sZFN0YXJ0LCBvbGRMaW5lczogaHVuay5vbGRMaW5lcyxcXG5cXHQgICAgbmV3U3RhcnQ6IGh1bmsubmV3U3RhcnQgKyBvZmZzZXQsIG5ld0xpbmVzOiBodW5rLm5ld0xpbmVzLFxcblxcdCAgICBsaW5lczogaHVuay5saW5lc1xcblxcdCAgfTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gbWVyZ2VMaW5lcyhodW5rLCBtaW5lT2Zmc2V0LCBtaW5lTGluZXMsIHRoZWlyT2Zmc2V0LCB0aGVpckxpbmVzKSB7XFxuXFx0ICAvLyBUaGlzIHdpbGwgZ2VuZXJhbGx5IHJlc3VsdCBpbiBhIGNvbmZsaWN0ZWQgaHVuaywgYnV0IHRoZXJlIGFyZSBjYXNlcyB3aGVyZSB0aGUgY29udGV4dFxcblxcdCAgLy8gaXMgdGhlIG9ubHkgb3ZlcmxhcCB3aGVyZSB3ZSBjYW4gc3VjY2Vzc2Z1bGx5IG1lcmdlIHRoZSBjb250ZW50IGhlcmUuXFxuXFx0ICB2YXIgbWluZSA9IHsgb2Zmc2V0OiBtaW5lT2Zmc2V0LCBsaW5lczogbWluZUxpbmVzLCBpbmRleDogMCB9LFxcblxcdCAgICAgIHRoZWlyID0geyBvZmZzZXQ6IHRoZWlyT2Zmc2V0LCBsaW5lczogdGhlaXJMaW5lcywgaW5kZXg6IDAgfTtcXG5cXG5cXHQgIC8vIEhhbmRsZSBhbnkgbGVhZGluZyBjb250ZW50XFxuXFx0ICBpbnNlcnRMZWFkaW5nKGh1bmssIG1pbmUsIHRoZWlyKTtcXG5cXHQgIGluc2VydExlYWRpbmcoaHVuaywgdGhlaXIsIG1pbmUpO1xcblxcblxcdCAgLy8gTm93IGluIHRoZSBvdmVybGFwIGNvbnRlbnQuIFNjYW4gdGhyb3VnaCBhbmQgc2VsZWN0IHRoZSBiZXN0IGNoYW5nZXMgZnJvbSBlYWNoLlxcblxcdCAgd2hpbGUgKG1pbmUuaW5kZXggPCBtaW5lLmxpbmVzLmxlbmd0aCAmJiB0aGVpci5pbmRleCA8IHRoZWlyLmxpbmVzLmxlbmd0aCkge1xcblxcdCAgICB2YXIgbWluZUN1cnJlbnQgPSBtaW5lLmxpbmVzW21pbmUuaW5kZXhdLFxcblxcdCAgICAgICAgdGhlaXJDdXJyZW50ID0gdGhlaXIubGluZXNbdGhlaXIuaW5kZXhdO1xcblxcblxcdCAgICBpZiAoKG1pbmVDdXJyZW50WzBdID09PSAnLScgfHwgbWluZUN1cnJlbnRbMF0gPT09ICcrJykgJiYgKHRoZWlyQ3VycmVudFswXSA9PT0gJy0nIHx8IHRoZWlyQ3VycmVudFswXSA9PT0gJysnKSkge1xcblxcdCAgICAgIC8vIEJvdGggbW9kaWZpZWQgLi4uXFxuXFx0ICAgICAgbXV0dWFsQ2hhbmdlKGh1bmssIG1pbmUsIHRoZWlyKTtcXG5cXHQgICAgfSBlbHNlIGlmIChtaW5lQ3VycmVudFswXSA9PT0gJysnICYmIHRoZWlyQ3VycmVudFswXSA9PT0gJyAnKSB7XFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfaHVuayRsaW5lcztcXG5cXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyAvLyBNaW5lIGluc2VydGVkXFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyhfaHVuayRsaW5lcyA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovaHVuay5saW5lcykucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2h1bmskbGluZXMgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8sIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fdG9Db25zdW1hYmxlQXJyYXkoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY29sbGVjdENoYW5nZShtaW5lKSkpO1xcblxcdCAgICB9IGVsc2UgaWYgKHRoZWlyQ3VycmVudFswXSA9PT0gJysnICYmIG1pbmVDdXJyZW50WzBdID09PSAnICcpIHtcXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9odW5rJGxpbmVzMjtcXG5cXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyAvLyBUaGVpcnMgaW5zZXJ0ZWRcXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKF9odW5rJGxpbmVzMiA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovaHVuay5saW5lcykucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2h1bmskbGluZXMyIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3RvQ29uc3VtYWJsZUFycmF5KCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbGxlY3RDaGFuZ2UodGhlaXIpKSk7XFxuXFx0ICAgIH0gZWxzZSBpZiAobWluZUN1cnJlbnRbMF0gPT09ICctJyAmJiB0aGVpckN1cnJlbnRbMF0gPT09ICcgJykge1xcblxcdCAgICAgIC8vIE1pbmUgcmVtb3ZlZCBvciBlZGl0ZWRcXG5cXHQgICAgICByZW1vdmFsKGh1bmssIG1pbmUsIHRoZWlyKTtcXG5cXHQgICAgfSBlbHNlIGlmICh0aGVpckN1cnJlbnRbMF0gPT09ICctJyAmJiBtaW5lQ3VycmVudFswXSA9PT0gJyAnKSB7XFxuXFx0ICAgICAgLy8gVGhlaXIgcmVtb3ZlZCBvciBlZGl0ZWRcXG5cXHQgICAgICByZW1vdmFsKGh1bmssIHRoZWlyLCBtaW5lLCB0cnVlKTtcXG5cXHQgICAgfSBlbHNlIGlmIChtaW5lQ3VycmVudCA9PT0gdGhlaXJDdXJyZW50KSB7XFxuXFx0ICAgICAgLy8gQ29udGV4dCBpZGVudGl0eVxcblxcdCAgICAgIGh1bmsubGluZXMucHVzaChtaW5lQ3VycmVudCk7XFxuXFx0ICAgICAgbWluZS5pbmRleCsrO1xcblxcdCAgICAgIHRoZWlyLmluZGV4Kys7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgLy8gQ29udGV4dCBtaXNtYXRjaFxcblxcdCAgICAgIGNvbmZsaWN0KGh1bmssIGNvbGxlY3RDaGFuZ2UobWluZSksIGNvbGxlY3RDaGFuZ2UodGhlaXIpKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgLy8gTm93IHB1c2ggYW55dGhpbmcgdGhhdCBtYXkgYmUgcmVtYWluaW5nXFxuXFx0ICBpbnNlcnRUcmFpbGluZyhodW5rLCBtaW5lKTtcXG5cXHQgIGluc2VydFRyYWlsaW5nKGh1bmssIHRoZWlyKTtcXG5cXG5cXHQgIGNhbGNMaW5lQ291bnQoaHVuayk7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIG11dHVhbENoYW5nZShodW5rLCBtaW5lLCB0aGVpcikge1xcblxcdCAgdmFyIG15Q2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UobWluZSksXFxuXFx0ICAgICAgdGhlaXJDaGFuZ2VzID0gY29sbGVjdENoYW5nZSh0aGVpcik7XFxuXFxuXFx0ICBpZiAoYWxsUmVtb3ZlcyhteUNoYW5nZXMpICYmIGFsbFJlbW92ZXModGhlaXJDaGFuZ2VzKSkge1xcblxcdCAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHJlbW92ZSBjaGFuZ2VzIHRoYXQgYXJlIHN1cGVyc2V0cyBvZiBvbmUgYW5vdGhlclxcblxcdCAgICBpZiAoIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX2FycmF5LmFycmF5U3RhcnRzV2l0aCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8obXlDaGFuZ2VzLCB0aGVpckNoYW5nZXMpICYmIHNraXBSZW1vdmVTdXBlcnNldCh0aGVpciwgbXlDaGFuZ2VzLCBteUNoYW5nZXMubGVuZ3RoIC0gdGhlaXJDaGFuZ2VzLmxlbmd0aCkpIHtcXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9odW5rJGxpbmVzMztcXG5cXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKF9odW5rJGxpbmVzMyA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovaHVuay5saW5lcykucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2h1bmskbGluZXMzIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3RvQ29uc3VtYWJsZUFycmF5KCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL215Q2hhbmdlcykpO1xcblxcdCAgICAgIHJldHVybjtcXG5cXHQgICAgfSBlbHNlIGlmICggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfYXJyYXkuYXJyYXlTdGFydHNXaXRoKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyh0aGVpckNoYW5nZXMsIG15Q2hhbmdlcykgJiYgc2tpcFJlbW92ZVN1cGVyc2V0KG1pbmUsIHRoZWlyQ2hhbmdlcywgdGhlaXJDaGFuZ2VzLmxlbmd0aCAtIG15Q2hhbmdlcy5sZW5ndGgpKSB7XFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfaHVuayRsaW5lczQ7XFxuXFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyhfaHVuayRsaW5lczQgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2h1bmsubGluZXMpLnB1c2guIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9hcHBseSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19odW5rJGxpbmVzNCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLywgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL190b0NvbnN1bWFibGVBcnJheSggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi90aGVpckNoYW5nZXMpKTtcXG5cXHQgICAgICByZXR1cm47XFxuXFx0ICAgIH1cXG5cXHQgIH0gZWxzZSBpZiAoIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX2FycmF5LmFycmF5RXF1YWwpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKSkge1xcblxcdCAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9odW5rJGxpbmVzNTtcXG5cXG5cXHQgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyhfaHVuayRsaW5lczUgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2h1bmsubGluZXMpLnB1c2guIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9hcHBseSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19odW5rJGxpbmVzNSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLywgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL190b0NvbnN1bWFibGVBcnJheSggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9teUNoYW5nZXMpKTtcXG5cXHQgICAgcmV0dXJuO1xcblxcdCAgfVxcblxcblxcdCAgY29uZmxpY3QoaHVuaywgbXlDaGFuZ2VzLCB0aGVpckNoYW5nZXMpO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiByZW1vdmFsKGh1bmssIG1pbmUsIHRoZWlyLCBzd2FwKSB7XFxuXFx0ICB2YXIgbXlDaGFuZ2VzID0gY29sbGVjdENoYW5nZShtaW5lKSxcXG5cXHQgICAgICB0aGVpckNoYW5nZXMgPSBjb2xsZWN0Q29udGV4dCh0aGVpciwgbXlDaGFuZ2VzKTtcXG5cXHQgIGlmICh0aGVpckNoYW5nZXMubWVyZ2VkKSB7XFxuXFx0ICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2h1bmskbGluZXM2O1xcblxcblxcdCAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKF9odW5rJGxpbmVzNiA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovaHVuay5saW5lcykucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2h1bmskbGluZXM2IC8qaXN0YW5idWwgaWdub3JlIGVuZCovLCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3RvQ29uc3VtYWJsZUFycmF5KCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3RoZWlyQ2hhbmdlcy5tZXJnZWQpKTtcXG5cXHQgIH0gZWxzZSB7XFxuXFx0ICAgIGNvbmZsaWN0KGh1bmssIHN3YXAgPyB0aGVpckNoYW5nZXMgOiBteUNoYW5nZXMsIHN3YXAgPyBteUNoYW5nZXMgOiB0aGVpckNoYW5nZXMpO1xcblxcdCAgfVxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBjb25mbGljdChodW5rLCBtaW5lLCB0aGVpcikge1xcblxcdCAgaHVuay5jb25mbGljdCA9IHRydWU7XFxuXFx0ICBodW5rLmxpbmVzLnB1c2goe1xcblxcdCAgICBjb25mbGljdDogdHJ1ZSxcXG5cXHQgICAgbWluZTogbWluZSxcXG5cXHQgICAgdGhlaXJzOiB0aGVpclxcblxcdCAgfSk7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGluc2VydExlYWRpbmcoaHVuaywgaW5zZXJ0LCB0aGVpcikge1xcblxcdCAgd2hpbGUgKGluc2VydC5vZmZzZXQgPCB0aGVpci5vZmZzZXQgJiYgaW5zZXJ0LmluZGV4IDwgaW5zZXJ0LmxpbmVzLmxlbmd0aCkge1xcblxcdCAgICB2YXIgbGluZSA9IGluc2VydC5saW5lc1tpbnNlcnQuaW5kZXgrK107XFxuXFx0ICAgIGh1bmsubGluZXMucHVzaChsaW5lKTtcXG5cXHQgICAgaW5zZXJ0Lm9mZnNldCsrO1xcblxcdCAgfVxcblxcdH1cXG5cXHRmdW5jdGlvbiBpbnNlcnRUcmFpbGluZyhodW5rLCBpbnNlcnQpIHtcXG5cXHQgIHdoaWxlIChpbnNlcnQuaW5kZXggPCBpbnNlcnQubGluZXMubGVuZ3RoKSB7XFxuXFx0ICAgIHZhciBsaW5lID0gaW5zZXJ0LmxpbmVzW2luc2VydC5pbmRleCsrXTtcXG5cXHQgICAgaHVuay5saW5lcy5wdXNoKGxpbmUpO1xcblxcdCAgfVxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBjb2xsZWN0Q2hhbmdlKHN0YXRlKSB7XFxuXFx0ICB2YXIgcmV0ID0gW10sXFxuXFx0ICAgICAgb3BlcmF0aW9uID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdWzBdO1xcblxcdCAgd2hpbGUgKHN0YXRlLmluZGV4IDwgc3RhdGUubGluZXMubGVuZ3RoKSB7XFxuXFx0ICAgIHZhciBsaW5lID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdO1xcblxcblxcdCAgICAvLyBHcm91cCBhZGRpdGlvbnMgdGhhdCBhcmUgaW1tZWRpYXRlbHkgYWZ0ZXIgc3VidHJhY3Rpb25zIGFuZCB0cmVhdCB0aGVtIGFzIG9uZSBcXFwiYXRvbWljXFxcIiBtb2RpZnkgY2hhbmdlLlxcblxcdCAgICBpZiAob3BlcmF0aW9uID09PSAnLScgJiYgbGluZVswXSA9PT0gJysnKSB7XFxuXFx0ICAgICAgb3BlcmF0aW9uID0gJysnO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGlmIChvcGVyYXRpb24gPT09IGxpbmVbMF0pIHtcXG5cXHQgICAgICByZXQucHVzaChsaW5lKTtcXG5cXHQgICAgICBzdGF0ZS5pbmRleCsrO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIGJyZWFrO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gcmV0O1xcblxcdH1cXG5cXHRmdW5jdGlvbiBjb2xsZWN0Q29udGV4dChzdGF0ZSwgbWF0Y2hDaGFuZ2VzKSB7XFxuXFx0ICB2YXIgY2hhbmdlcyA9IFtdLFxcblxcdCAgICAgIG1lcmdlZCA9IFtdLFxcblxcdCAgICAgIG1hdGNoSW5kZXggPSAwLFxcblxcdCAgICAgIGNvbnRleHRDaGFuZ2VzID0gZmFsc2UsXFxuXFx0ICAgICAgY29uZmxpY3RlZCA9IGZhbHNlO1xcblxcdCAgd2hpbGUgKG1hdGNoSW5kZXggPCBtYXRjaENoYW5nZXMubGVuZ3RoICYmIHN0YXRlLmluZGV4IDwgc3RhdGUubGluZXMubGVuZ3RoKSB7XFxuXFx0ICAgIHZhciBjaGFuZ2UgPSBzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleF0sXFxuXFx0ICAgICAgICBtYXRjaCA9IG1hdGNoQ2hhbmdlc1ttYXRjaEluZGV4XTtcXG5cXG5cXHQgICAgLy8gT25jZSB3ZSd2ZSBoaXQgb3VyIGFkZCwgdGhlbiB3ZSBhcmUgZG9uZVxcblxcdCAgICBpZiAobWF0Y2hbMF0gPT09ICcrJykge1xcblxcdCAgICAgIGJyZWFrO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGNvbnRleHRDaGFuZ2VzID0gY29udGV4dENoYW5nZXMgfHwgY2hhbmdlWzBdICE9PSAnICc7XFxuXFxuXFx0ICAgIG1lcmdlZC5wdXNoKG1hdGNoKTtcXG5cXHQgICAgbWF0Y2hJbmRleCsrO1xcblxcblxcdCAgICAvLyBDb25zdW1lIGFueSBhZGRpdGlvbnMgaW4gdGhlIG90aGVyIGJsb2NrIGFzIGEgY29uZmxpY3QgdG8gYXR0ZW1wdFxcblxcdCAgICAvLyB0byBwdWxsIGluIHRoZSByZW1haW5pbmcgY29udGV4dCBhZnRlciB0aGlzXFxuXFx0ICAgIGlmIChjaGFuZ2VbMF0gPT09ICcrJykge1xcblxcdCAgICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xcblxcblxcdCAgICAgIHdoaWxlIChjaGFuZ2VbMF0gPT09ICcrJykge1xcblxcdCAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XFxuXFx0ICAgICAgICBjaGFuZ2UgPSBzdGF0ZS5saW5lc1srK3N0YXRlLmluZGV4XTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgaWYgKG1hdGNoLnN1YnN0cigxKSA9PT0gY2hhbmdlLnN1YnN0cigxKSkge1xcblxcdCAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xcblxcdCAgICAgIHN0YXRlLmluZGV4Kys7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgY29uZmxpY3RlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIGlmICgobWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXhdIHx8ICcnKVswXSA9PT0gJysnICYmIGNvbnRleHRDaGFuZ2VzKSB7XFxuXFx0ICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xcblxcdCAgfVxcblxcblxcdCAgaWYgKGNvbmZsaWN0ZWQpIHtcXG5cXHQgICAgcmV0dXJuIGNoYW5nZXM7XFxuXFx0ICB9XFxuXFxuXFx0ICB3aGlsZSAobWF0Y2hJbmRleCA8IG1hdGNoQ2hhbmdlcy5sZW5ndGgpIHtcXG5cXHQgICAgbWVyZ2VkLnB1c2gobWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXgrK10pO1xcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIHtcXG5cXHQgICAgbWVyZ2VkOiBtZXJnZWQsXFxuXFx0ICAgIGNoYW5nZXM6IGNoYW5nZXNcXG5cXHQgIH07XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGFsbFJlbW92ZXMoY2hhbmdlcykge1xcblxcdCAgcmV0dXJuIGNoYW5nZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjaGFuZ2UpIHtcXG5cXHQgICAgcmV0dXJuIHByZXYgJiYgY2hhbmdlWzBdID09PSAnLSc7XFxuXFx0ICB9LCB0cnVlKTtcXG5cXHR9XFxuXFx0ZnVuY3Rpb24gc2tpcFJlbW92ZVN1cGVyc2V0KHN0YXRlLCByZW1vdmVDaGFuZ2VzLCBkZWx0YSkge1xcblxcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YTsgaSsrKSB7XFxuXFx0ICAgIHZhciBjaGFuZ2VDb250ZW50ID0gcmVtb3ZlQ2hhbmdlc1tyZW1vdmVDaGFuZ2VzLmxlbmd0aCAtIGRlbHRhICsgaV0uc3Vic3RyKDEpO1xcblxcdCAgICBpZiAoc3RhdGUubGluZXNbc3RhdGUuaW5kZXggKyBpXSAhPT0gJyAnICsgY2hhbmdlQ29udGVudCkge1xcblxcdCAgICAgIHJldHVybiBmYWxzZTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgc3RhdGUuaW5kZXggKz0gZGVsdGE7XFxuXFx0ICByZXR1cm4gdHJ1ZTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lcykge1xcblxcdCAgdmFyIG9sZExpbmVzID0gMDtcXG5cXHQgIHZhciBuZXdMaW5lcyA9IDA7XFxuXFxuXFx0ICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XFxuXFx0ICAgIGlmICh0eXBlb2YgbGluZSAhPT0gJ3N0cmluZycpIHtcXG5cXHQgICAgICB2YXIgbXlDb3VudCA9IGNhbGNPbGROZXdMaW5lQ291bnQobGluZS5taW5lKTtcXG5cXHQgICAgICB2YXIgdGhlaXJDb3VudCA9IGNhbGNPbGROZXdMaW5lQ291bnQobGluZS50aGVpcnMpO1xcblxcblxcdCAgICAgIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgICAgICBpZiAobXlDb3VudC5vbGRMaW5lcyA9PT0gdGhlaXJDb3VudC5vbGRMaW5lcykge1xcblxcdCAgICAgICAgICBvbGRMaW5lcyArPSBteUNvdW50Lm9sZExpbmVzO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgb2xkTGluZXMgPSB1bmRlZmluZWQ7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfVxcblxcblxcdCAgICAgIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgICAgICBpZiAobXlDb3VudC5uZXdMaW5lcyA9PT0gdGhlaXJDb3VudC5uZXdMaW5lcykge1xcblxcdCAgICAgICAgICBuZXdMaW5lcyArPSBteUNvdW50Lm5ld0xpbmVzO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgbmV3TGluZXMgPSB1bmRlZmluZWQ7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfVxcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkICYmIChsaW5lWzBdID09PSAnKycgfHwgbGluZVswXSA9PT0gJyAnKSkge1xcblxcdCAgICAgICAgbmV3TGluZXMrKztcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQgJiYgKGxpbmVbMF0gPT09ICctJyB8fCBsaW5lWzBdID09PSAnICcpKSB7XFxuXFx0ICAgICAgICBvbGRMaW5lcysrO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfSk7XFxuXFxuXFx0ICByZXR1cm4geyBvbGRMaW5lczogb2xkTGluZXMsIG5ld0xpbmVzOiBuZXdMaW5lcyB9O1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAxNCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9zdHJ1Y3R1cmVkUGF0Y2ggPSBzdHJ1Y3R1cmVkUGF0Y2g7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3JlYXRlVHdvRmlsZXNQYXRjaCA9IGNyZWF0ZVR3b0ZpbGVzUGF0Y2g7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3JlYXRlUGF0Y2ggPSBjcmVhdGVQYXRjaDtcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19saW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9mdW5jdGlvbiBzdHJ1Y3R1cmVkUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcXG5cXHQgIGlmICghb3B0aW9ucykge1xcblxcdCAgICBvcHRpb25zID0ge307XFxuXFx0ICB9XFxuXFx0ICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG5cXHQgICAgb3B0aW9ucy5jb250ZXh0ID0gNDtcXG5cXHQgIH1cXG5cXG5cXHQgIHZhciBkaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfbGluZS5kaWZmTGluZXMpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcXG5cXHQgIGRpZmYucHVzaCh7IHZhbHVlOiAnJywgbGluZXM6IFtdIH0pOyAvLyBBcHBlbmQgYW4gZW1wdHkgdmFsdWUgdG8gbWFrZSBjbGVhbnVwIGVhc2llclxcblxcblxcdCAgZnVuY3Rpb24gY29udGV4dExpbmVzKGxpbmVzKSB7XFxuXFx0ICAgIHJldHVybiBsaW5lcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XFxuXFx0ICAgICAgcmV0dXJuICcgJyArIGVudHJ5O1xcblxcdCAgICB9KTtcXG5cXHQgIH1cXG5cXG5cXHQgIHZhciBodW5rcyA9IFtdO1xcblxcdCAgdmFyIG9sZFJhbmdlU3RhcnQgPSAwLFxcblxcdCAgICAgIG5ld1JhbmdlU3RhcnQgPSAwLFxcblxcdCAgICAgIGN1clJhbmdlID0gW10sXFxuXFx0ICAgICAgb2xkTGluZSA9IDEsXFxuXFx0ICAgICAgbmV3TGluZSA9IDE7XFxuXFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovaSkge1xcblxcdCAgICB2YXIgY3VycmVudCA9IGRpZmZbaV0sXFxuXFx0ICAgICAgICBsaW5lcyA9IGN1cnJlbnQubGluZXMgfHwgY3VycmVudC52YWx1ZS5yZXBsYWNlKC9cXFxcbiQvLCAnJykuc3BsaXQoJ1xcXFxuJyk7XFxuXFx0ICAgIGN1cnJlbnQubGluZXMgPSBsaW5lcztcXG5cXG5cXHQgICAgaWYgKGN1cnJlbnQuYWRkZWQgfHwgY3VycmVudC5yZW1vdmVkKSB7XFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfY3VyUmFuZ2U7XFxuXFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8gLy8gSWYgd2UgaGF2ZSBwcmV2aW91cyBjb250ZXh0LCBzdGFydCB3aXRoIHRoYXRcXG5cXHQgICAgICBpZiAoIW9sZFJhbmdlU3RhcnQpIHtcXG5cXHQgICAgICAgIHZhciBwcmV2ID0gZGlmZltpIC0gMV07XFxuXFx0ICAgICAgICBvbGRSYW5nZVN0YXJ0ID0gb2xkTGluZTtcXG5cXHQgICAgICAgIG5ld1JhbmdlU3RhcnQgPSBuZXdMaW5lO1xcblxcblxcdCAgICAgICAgaWYgKHByZXYpIHtcXG5cXHQgICAgICAgICAgY3VyUmFuZ2UgPSBvcHRpb25zLmNvbnRleHQgPiAwID8gY29udGV4dExpbmVzKHByZXYubGluZXMuc2xpY2UoLW9wdGlvbnMuY29udGV4dCkpIDogW107XFxuXFx0ICAgICAgICAgIG9sZFJhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xcblxcdCAgICAgICAgICBuZXdSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgLy8gT3V0cHV0IG91ciBjaGFuZ2VzXFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyhfY3VyUmFuZ2UgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2N1clJhbmdlKS5wdXNoLiAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovYXBwbHkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fY3VyUmFuZ2UgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8sIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fdG9Db25zdW1hYmxlQXJyYXkoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovbGluZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xcblxcdCAgICAgICAgcmV0dXJuIChjdXJyZW50LmFkZGVkID8gJysnIDogJy0nKSArIGVudHJ5O1xcblxcdCAgICAgIH0pKSk7XFxuXFxuXFx0ICAgICAgLy8gVHJhY2sgdGhlIHVwZGF0ZWQgZmlsZSBwb3NpdGlvblxcblxcdCAgICAgIGlmIChjdXJyZW50LmFkZGVkKSB7XFxuXFx0ICAgICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIC8vIElkZW50aWNhbCBjb250ZXh0IGxpbmVzLiBUcmFjayBsaW5lIGNoYW5nZXNcXG5cXHQgICAgICBpZiAob2xkUmFuZ2VTdGFydCkge1xcblxcdCAgICAgICAgLy8gQ2xvc2Ugb3V0IGFueSBjaGFuZ2VzIHRoYXQgaGF2ZSBiZWVuIG91dHB1dCAob3Igam9pbiBvdmVybGFwcGluZylcXG5cXHQgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gb3B0aW9ucy5jb250ZXh0ICogMiAmJiBpIDwgZGlmZi5sZW5ndGggLSAyKSB7XFxuXFx0ICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2N1clJhbmdlMjtcXG5cXG5cXHQgICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8gLy8gT3ZlcmxhcHBpbmdcXG5cXHQgICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyhfY3VyUmFuZ2UyID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jdXJSYW5nZSkucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2N1clJhbmdlMiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLywgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL190b0NvbnN1bWFibGVBcnJheSggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jb250ZXh0TGluZXMobGluZXMpKSk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9jdXJSYW5nZTM7XFxuXFxuXFx0ICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovIC8vIGVuZCB0aGUgcmFuZ2UgYW5kIG91dHB1dFxcblxcdCAgICAgICAgICB2YXIgY29udGV4dFNpemUgPSBNYXRoLm1pbihsaW5lcy5sZW5ndGgsIG9wdGlvbnMuY29udGV4dCk7XFxuXFx0ICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oX2N1clJhbmdlMyA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3VyUmFuZ2UpLnB1c2guIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9hcHBseSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19jdXJSYW5nZTMgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8sIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fdG9Db25zdW1hYmxlQXJyYXkoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY29udGV4dExpbmVzKGxpbmVzLnNsaWNlKDAsIGNvbnRleHRTaXplKSkpKTtcXG5cXG5cXHQgICAgICAgICAgdmFyIGh1bmsgPSB7XFxuXFx0ICAgICAgICAgICAgb2xkU3RhcnQ6IG9sZFJhbmdlU3RhcnQsXFxuXFx0ICAgICAgICAgICAgb2xkTGluZXM6IG9sZExpbmUgLSBvbGRSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUsXFxuXFx0ICAgICAgICAgICAgbmV3U3RhcnQ6IG5ld1JhbmdlU3RhcnQsXFxuXFx0ICAgICAgICAgICAgbmV3TGluZXM6IG5ld0xpbmUgLSBuZXdSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUsXFxuXFx0ICAgICAgICAgICAgbGluZXM6IGN1clJhbmdlXFxuXFx0ICAgICAgICAgIH07XFxuXFx0ICAgICAgICAgIGlmIChpID49IGRpZmYubGVuZ3RoIC0gMiAmJiBsaW5lcy5sZW5ndGggPD0gb3B0aW9ucy5jb250ZXh0KSB7XFxuXFx0ICAgICAgICAgICAgLy8gRU9GIGlzIGluc2lkZSB0aGlzIGh1bmtcXG5cXHQgICAgICAgICAgICB2YXIgb2xkRU9GTmV3bGluZSA9IC9cXFxcbiQvLnRlc3Qob2xkU3RyKTtcXG5cXHQgICAgICAgICAgICB2YXIgbmV3RU9GTmV3bGluZSA9IC9cXFxcbiQvLnRlc3QobmV3U3RyKTtcXG5cXHQgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID09IDAgJiYgIW9sZEVPRk5ld2xpbmUpIHtcXG5cXHQgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogb2xkIGhhcyBubyBlb2wgYW5kIG5vIHRyYWlsaW5nIGNvbnRleHQ7IG5vLW5sIGNhbiBlbmQgdXAgYmVmb3JlIGFkZHNcXG5cXHQgICAgICAgICAgICAgIGN1clJhbmdlLnNwbGljZShodW5rLm9sZExpbmVzLCAwLCAnXFxcXFxcXFwgTm8gbmV3bGluZSBhdCBlbmQgb2YgZmlsZScpO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9sZEVPRk5ld2xpbmUgfHwgIW5ld0VPRk5ld2xpbmUpIHtcXG5cXHQgICAgICAgICAgICAgIGN1clJhbmdlLnB1c2goJ1xcXFxcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgaHVua3MucHVzaChodW5rKTtcXG5cXG5cXHQgICAgICAgICAgb2xkUmFuZ2VTdGFydCA9IDA7XFxuXFx0ICAgICAgICAgIG5ld1JhbmdlU3RhcnQgPSAwO1xcblxcdCAgICAgICAgICBjdXJSYW5nZSA9IFtdO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH1cXG5cXHQgICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcXG5cXHQgICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcXG5cXHQgICAgfVxcblxcdCAgfTtcXG5cXG5cXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xcblxcdCAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2xvb3AoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovaSk7XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4ge1xcblxcdCAgICBvbGRGaWxlTmFtZTogb2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lOiBuZXdGaWxlTmFtZSxcXG5cXHQgICAgb2xkSGVhZGVyOiBvbGRIZWFkZXIsIG5ld0hlYWRlcjogbmV3SGVhZGVyLFxcblxcdCAgICBodW5rczogaHVua3NcXG5cXHQgIH07XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGNyZWF0ZVR3b0ZpbGVzUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcXG5cXHQgIHZhciBkaWZmID0gc3RydWN0dXJlZFBhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKTtcXG5cXG5cXHQgIHZhciByZXQgPSBbXTtcXG5cXHQgIGlmIChvbGRGaWxlTmFtZSA9PSBuZXdGaWxlTmFtZSkge1xcblxcdCAgICByZXQucHVzaCgnSW5kZXg6ICcgKyBvbGRGaWxlTmFtZSk7XFxuXFx0ICB9XFxuXFx0ICByZXQucHVzaCgnPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PScpO1xcblxcdCAgcmV0LnB1c2goJy0tLSAnICsgZGlmZi5vbGRGaWxlTmFtZSArICh0eXBlb2YgZGlmZi5vbGRIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFxcXHQnICsgZGlmZi5vbGRIZWFkZXIpKTtcXG5cXHQgIHJldC5wdXNoKCcrKysgJyArIGRpZmYubmV3RmlsZU5hbWUgKyAodHlwZW9mIGRpZmYubmV3SGVhZGVyID09PSAndW5kZWZpbmVkJyA/ICcnIDogJ1xcXFx0JyArIGRpZmYubmV3SGVhZGVyKSk7XFxuXFxuXFx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYuaHVua3MubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgdmFyIGh1bmsgPSBkaWZmLmh1bmtzW2ldO1xcblxcdCAgICByZXQucHVzaCgnQEAgLScgKyBodW5rLm9sZFN0YXJ0ICsgJywnICsgaHVuay5vbGRMaW5lcyArICcgKycgKyBodW5rLm5ld1N0YXJ0ICsgJywnICsgaHVuay5uZXdMaW5lcyArICcgQEAnKTtcXG5cXHQgICAgcmV0LnB1c2guYXBwbHkocmV0LCBodW5rLmxpbmVzKTtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiByZXQuam9pbignXFxcXG4nKSArICdcXFxcbic7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGNyZWF0ZVBhdGNoKGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcXG5cXHQgIHJldHVybiBjcmVhdGVUd29GaWxlc1BhdGNoKGZpbGVOYW1lLCBmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKTtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMTUgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovYXJyYXlFcXVhbCA9IGFycmF5RXF1YWw7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovYXJyYXlTdGFydHNXaXRoID0gYXJyYXlTdGFydHNXaXRoO1xcblxcdGZ1bmN0aW9uIGFycmF5RXF1YWwoYSwgYikge1xcblxcdCAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xcblxcdCAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gYXJyYXlTdGFydHNXaXRoKGEsIGIpO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBhcnJheVN0YXJ0c1dpdGgoYXJyYXksIHN0YXJ0KSB7XFxuXFx0ICBpZiAoc3RhcnQubGVuZ3RoID4gYXJyYXkubGVuZ3RoKSB7XFxuXFx0ICAgIHJldHVybiBmYWxzZTtcXG5cXHQgIH1cXG5cXG5cXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhcnQubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgaWYgKHN0YXJ0W2ldICE9PSBhcnJheVtpXSkge1xcblxcdCAgICAgIHJldHVybiBmYWxzZTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIHRydWU7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDE2ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbnZlcnRDaGFuZ2VzVG9ETVAgPSBjb252ZXJ0Q2hhbmdlc1RvRE1QO1xcblxcdC8vIFNlZTogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL3dpa2kvQVBJXFxuXFx0ZnVuY3Rpb24gY29udmVydENoYW5nZXNUb0RNUChjaGFuZ2VzKSB7XFxuXFx0ICB2YXIgcmV0ID0gW10sXFxuXFx0ICAgICAgY2hhbmdlID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyxcXG5cXHQgICAgICBvcGVyYXRpb24gPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgIGNoYW5nZSA9IGNoYW5nZXNbaV07XFxuXFx0ICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcXG5cXHQgICAgICBvcGVyYXRpb24gPSAxO1xcblxcdCAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XFxuXFx0ICAgICAgb3BlcmF0aW9uID0gLTE7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgb3BlcmF0aW9uID0gMDtcXG5cXHQgICAgfVxcblxcblxcdCAgICByZXQucHVzaChbb3BlcmF0aW9uLCBjaGFuZ2UudmFsdWVdKTtcXG5cXHQgIH1cXG5cXHQgIHJldHVybiByZXQ7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDE3ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbnZlcnRDaGFuZ2VzVG9YTUwgPSBjb252ZXJ0Q2hhbmdlc1RvWE1MO1xcblxcdGZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VzVG9YTUwoY2hhbmdlcykge1xcblxcdCAgdmFyIHJldCA9IFtdO1xcblxcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xcblxcdCAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XFxuXFx0ICAgICAgcmV0LnB1c2goJzxpbnM+Jyk7XFxuXFx0ICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcXG5cXHQgICAgICByZXQucHVzaCgnPGRlbD4nKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICByZXQucHVzaChlc2NhcGVIVE1MKGNoYW5nZS52YWx1ZSkpO1xcblxcblxcdCAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XFxuXFx0ICAgICAgcmV0LnB1c2goJzwvaW5zPicpO1xcblxcdCAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XFxuXFx0ICAgICAgcmV0LnB1c2goJzwvZGVsPicpO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gcmV0LmpvaW4oJycpO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBlc2NhcGVIVE1MKHMpIHtcXG5cXHQgIHZhciBuID0gcztcXG5cXHQgIG4gPSBuLnJlcGxhY2UoLyYvZywgJyZhbXA7Jyk7XFxuXFx0ICBuID0gbi5yZXBsYWNlKC88L2csICcmbHQ7Jyk7XFxuXFx0ICBuID0gbi5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XFxuXFx0ICBuID0gbi5yZXBsYWNlKC9cXFwiL2csICcmcXVvdDsnKTtcXG5cXG5cXHQgIHJldHVybiBuO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KVxcbi8qKioqKiovIF0pXFxufSk7XFxuO1xcbn0se31dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIG1hdGNoT3BlcmF0b3JzUmUgPSAvW3xcXFxcXFxcXHt9KClbXFxcXF1eJCsqPy5dL2c7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XFxuXFx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XFxuXFx0XFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHN0ci5yZXBsYWNlKG1hdGNoT3BlcmF0b3JzUmUsICdcXFxcXFxcXCQmJyk7XFxufTtcXG5cXG59LHt9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgb2JqZWN0Q3JlYXRlUG9seWZpbGxcXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IG9iamVjdEtleXNQb2x5ZmlsbFxcbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgZnVuY3Rpb25CaW5kUG9seWZpbGxcXG5cXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XFxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfZXZlbnRzJykpIHtcXG4gICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XFxuICB9XFxuXFxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xcbn1cXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcXG5cXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XFxuXFxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXFxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xcblxcbnZhciBoYXNEZWZpbmVQcm9wZXJ0eTtcXG50cnkge1xcbiAgdmFyIG8gPSB7fTtcXG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCAneCcsIHsgdmFsdWU6IDAgfSk7XFxuICBoYXNEZWZpbmVQcm9wZXJ0eSA9IG8ueCA9PT0gMDtcXG59IGNhdGNoIChlcnIpIHsgaGFzRGVmaW5lUHJvcGVydHkgPSBmYWxzZSB9XFxuaWYgKGhhc0RlZmluZVByb3BlcnR5KSB7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcXG4gICAgfSxcXG4gICAgc2V0OiBmdW5jdGlvbihhcmcpIHtcXG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlIG51bWJlciAod2hvc2UgdmFsdWUgaXMgemVybyBvclxcbiAgICAgIC8vIGdyZWF0ZXIgYW5kIG5vdCBhIE5hTikuXFxuICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgYXJnICE9PSBhcmcpXFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwiZGVmYXVsdE1heExpc3RlbmVyc1xcXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xcbiAgICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XFxuICAgIH1cXG4gIH0pO1xcbn0gZWxzZSB7XFxuICBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XFxufVxcblxcbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xcbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcXG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpXFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJuXFxcIiBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XFxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcXG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcXG59XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XFxuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcXG59O1xcblxcbi8vIFRoZXNlIHN0YW5kYWxvbmUgZW1pdCogZnVuY3Rpb25zIGFyZSB1c2VkIHRvIG9wdGltaXplIGNhbGxpbmcgb2YgZXZlbnRcXG4vLyBoYW5kbGVycyBmb3IgZmFzdCBjYXNlcyBiZWNhdXNlIGVtaXQoKSBpdHNlbGYgb2Z0ZW4gaGFzIGEgdmFyaWFibGUgbnVtYmVyIG9mXFxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcXG4vLyB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCB0aHVzIGRvIG5vdCBnZXQgZGVvcHRpbWl6ZWQsIHNvIHRoZSBjb2RlXFxuLy8gaW5zaWRlIHRoZW0gY2FuIGV4ZWN1dGUgZmFzdGVyLlxcbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcXG4gIGlmIChpc0ZuKVxcbiAgICBoYW5kbGVyLmNhbGwoc2VsZik7XFxuICBlbHNlIHtcXG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYpO1xcbiAgfVxcbn1cXG5mdW5jdGlvbiBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEpIHtcXG4gIGlmIChpc0ZuKVxcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XFxuICBlbHNlIHtcXG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEpO1xcbiAgfVxcbn1cXG5mdW5jdGlvbiBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIpIHtcXG4gIGlmIChpc0ZuKVxcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XFxuICBlbHNlIHtcXG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xcbiAgfVxcbn1cXG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xcbiAgaWYgKGlzRm4pXFxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcXG4gIGVsc2Uge1xcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XFxuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXFxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZ3MpIHtcXG4gIGlmIChpc0ZuKVxcbiAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xcbiAgZWxzZSB7XFxuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcXG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XFxuICB9XFxufVxcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGV2ZW50cztcXG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xcblxcbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xcbiAgaWYgKGV2ZW50cylcXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PSBudWxsKTtcXG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxcbiAgICByZXR1cm4gZmFsc2U7XFxuXFxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXFxuICBpZiAoZG9FcnJvcikge1xcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXFxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XFxuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XFxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBcXFwiZXJyb3JcXFwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcXG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xcbiAgICAgIHRocm93IGVycjtcXG4gICAgfVxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xcblxcbiAgaWYgKCFoYW5kbGVyKVxcbiAgICByZXR1cm4gZmFsc2U7XFxuXFxuICB2YXIgaXNGbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xcbiAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gIHN3aXRjaCAobGVuKSB7XFxuICAgICAgLy8gZmFzdCBjYXNlc1xcbiAgICBjYXNlIDE6XFxuICAgICAgZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgdGhpcyk7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgMjpcXG4gICAgICBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSk7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgMzpcXG4gICAgICBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSA0OlxcbiAgICAgIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcXG4gICAgICBicmVhaztcXG4gICAgICAvLyBzbG93ZXJcXG4gICAgZGVmYXVsdDpcXG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcXG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xcbiAgICAgIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3MpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRydWU7XFxufTtcXG5cXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xcbiAgdmFyIG07XFxuICB2YXIgZXZlbnRzO1xcbiAgdmFyIGV4aXN0aW5nO1xcblxcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcImxpc3RlbmVyXFxcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcXG5cXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xcbiAgaWYgKCFldmVudHMpIHtcXG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XFxuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXFxcIm5ld0xpc3RlbmVyXFxcIiEgQmVmb3JlXFxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFxcXCJuZXdMaXN0ZW5lclxcXCIuXFxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIpIHtcXG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxcbiAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xcblxcbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XFxuICAgIH1cXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XFxuICB9XFxuXFxuICBpZiAoIWV4aXN0aW5nKSB7XFxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxcbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XFxuICB9IGVsc2Uge1xcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXFxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxcbiAgICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXFxuICAgICAgaWYgKHByZXBlbmQpIHtcXG4gICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcXG4gICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xcbiAgICAgIGlmIChtICYmIG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0pIHtcXG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XFxuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcXG4gICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnIFxcXCInICsgU3RyaW5nKHR5cGUpICsgJ1xcXCIgbGlzdGVuZXJzICcgK1xcbiAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXFxuICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0LicpO1xcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XFxuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XFxuICAgICAgICB3LnR5cGUgPSB0eXBlO1xcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XFxuICAgICAgICAgIGNvbnNvbGUud2FybignJXM6ICVzJywgdy5uYW1lLCB3Lm1lc3NhZ2UpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRhcmdldDtcXG59XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XFxuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XFxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xcbiAgICB9O1xcblxcbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XFxuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgICAgY2FzZSAwOlxcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XFxuICAgICAgY2FzZSAxOlxcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdKTtcXG4gICAgICBjYXNlIDI6XFxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XFxuICAgICAgY2FzZSAzOlxcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sXFxuICAgICAgICAgICAgYXJndW1lbnRzWzJdKTtcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpXFxuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XFxuICAgICAgICB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmdzKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XFxuICB2YXIgd3JhcHBlZCA9IGJpbmQuY2FsbChvbmNlV3JhcHBlciwgc3RhdGUpO1xcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcXG4gIHJldHVybiB3cmFwcGVkO1xcbn1cXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XFxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwibGlzdGVuZXJcXFwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cXG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwibGlzdGVuZXJcXFwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9O1xcblxcbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XFxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XFxuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJsaXN0ZW5lclxcXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XFxuXFxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xcbiAgICAgIGlmICghZXZlbnRzKVxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuXFxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcXG4gICAgICBpZiAoIWxpc3QpXFxuICAgICAgICByZXR1cm4gdGhpcztcXG5cXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcXG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcXG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcXG5cXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XFxuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XFxuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxcbiAgICAgICAgICByZXR1cm4gdGhpcztcXG5cXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xcblxcbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xcblxcbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XFxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XFxuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xcblxcbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcXG4gICAgICBpZiAoIWV2ZW50cylcXG4gICAgICAgIHJldHVybiB0aGlzO1xcblxcbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcXG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XFxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSkge1xcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XFxuICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoZXZlbnRzKTtcXG4gICAgICAgIHZhciBrZXk7XFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcXG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfVxcblxcbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcXG5cXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XFxuICAgICAgICAvLyBMSUZPIG9yZGVyXFxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XFxuICB2YXIgZXZsaXN0ZW5lcjtcXG4gIHZhciByZXQ7XFxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xcblxcbiAgaWYgKCFldmVudHMpXFxuICAgIHJldCA9IFtdO1xcbiAgZWxzZSB7XFxuICAgIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XFxuICAgIGlmICghZXZsaXN0ZW5lcilcXG4gICAgICByZXQgPSBbXTtcXG4gICAgZWxzZSBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXFxuICAgICAgcmV0ID0gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl07XFxuICAgIGVsc2VcXG4gICAgICByZXQgPSB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcik7XFxuICB9XFxuXFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XFxuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcXG4gIH1cXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XFxuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XFxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xcblxcbiAgaWYgKGV2ZW50cykge1xcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcXG5cXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgcmV0dXJuIDE7XFxuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lcikge1xcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIDA7XFxufVxcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XFxuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdC5vd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcXG59O1xcblxcbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKS5cXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcXG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSlcXG4gICAgbGlzdFtpXSA9IGxpc3Rba107XFxuICBsaXN0LnBvcCgpO1xcbn1cXG5cXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcXG4gICAgY29weVtpXSA9IGFycltpXTtcXG4gIHJldHVybiBjb3B5O1xcbn1cXG5cXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XFxuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcXG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcXG4gIH1cXG4gIHJldHVybiByZXQ7XFxufVxcblxcbmZ1bmN0aW9uIG9iamVjdENyZWF0ZVBvbHlmaWxsKHByb3RvKSB7XFxuICB2YXIgRiA9IGZ1bmN0aW9uKCkge307XFxuICBGLnByb3RvdHlwZSA9IHByb3RvO1xcbiAgcmV0dXJuIG5ldyBGO1xcbn1cXG5mdW5jdGlvbiBvYmplY3RLZXlzUG9seWZpbGwob2JqKSB7XFxuICB2YXIga2V5cyA9IFtdO1xcbiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkge1xcbiAgICBrZXlzLnB1c2goayk7XFxuICB9XFxuICByZXR1cm4gaztcXG59XFxuZnVuY3Rpb24gZnVuY3Rpb25CaW5kUG9seWZpbGwoY29udGV4dCkge1xcbiAgdmFyIGZuID0gdGhpcztcXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xcbiAgfTtcXG59XFxuXFxufSx7fV0sNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAoZ2xvYmFsKXtcXG4vKiEgaHR0cHM6Ly9tdGhzLmJlL2hlIHYxLjEuMSBieSBAbWF0aGlhcyB8IE1JVCBsaWNlbnNlICovXFxuOyhmdW5jdGlvbihyb290KSB7XFxuXFxuXFx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYC5cXG5cXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xcblxcblxcdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLlxcblxcdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XFxuXFxuXFx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcXG5cXHQvLyBhbmQgdXNlIGl0IGFzIGByb290YC5cXG5cXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xcblxcdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xcblxcdFxcdHJvb3QgPSBmcmVlR2xvYmFsO1xcblxcdH1cXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG5cXHQvLyBBbGwgYXN0cmFsIHN5bWJvbHMuXFxuXFx0dmFyIHJlZ2V4QXN0cmFsU3ltYm9scyA9IC9bXFxcXHVEODAwLVxcXFx1REJGRl1bXFxcXHVEQzAwLVxcXFx1REZGRl0vZztcXG5cXHQvLyBBbGwgQVNDSUkgc3ltYm9scyAobm90IGp1c3QgcHJpbnRhYmxlIEFTQ0lJKSBleGNlcHQgdGhvc2UgbGlzdGVkIGluIHRoZVxcblxcdC8vIGZpcnN0IGNvbHVtbiBvZiB0aGUgb3ZlcnJpZGVzIHRhYmxlLlxcblxcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3RhYmxlLWNoYXJyZWYtb3ZlcnJpZGVzXFxuXFx0dmFyIHJlZ2V4QXNjaWlXaGl0ZWxpc3QgPSAvW1xcXFx4MDEtXFxcXHg3Rl0vZztcXG5cXHQvLyBBbGwgQk1QIHN5bWJvbHMgdGhhdCBhcmUgbm90IEFTQ0lJIG5ld2xpbmVzLCBwcmludGFibGUgQVNDSUkgc3ltYm9scywgb3JcXG5cXHQvLyBjb2RlIHBvaW50cyBsaXN0ZWQgaW4gdGhlIGZpcnN0IGNvbHVtbiBvZiB0aGUgb3ZlcnJpZGVzIHRhYmxlIG9uXFxuXFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjdGFibGUtY2hhcnJlZi1vdmVycmlkZXMuXFxuXFx0dmFyIHJlZ2V4Qm1wV2hpdGVsaXN0ID0gL1tcXFxceDAxLVxcXFx0XFxcXHgwQlxcXFxmXFxcXHgwRS1cXFxceDFGXFxcXHg3RlxcXFx4ODFcXFxceDhEXFxcXHg4RlxcXFx4OTBcXFxceDlEXFxcXHhBMC1cXFxcdUZGRkZdL2c7XFxuXFxuXFx0dmFyIHJlZ2V4RW5jb2RlTm9uQXNjaWkgPSAvPFxcXFx1MjBEMnw9XFxcXHUyMEU1fD5cXFxcdTIwRDJ8XFxcXHUyMDVGXFxcXHUyMDBBfFxcXFx1MjE5RFxcXFx1MDMzOHxcXFxcdTIyMDJcXFxcdTAzMzh8XFxcXHUyMjIwXFxcXHUyMEQyfFxcXFx1MjIyOVxcXFx1RkUwMHxcXFxcdTIyMkFcXFxcdUZFMDB8XFxcXHUyMjNDXFxcXHUyMEQyfFxcXFx1MjIzRFxcXFx1MDMzMXxcXFxcdTIyM0VcXFxcdTAzMzN8XFxcXHUyMjQyXFxcXHUwMzM4fFxcXFx1MjI0QlxcXFx1MDMzOHxcXFxcdTIyNERcXFxcdTIwRDJ8XFxcXHUyMjRFXFxcXHUwMzM4fFxcXFx1MjI0RlxcXFx1MDMzOHxcXFxcdTIyNTBcXFxcdTAzMzh8XFxcXHUyMjYxXFxcXHUyMEU1fFxcXFx1MjI2NFxcXFx1MjBEMnxcXFxcdTIyNjVcXFxcdTIwRDJ8XFxcXHUyMjY2XFxcXHUwMzM4fFxcXFx1MjI2N1xcXFx1MDMzOHxcXFxcdTIyNjhcXFxcdUZFMDB8XFxcXHUyMjY5XFxcXHVGRTAwfFxcXFx1MjI2QVxcXFx1MDMzOHxcXFxcdTIyNkFcXFxcdTIwRDJ8XFxcXHUyMjZCXFxcXHUwMzM4fFxcXFx1MjI2QlxcXFx1MjBEMnxcXFxcdTIyN0ZcXFxcdTAzMzh8XFxcXHUyMjgyXFxcXHUyMEQyfFxcXFx1MjI4M1xcXFx1MjBEMnxcXFxcdTIyOEFcXFxcdUZFMDB8XFxcXHUyMjhCXFxcXHVGRTAwfFxcXFx1MjI4RlxcXFx1MDMzOHxcXFxcdTIyOTBcXFxcdTAzMzh8XFxcXHUyMjkzXFxcXHVGRTAwfFxcXFx1MjI5NFxcXFx1RkUwMHxcXFxcdTIyQjRcXFxcdTIwRDJ8XFxcXHUyMkI1XFxcXHUyMEQyfFxcXFx1MjJEOFxcXFx1MDMzOHxcXFxcdTIyRDlcXFxcdTAzMzh8XFxcXHUyMkRBXFxcXHVGRTAwfFxcXFx1MjJEQlxcXFx1RkUwMHxcXFxcdTIyRjVcXFxcdTAzMzh8XFxcXHUyMkY5XFxcXHUwMzM4fFxcXFx1MjkzM1xcXFx1MDMzOHxcXFxcdTI5Q0ZcXFxcdTAzMzh8XFxcXHUyOUQwXFxcXHUwMzM4fFxcXFx1MkE2RFxcXFx1MDMzOHxcXFxcdTJBNzBcXFxcdTAzMzh8XFxcXHUyQTdEXFxcXHUwMzM4fFxcXFx1MkE3RVxcXFx1MDMzOHxcXFxcdTJBQTFcXFxcdTAzMzh8XFxcXHUyQUEyXFxcXHUwMzM4fFxcXFx1MkFBQ1xcXFx1RkUwMHxcXFxcdTJBQURcXFxcdUZFMDB8XFxcXHUyQUFGXFxcXHUwMzM4fFxcXFx1MkFCMFxcXFx1MDMzOHxcXFxcdTJBQzVcXFxcdTAzMzh8XFxcXHUyQUM2XFxcXHUwMzM4fFxcXFx1MkFDQlxcXFx1RkUwMHxcXFxcdTJBQ0NcXFxcdUZFMDB8XFxcXHUyQUZEXFxcXHUyMEU1fFtcXFxceEEwLVxcXFx1MDExM1xcXFx1MDExNi1cXFxcdTAxMjJcXFxcdTAxMjQtXFxcXHUwMTJCXFxcXHUwMTJFLVxcXFx1MDE0RFxcXFx1MDE1MC1cXFxcdTAxN0VcXFxcdTAxOTJcXFxcdTAxQjVcXFxcdTAxRjVcXFxcdTAyMzdcXFxcdTAyQzZcXFxcdTAyQzdcXFxcdTAyRDgtXFxcXHUwMkREXFxcXHUwMzExXFxcXHUwMzkxLVxcXFx1MDNBMVxcXFx1MDNBMy1cXFxcdTAzQTlcXFxcdTAzQjEtXFxcXHUwM0M5XFxcXHUwM0QxXFxcXHUwM0QyXFxcXHUwM0Q1XFxcXHUwM0Q2XFxcXHUwM0RDXFxcXHUwM0REXFxcXHUwM0YwXFxcXHUwM0YxXFxcXHUwM0Y1XFxcXHUwM0Y2XFxcXHUwNDAxLVxcXFx1MDQwQ1xcXFx1MDQwRS1cXFxcdTA0NEZcXFxcdTA0NTEtXFxcXHUwNDVDXFxcXHUwNDVFXFxcXHUwNDVGXFxcXHUyMDAyLVxcXFx1MjAwNVxcXFx1MjAwNy1cXFxcdTIwMTBcXFxcdTIwMTMtXFxcXHUyMDE2XFxcXHUyMDE4LVxcXFx1MjAxQVxcXFx1MjAxQy1cXFxcdTIwMUVcXFxcdTIwMjAtXFxcXHUyMDIyXFxcXHUyMDI1XFxcXHUyMDI2XFxcXHUyMDMwLVxcXFx1MjAzNVxcXFx1MjAzOVxcXFx1MjAzQVxcXFx1MjAzRVxcXFx1MjA0MVxcXFx1MjA0M1xcXFx1MjA0NFxcXFx1MjA0RlxcXFx1MjA1N1xcXFx1MjA1Ri1cXFxcdTIwNjNcXFxcdTIwQUNcXFxcdTIwREJcXFxcdTIwRENcXFxcdTIxMDJcXFxcdTIxMDVcXFxcdTIxMEEtXFxcXHUyMTEzXFxcXHUyMTE1LVxcXFx1MjExRVxcXFx1MjEyMlxcXFx1MjEyNFxcXFx1MjEyNy1cXFxcdTIxMjlcXFxcdTIxMkNcXFxcdTIxMkRcXFxcdTIxMkYtXFxcXHUyMTMxXFxcXHUyMTMzLVxcXFx1MjEzOFxcXFx1MjE0NS1cXFxcdTIxNDhcXFxcdTIxNTMtXFxcXHUyMTVFXFxcXHUyMTkwLVxcXFx1MjE5QlxcXFx1MjE5RC1cXFxcdTIxQTdcXFxcdTIxQTktXFxcXHUyMUFFXFxcXHUyMUIwLVxcXFx1MjFCM1xcXFx1MjFCNS1cXFxcdTIxQjdcXFxcdTIxQkEtXFxcXHUyMURCXFxcXHUyMUREXFxcXHUyMUU0XFxcXHUyMUU1XFxcXHUyMUY1XFxcXHUyMUZELVxcXFx1MjIwNVxcXFx1MjIwNy1cXFxcdTIyMDlcXFxcdTIyMEJcXFxcdTIyMENcXFxcdTIyMEYtXFxcXHUyMjE0XFxcXHUyMjE2LVxcXFx1MjIxOFxcXFx1MjIxQVxcXFx1MjIxRC1cXFxcdTIyMzhcXFxcdTIyM0EtXFxcXHUyMjU3XFxcXHUyMjU5XFxcXHUyMjVBXFxcXHUyMjVDXFxcXHUyMjVGLVxcXFx1MjI2MlxcXFx1MjI2NC1cXFxcdTIyOEJcXFxcdTIyOEQtXFxcXHUyMjlCXFxcXHUyMjlELVxcXFx1MjJBNVxcXFx1MjJBNy1cXFxcdTIyQjBcXFxcdTIyQjItXFxcXHUyMkJCXFxcXHUyMkJELVxcXFx1MjJEQlxcXFx1MjJERS1cXFxcdTIyRTNcXFxcdTIyRTYtXFxcXHUyMkY3XFxcXHUyMkY5LVxcXFx1MjJGRVxcXFx1MjMwNVxcXFx1MjMwNlxcXFx1MjMwOC1cXFxcdTIzMTBcXFxcdTIzMTJcXFxcdTIzMTNcXFxcdTIzMTVcXFxcdTIzMTZcXFxcdTIzMUMtXFxcXHUyMzFGXFxcXHUyMzIyXFxcXHUyMzIzXFxcXHUyMzJEXFxcXHUyMzJFXFxcXHUyMzM2XFxcXHUyMzNEXFxcXHUyMzNGXFxcXHUyMzdDXFxcXHUyM0IwXFxcXHUyM0IxXFxcXHUyM0I0LVxcXFx1MjNCNlxcXFx1MjNEQy1cXFxcdTIzREZcXFxcdTIzRTJcXFxcdTIzRTdcXFxcdTI0MjNcXFxcdTI0QzhcXFxcdTI1MDBcXFxcdTI1MDJcXFxcdTI1MENcXFxcdTI1MTBcXFxcdTI1MTRcXFxcdTI1MThcXFxcdTI1MUNcXFxcdTI1MjRcXFxcdTI1MkNcXFxcdTI1MzRcXFxcdTI1M0NcXFxcdTI1NTAtXFxcXHUyNTZDXFxcXHUyNTgwXFxcXHUyNTg0XFxcXHUyNTg4XFxcXHUyNTkxLVxcXFx1MjU5M1xcXFx1MjVBMVxcXFx1MjVBQVxcXFx1MjVBQlxcXFx1MjVBRFxcXFx1MjVBRVxcXFx1MjVCMVxcXFx1MjVCMy1cXFxcdTI1QjVcXFxcdTI1QjhcXFxcdTI1QjlcXFxcdTI1QkQtXFxcXHUyNUJGXFxcXHUyNUMyXFxcXHUyNUMzXFxcXHUyNUNBXFxcXHUyNUNCXFxcXHUyNUVDXFxcXHUyNUVGXFxcXHUyNUY4LVxcXFx1MjVGQ1xcXFx1MjYwNVxcXFx1MjYwNlxcXFx1MjYwRVxcXFx1MjY0MFxcXFx1MjY0MlxcXFx1MjY2MFxcXFx1MjY2M1xcXFx1MjY2NVxcXFx1MjY2NlxcXFx1MjY2QVxcXFx1MjY2RC1cXFxcdTI2NkZcXFxcdTI3MTNcXFxcdTI3MTdcXFxcdTI3MjBcXFxcdTI3MzZcXFxcdTI3NThcXFxcdTI3NzJcXFxcdTI3NzNcXFxcdTI3QzhcXFxcdTI3QzlcXFxcdTI3RTYtXFxcXHUyN0VEXFxcXHUyN0Y1LVxcXFx1MjdGQVxcXFx1MjdGQ1xcXFx1MjdGRlxcXFx1MjkwMi1cXFxcdTI5MDVcXFxcdTI5MEMtXFxcXHUyOTEzXFxcXHUyOTE2XFxcXHUyOTE5LVxcXFx1MjkyMFxcXFx1MjkyMy1cXFxcdTI5MkFcXFxcdTI5MzNcXFxcdTI5MzUtXFxcXHUyOTM5XFxcXHUyOTNDXFxcXHUyOTNEXFxcXHUyOTQ1XFxcXHUyOTQ4LVxcXFx1Mjk0QlxcXFx1Mjk0RS1cXFxcdTI5NzZcXFxcdTI5NzhcXFxcdTI5NzlcXFxcdTI5N0ItXFxcXHUyOTdGXFxcXHUyOTg1XFxcXHUyOTg2XFxcXHUyOThCLVxcXFx1Mjk5NlxcXFx1Mjk5QVxcXFx1Mjk5Q1xcXFx1Mjk5RFxcXFx1MjlBNC1cXFxcdTI5QjdcXFxcdTI5QjlcXFxcdTI5QkJcXFxcdTI5QkNcXFxcdTI5QkUtXFxcXHUyOUM1XFxcXHUyOUM5XFxcXHUyOUNELVxcXFx1MjlEMFxcXFx1MjlEQy1cXFxcdTI5REVcXFxcdTI5RTMtXFxcXHUyOUU1XFxcXHUyOUVCXFxcXHUyOUY0XFxcXHUyOUY2XFxcXHUyQTAwLVxcXFx1MkEwMlxcXFx1MkEwNFxcXFx1MkEwNlxcXFx1MkEwQ1xcXFx1MkEwRFxcXFx1MkExMC1cXFxcdTJBMTdcXFxcdTJBMjItXFxcXHUyQTI3XFxcXHUyQTI5XFxcXHUyQTJBXFxcXHUyQTJELVxcXFx1MkEzMVxcXFx1MkEzMy1cXFxcdTJBM0NcXFxcdTJBM0ZcXFxcdTJBNDBcXFxcdTJBNDItXFxcXHUyQTREXFxcXHUyQTUwXFxcXHUyQTUzLVxcXFx1MkE1OFxcXFx1MkE1QS1cXFxcdTJBNURcXFxcdTJBNUZcXFxcdTJBNjZcXFxcdTJBNkFcXFxcdTJBNkQtXFxcXHUyQTc1XFxcXHUyQTc3LVxcXFx1MkE5QVxcXFx1MkE5RC1cXFxcdTJBQTJcXFxcdTJBQTQtXFxcXHUyQUIwXFxcXHUyQUIzLVxcXFx1MkFDOFxcXFx1MkFDQlxcXFx1MkFDQ1xcXFx1MkFDRi1cXFxcdTJBREJcXFxcdTJBRTRcXFxcdTJBRTYtXFxcXHUyQUU5XFxcXHUyQUVCLVxcXFx1MkFGM1xcXFx1MkFGRFxcXFx1RkIwMC1cXFxcdUZCMDRdfFxcXFx1RDgzNVtcXFxcdURDOUNcXFxcdURDOUVcXFxcdURDOUZcXFxcdURDQTJcXFxcdURDQTVcXFxcdURDQTZcXFxcdURDQTktXFxcXHVEQ0FDXFxcXHVEQ0FFLVxcXFx1RENCOVxcXFx1RENCQlxcXFx1RENCRC1cXFxcdURDQzNcXFxcdURDQzUtXFxcXHVEQ0NGXFxcXHVERDA0XFxcXHVERDA1XFxcXHVERDA3LVxcXFx1REQwQVxcXFx1REQwRC1cXFxcdUREMTRcXFxcdUREMTYtXFxcXHVERDFDXFxcXHVERDFFLVxcXFx1REQzOVxcXFx1REQzQi1cXFxcdUREM0VcXFxcdURENDAtXFxcXHVERDQ0XFxcXHVERDQ2XFxcXHVERDRBLVxcXFx1REQ1MFxcXFx1REQ1Mi1cXFxcdURENkJdL2c7XFxuXFx0dmFyIGVuY29kZU1hcCA9IHsnXFxcXHhBRCc6J3NoeScsJ1xcXFx1MjAwQyc6J3p3bmonLCdcXFxcdTIwMEQnOid6d2onLCdcXFxcdTIwMEUnOidscm0nLCdcXFxcdTIwNjMnOidpYycsJ1xcXFx1MjA2Mic6J2l0JywnXFxcXHUyMDYxJzonYWYnLCdcXFxcdTIwMEYnOidybG0nLCdcXFxcdTIwMEInOidaZXJvV2lkdGhTcGFjZScsJ1xcXFx1MjA2MCc6J05vQnJlYWsnLCdcXFxcdTAzMTEnOidEb3duQnJldmUnLCdcXFxcdTIwREInOid0ZG90JywnXFxcXHUyMERDJzonRG90RG90JywnXFxcXHQnOidUYWInLCdcXFxcbic6J05ld0xpbmUnLCdcXFxcdTIwMDgnOidwdW5jc3AnLCdcXFxcdTIwNUYnOidNZWRpdW1TcGFjZScsJ1xcXFx1MjAwOSc6J3RoaW5zcCcsJ1xcXFx1MjAwQSc6J2hhaXJzcCcsJ1xcXFx1MjAwNCc6J2Vtc3AxMycsJ1xcXFx1MjAwMic6J2Vuc3AnLCdcXFxcdTIwMDUnOidlbXNwMTQnLCdcXFxcdTIwMDMnOidlbXNwJywnXFxcXHUyMDA3JzonbnVtc3AnLCdcXFxceEEwJzonbmJzcCcsJ1xcXFx1MjA1RlxcXFx1MjAwQSc6J1RoaWNrU3BhY2UnLCdcXFxcdTIwM0UnOidvbGluZScsJ18nOidsb3diYXInLCdcXFxcdTIwMTAnOidkYXNoJywnXFxcXHUyMDEzJzonbmRhc2gnLCdcXFxcdTIwMTQnOidtZGFzaCcsJ1xcXFx1MjAxNSc6J2hvcmJhcicsJywnOidjb21tYScsJzsnOidzZW1pJywnXFxcXHUyMDRGJzonYnNlbWknLCc6JzonY29sb24nLCdcXFxcdTJBNzQnOidDb2xvbmUnLCchJzonZXhjbCcsJ1xcXFx4QTEnOidpZXhjbCcsJz8nOidxdWVzdCcsJ1xcXFx4QkYnOidpcXVlc3QnLCcuJzoncGVyaW9kJywnXFxcXHUyMDI1JzonbmxkcicsJ1xcXFx1MjAyNic6J21sZHInLCdcXFxceEI3JzonbWlkZG90JywnXFxcXCcnOidhcG9zJywnXFxcXHUyMDE4JzonbHNxdW8nLCdcXFxcdTIwMTknOidyc3F1bycsJ1xcXFx1MjAxQSc6J3NicXVvJywnXFxcXHUyMDM5JzonbHNhcXVvJywnXFxcXHUyMDNBJzoncnNhcXVvJywnXFxcIic6J3F1b3QnLCdcXFxcdTIwMUMnOidsZHF1bycsJ1xcXFx1MjAxRCc6J3JkcXVvJywnXFxcXHUyMDFFJzonYmRxdW8nLCdcXFxceEFCJzonbGFxdW8nLCdcXFxceEJCJzoncmFxdW8nLCcoJzonbHBhcicsJyknOidycGFyJywnWyc6J2xzcWInLCddJzoncnNxYicsJ3snOidsY3ViJywnfSc6J3JjdWInLCdcXFxcdTIzMDgnOidsY2VpbCcsJ1xcXFx1MjMwOSc6J3JjZWlsJywnXFxcXHUyMzBBJzonbGZsb29yJywnXFxcXHUyMzBCJzoncmZsb29yJywnXFxcXHUyOTg1JzonbG9wYXInLCdcXFxcdTI5ODYnOidyb3BhcicsJ1xcXFx1Mjk4Qic6J2xicmtlJywnXFxcXHUyOThDJzoncmJya2UnLCdcXFxcdTI5OEQnOidsYnJrc2x1JywnXFxcXHUyOThFJzoncmJya3NsZCcsJ1xcXFx1Mjk4Ric6J2xicmtzbGQnLCdcXFxcdTI5OTAnOidyYnJrc2x1JywnXFxcXHUyOTkxJzonbGFuZ2QnLCdcXFxcdTI5OTInOidyYW5nZCcsJ1xcXFx1Mjk5Myc6J2xwYXJsdCcsJ1xcXFx1Mjk5NCc6J3JwYXJndCcsJ1xcXFx1Mjk5NSc6J2d0bFBhcicsJ1xcXFx1Mjk5Nic6J2x0clBhcicsJ1xcXFx1MjdFNic6J2xvYnJrJywnXFxcXHUyN0U3Jzoncm9icmsnLCdcXFxcdTI3RTgnOidsYW5nJywnXFxcXHUyN0U5JzoncmFuZycsJ1xcXFx1MjdFQSc6J0xhbmcnLCdcXFxcdTI3RUInOidSYW5nJywnXFxcXHUyN0VDJzonbG9hbmcnLCdcXFxcdTI3RUQnOidyb2FuZycsJ1xcXFx1Mjc3Mic6J2xiYnJrJywnXFxcXHUyNzczJzoncmJicmsnLCdcXFxcdTIwMTYnOidWZXJ0JywnXFxcXHhBNyc6J3NlY3QnLCdcXFxceEI2JzoncGFyYScsJ0AnOidjb21tYXQnLCcqJzonYXN0JywnLyc6J3NvbCcsJ3VuZGVmaW5lZCc6bnVsbCwnJic6J2FtcCcsJyMnOidudW0nLCclJzoncGVyY250JywnXFxcXHUyMDMwJzoncGVybWlsJywnXFxcXHUyMDMxJzoncGVydGVuaycsJ1xcXFx1MjAyMCc6J2RhZ2dlcicsJ1xcXFx1MjAyMSc6J0RhZ2dlcicsJ1xcXFx1MjAyMic6J2J1bGwnLCdcXFxcdTIwNDMnOidoeWJ1bGwnLCdcXFxcdTIwMzInOidwcmltZScsJ1xcXFx1MjAzMyc6J1ByaW1lJywnXFxcXHUyMDM0JzondHByaW1lJywnXFxcXHUyMDU3JzoncXByaW1lJywnXFxcXHUyMDM1JzonYnByaW1lJywnXFxcXHUyMDQxJzonY2FyZXQnLCdgJzonZ3JhdmUnLCdcXFxceEI0JzonYWN1dGUnLCdcXFxcdTAyREMnOid0aWxkZScsJ14nOidIYXQnLCdcXFxceEFGJzonbWFjcicsJ1xcXFx1MDJEOCc6J2JyZXZlJywnXFxcXHUwMkQ5JzonZG90JywnXFxcXHhBOCc6J2RpZScsJ1xcXFx1MDJEQSc6J3JpbmcnLCdcXFxcdTAyREQnOidkYmxhYycsJ1xcXFx4QjgnOidjZWRpbCcsJ1xcXFx1MDJEQic6J29nb24nLCdcXFxcdTAyQzYnOidjaXJjJywnXFxcXHUwMkM3JzonY2Fyb24nLCdcXFxceEIwJzonZGVnJywnXFxcXHhBOSc6J2NvcHknLCdcXFxceEFFJzoncmVnJywnXFxcXHUyMTE3JzonY29weXNyJywnXFxcXHUyMTE4Jzond3AnLCdcXFxcdTIxMUUnOidyeCcsJ1xcXFx1MjEyNyc6J21obycsJ1xcXFx1MjEyOSc6J2lpb3RhJywnXFxcXHUyMTkwJzonbGFycicsJ1xcXFx1MjE5QSc6J25sYXJyJywnXFxcXHUyMTkyJzoncmFycicsJ1xcXFx1MjE5Qic6J25yYXJyJywnXFxcXHUyMTkxJzondWFycicsJ1xcXFx1MjE5Myc6J2RhcnInLCdcXFxcdTIxOTQnOidoYXJyJywnXFxcXHUyMUFFJzonbmhhcnInLCdcXFxcdTIxOTUnOid2YXJyJywnXFxcXHUyMTk2JzonbndhcnInLCdcXFxcdTIxOTcnOiduZWFycicsJ1xcXFx1MjE5OCc6J3NlYXJyJywnXFxcXHUyMTk5Jzonc3dhcnInLCdcXFxcdTIxOUQnOidyYXJydycsJ1xcXFx1MjE5RFxcXFx1MDMzOCc6J25yYXJydycsJ1xcXFx1MjE5RSc6J0xhcnInLCdcXFxcdTIxOUYnOidVYXJyJywnXFxcXHUyMUEwJzonUmFycicsJ1xcXFx1MjFBMSc6J0RhcnInLCdcXFxcdTIxQTInOidsYXJydGwnLCdcXFxcdTIxQTMnOidyYXJydGwnLCdcXFxcdTIxQTQnOidtYXBzdG9sZWZ0JywnXFxcXHUyMUE1JzonbWFwc3RvdXAnLCdcXFxcdTIxQTYnOidtYXAnLCdcXFxcdTIxQTcnOidtYXBzdG9kb3duJywnXFxcXHUyMUE5JzonbGFycmhrJywnXFxcXHUyMUFBJzoncmFycmhrJywnXFxcXHUyMUFCJzonbGFycmxwJywnXFxcXHUyMUFDJzoncmFycmxwJywnXFxcXHUyMUFEJzonaGFycncnLCdcXFxcdTIxQjAnOidsc2gnLCdcXFxcdTIxQjEnOidyc2gnLCdcXFxcdTIxQjInOidsZHNoJywnXFxcXHUyMUIzJzoncmRzaCcsJ1xcXFx1MjFCNSc6J2NyYXJyJywnXFxcXHUyMUI2JzonY3VsYXJyJywnXFxcXHUyMUI3JzonY3VyYXJyJywnXFxcXHUyMUJBJzonb2xhcnInLCdcXFxcdTIxQkInOidvcmFycicsJ1xcXFx1MjFCQyc6J2xoYXJ1JywnXFxcXHUyMUJEJzonbGhhcmQnLCdcXFxcdTIxQkUnOid1aGFycicsJ1xcXFx1MjFCRic6J3VoYXJsJywnXFxcXHUyMUMwJzoncmhhcnUnLCdcXFxcdTIxQzEnOidyaGFyZCcsJ1xcXFx1MjFDMic6J2RoYXJyJywnXFxcXHUyMUMzJzonZGhhcmwnLCdcXFxcdTIxQzQnOidybGFycicsJ1xcXFx1MjFDNSc6J3VkYXJyJywnXFxcXHUyMUM2JzonbHJhcnInLCdcXFxcdTIxQzcnOidsbGFycicsJ1xcXFx1MjFDOCc6J3V1YXJyJywnXFxcXHUyMUM5JzoncnJhcnInLCdcXFxcdTIxQ0EnOidkZGFycicsJ1xcXFx1MjFDQic6J2xyaGFyJywnXFxcXHUyMUNDJzoncmxoYXInLCdcXFxcdTIxRDAnOidsQXJyJywnXFxcXHUyMUNEJzonbmxBcnInLCdcXFxcdTIxRDEnOid1QXJyJywnXFxcXHUyMUQyJzonckFycicsJ1xcXFx1MjFDRic6J25yQXJyJywnXFxcXHUyMUQzJzonZEFycicsJ1xcXFx1MjFENCc6J2lmZicsJ1xcXFx1MjFDRSc6J25oQXJyJywnXFxcXHUyMUQ1JzondkFycicsJ1xcXFx1MjFENic6J253QXJyJywnXFxcXHUyMUQ3JzonbmVBcnInLCdcXFxcdTIxRDgnOidzZUFycicsJ1xcXFx1MjFEOSc6J3N3QXJyJywnXFxcXHUyMURBJzonbEFhcnInLCdcXFxcdTIxREInOidyQWFycicsJ1xcXFx1MjFERCc6J3ppZ3JhcnInLCdcXFxcdTIxRTQnOidsYXJyYicsJ1xcXFx1MjFFNSc6J3JhcnJiJywnXFxcXHUyMUY1JzonZHVhcnInLCdcXFxcdTIxRkQnOidsb2FycicsJ1xcXFx1MjFGRSc6J3JvYXJyJywnXFxcXHUyMUZGJzonaG9hcnInLCdcXFxcdTIyMDAnOidmb3JhbGwnLCdcXFxcdTIyMDEnOidjb21wJywnXFxcXHUyMjAyJzoncGFydCcsJ1xcXFx1MjIwMlxcXFx1MDMzOCc6J25wYXJ0JywnXFxcXHUyMjAzJzonZXhpc3QnLCdcXFxcdTIyMDQnOiduZXhpc3QnLCdcXFxcdTIyMDUnOidlbXB0eScsJ1xcXFx1MjIwNyc6J0RlbCcsJ1xcXFx1MjIwOCc6J2luJywnXFxcXHUyMjA5Jzonbm90aW4nLCdcXFxcdTIyMEInOiduaScsJ1xcXFx1MjIwQyc6J25vdG5pJywnXFxcXHUwM0Y2JzonYmVwc2knLCdcXFxcdTIyMEYnOidwcm9kJywnXFxcXHUyMjEwJzonY29wcm9kJywnXFxcXHUyMjExJzonc3VtJywnKyc6J3BsdXMnLCdcXFxceEIxJzoncG0nLCdcXFxceEY3JzonZGl2JywnXFxcXHhENyc6J3RpbWVzJywnPCc6J2x0JywnXFxcXHUyMjZFJzonbmx0JywnPFxcXFx1MjBEMic6J252bHQnLCc9JzonZXF1YWxzJywnXFxcXHUyMjYwJzonbmUnLCc9XFxcXHUyMEU1JzonYm5lJywnXFxcXHUyQTc1JzonRXF1YWwnLCc+JzonZ3QnLCdcXFxcdTIyNkYnOiduZ3QnLCc+XFxcXHUyMEQyJzonbnZndCcsJ1xcXFx4QUMnOidub3QnLCd8JzondmVydCcsJ1xcXFx4QTYnOidicnZiYXInLCdcXFxcdTIyMTInOidtaW51cycsJ1xcXFx1MjIxMyc6J21wJywnXFxcXHUyMjE0JzoncGx1c2RvJywnXFxcXHUyMDQ0JzonZnJhc2wnLCdcXFxcdTIyMTYnOidzZXRtbicsJ1xcXFx1MjIxNyc6J2xvd2FzdCcsJ1xcXFx1MjIxOCc6J2NvbXBmbicsJ1xcXFx1MjIxQSc6J1NxcnQnLCdcXFxcdTIyMUQnOidwcm9wJywnXFxcXHUyMjFFJzonaW5maW4nLCdcXFxcdTIyMUYnOidhbmdydCcsJ1xcXFx1MjIyMCc6J2FuZycsJ1xcXFx1MjIyMFxcXFx1MjBEMic6J25hbmcnLCdcXFxcdTIyMjEnOidhbmdtc2QnLCdcXFxcdTIyMjInOidhbmdzcGgnLCdcXFxcdTIyMjMnOidtaWQnLCdcXFxcdTIyMjQnOidubWlkJywnXFxcXHUyMjI1JzoncGFyJywnXFxcXHUyMjI2JzonbnBhcicsJ1xcXFx1MjIyNyc6J2FuZCcsJ1xcXFx1MjIyOCc6J29yJywnXFxcXHUyMjI5JzonY2FwJywnXFxcXHUyMjI5XFxcXHVGRTAwJzonY2FwcycsJ1xcXFx1MjIyQSc6J2N1cCcsJ1xcXFx1MjIyQVxcXFx1RkUwMCc6J2N1cHMnLCdcXFxcdTIyMkInOidpbnQnLCdcXFxcdTIyMkMnOidJbnQnLCdcXFxcdTIyMkQnOid0aW50JywnXFxcXHUyQTBDJzoncWludCcsJ1xcXFx1MjIyRSc6J29pbnQnLCdcXFxcdTIyMkYnOidDb25pbnQnLCdcXFxcdTIyMzAnOidDY29uaW50JywnXFxcXHUyMjMxJzonY3dpbnQnLCdcXFxcdTIyMzInOidjd2NvbmludCcsJ1xcXFx1MjIzMyc6J2F3Y29uaW50JywnXFxcXHUyMjM0JzondGhlcmU0JywnXFxcXHUyMjM1JzonYmVjYXVzJywnXFxcXHUyMjM2JzoncmF0aW8nLCdcXFxcdTIyMzcnOidDb2xvbicsJ1xcXFx1MjIzOCc6J21pbnVzZCcsJ1xcXFx1MjIzQSc6J21ERG90JywnXFxcXHUyMjNCJzonaG9tdGh0JywnXFxcXHUyMjNDJzonc2ltJywnXFxcXHUyMjQxJzonbnNpbScsJ1xcXFx1MjIzQ1xcXFx1MjBEMic6J252c2ltJywnXFxcXHUyMjNEJzonYnNpbScsJ1xcXFx1MjIzRFxcXFx1MDMzMSc6J3JhY2UnLCdcXFxcdTIyM0UnOidhYycsJ1xcXFx1MjIzRVxcXFx1MDMzMyc6J2FjRScsJ1xcXFx1MjIzRic6J2FjZCcsJ1xcXFx1MjI0MCc6J3dyJywnXFxcXHUyMjQyJzonZXNpbScsJ1xcXFx1MjI0MlxcXFx1MDMzOCc6J25lc2ltJywnXFxcXHUyMjQzJzonc2ltZScsJ1xcXFx1MjI0NCc6J25zaW1lJywnXFxcXHUyMjQ1JzonY29uZycsJ1xcXFx1MjI0Nyc6J25jb25nJywnXFxcXHUyMjQ2Jzonc2ltbmUnLCdcXFxcdTIyNDgnOidhcCcsJ1xcXFx1MjI0OSc6J25hcCcsJ1xcXFx1MjI0QSc6J2FwZScsJ1xcXFx1MjI0Qic6J2FwaWQnLCdcXFxcdTIyNEJcXFxcdTAzMzgnOiduYXBpZCcsJ1xcXFx1MjI0Qyc6J2Jjb25nJywnXFxcXHUyMjREJzonQ3VwQ2FwJywnXFxcXHUyMjZEJzonTm90Q3VwQ2FwJywnXFxcXHUyMjREXFxcXHUyMEQyJzonbnZhcCcsJ1xcXFx1MjI0RSc6J2J1bXAnLCdcXFxcdTIyNEVcXFxcdTAzMzgnOiduYnVtcCcsJ1xcXFx1MjI0Ric6J2J1bXBlJywnXFxcXHUyMjRGXFxcXHUwMzM4JzonbmJ1bXBlJywnXFxcXHUyMjUwJzonZG90ZXEnLCdcXFxcdTIyNTBcXFxcdTAzMzgnOiduZWRvdCcsJ1xcXFx1MjI1MSc6J2VEb3QnLCdcXFxcdTIyNTInOidlZkRvdCcsJ1xcXFx1MjI1Myc6J2VyRG90JywnXFxcXHUyMjU0JzonY29sb25lJywnXFxcXHUyMjU1JzonZWNvbG9uJywnXFxcXHUyMjU2JzonZWNpcicsJ1xcXFx1MjI1Nyc6J2NpcmUnLCdcXFxcdTIyNTknOid3ZWRnZXEnLCdcXFxcdTIyNUEnOid2ZWVlcScsJ1xcXFx1MjI1Qyc6J3RyaWUnLCdcXFxcdTIyNUYnOidlcXVlc3QnLCdcXFxcdTIyNjEnOidlcXVpdicsJ1xcXFx1MjI2Mic6J25lcXVpdicsJ1xcXFx1MjI2MVxcXFx1MjBFNSc6J2JuZXF1aXYnLCdcXFxcdTIyNjQnOidsZScsJ1xcXFx1MjI3MCc6J25sZScsJ1xcXFx1MjI2NFxcXFx1MjBEMic6J252bGUnLCdcXFxcdTIyNjUnOidnZScsJ1xcXFx1MjI3MSc6J25nZScsJ1xcXFx1MjI2NVxcXFx1MjBEMic6J252Z2UnLCdcXFxcdTIyNjYnOidsRScsJ1xcXFx1MjI2NlxcXFx1MDMzOCc6J25sRScsJ1xcXFx1MjI2Nyc6J2dFJywnXFxcXHUyMjY3XFxcXHUwMzM4JzonbmdFJywnXFxcXHUyMjY4XFxcXHVGRTAwJzonbHZuRScsJ1xcXFx1MjI2OCc6J2xuRScsJ1xcXFx1MjI2OSc6J2duRScsJ1xcXFx1MjI2OVxcXFx1RkUwMCc6J2d2bkUnLCdcXFxcdTIyNkEnOidsbCcsJ1xcXFx1MjI2QVxcXFx1MDMzOCc6J25MdHYnLCdcXFxcdTIyNkFcXFxcdTIwRDInOiduTHQnLCdcXFxcdTIyNkInOidnZycsJ1xcXFx1MjI2QlxcXFx1MDMzOCc6J25HdHYnLCdcXFxcdTIyNkJcXFxcdTIwRDInOiduR3QnLCdcXFxcdTIyNkMnOid0d2l4dCcsJ1xcXFx1MjI3Mic6J2xzaW0nLCdcXFxcdTIyNzQnOidubHNpbScsJ1xcXFx1MjI3Myc6J2dzaW0nLCdcXFxcdTIyNzUnOiduZ3NpbScsJ1xcXFx1MjI3Nic6J2xnJywnXFxcXHUyMjc4JzonbnRsZycsJ1xcXFx1MjI3Nyc6J2dsJywnXFxcXHUyMjc5JzonbnRnbCcsJ1xcXFx1MjI3QSc6J3ByJywnXFxcXHUyMjgwJzonbnByJywnXFxcXHUyMjdCJzonc2MnLCdcXFxcdTIyODEnOiduc2MnLCdcXFxcdTIyN0MnOidwcmN1ZScsJ1xcXFx1MjJFMCc6J25wcmN1ZScsJ1xcXFx1MjI3RCc6J3NjY3VlJywnXFxcXHUyMkUxJzonbnNjY3VlJywnXFxcXHUyMjdFJzoncHJzaW0nLCdcXFxcdTIyN0YnOidzY3NpbScsJ1xcXFx1MjI3RlxcXFx1MDMzOCc6J05vdFN1Y2NlZWRzVGlsZGUnLCdcXFxcdTIyODInOidzdWInLCdcXFxcdTIyODQnOiduc3ViJywnXFxcXHUyMjgyXFxcXHUyMEQyJzondm5zdWInLCdcXFxcdTIyODMnOidzdXAnLCdcXFxcdTIyODUnOiduc3VwJywnXFxcXHUyMjgzXFxcXHUyMEQyJzondm5zdXAnLCdcXFxcdTIyODYnOidzdWJlJywnXFxcXHUyMjg4JzonbnN1YmUnLCdcXFxcdTIyODcnOidzdXBlJywnXFxcXHUyMjg5JzonbnN1cGUnLCdcXFxcdTIyOEFcXFxcdUZFMDAnOid2c3VibmUnLCdcXFxcdTIyOEEnOidzdWJuZScsJ1xcXFx1MjI4QlxcXFx1RkUwMCc6J3ZzdXBuZScsJ1xcXFx1MjI4Qic6J3N1cG5lJywnXFxcXHUyMjhEJzonY3VwZG90JywnXFxcXHUyMjhFJzondXBsdXMnLCdcXFxcdTIyOEYnOidzcXN1YicsJ1xcXFx1MjI4RlxcXFx1MDMzOCc6J05vdFNxdWFyZVN1YnNldCcsJ1xcXFx1MjI5MCc6J3Nxc3VwJywnXFxcXHUyMjkwXFxcXHUwMzM4JzonTm90U3F1YXJlU3VwZXJzZXQnLCdcXFxcdTIyOTEnOidzcXN1YmUnLCdcXFxcdTIyRTInOiduc3FzdWJlJywnXFxcXHUyMjkyJzonc3FzdXBlJywnXFxcXHUyMkUzJzonbnNxc3VwZScsJ1xcXFx1MjI5Myc6J3NxY2FwJywnXFxcXHUyMjkzXFxcXHVGRTAwJzonc3FjYXBzJywnXFxcXHUyMjk0Jzonc3FjdXAnLCdcXFxcdTIyOTRcXFxcdUZFMDAnOidzcWN1cHMnLCdcXFxcdTIyOTUnOidvcGx1cycsJ1xcXFx1MjI5Nic6J29taW51cycsJ1xcXFx1MjI5Nyc6J290aW1lcycsJ1xcXFx1MjI5OCc6J29zb2wnLCdcXFxcdTIyOTknOidvZG90JywnXFxcXHUyMjlBJzonb2NpcicsJ1xcXFx1MjI5Qic6J29hc3QnLCdcXFxcdTIyOUQnOidvZGFzaCcsJ1xcXFx1MjI5RSc6J3BsdXNiJywnXFxcXHUyMjlGJzonbWludXNiJywnXFxcXHUyMkEwJzondGltZXNiJywnXFxcXHUyMkExJzonc2RvdGInLCdcXFxcdTIyQTInOid2ZGFzaCcsJ1xcXFx1MjJBQyc6J252ZGFzaCcsJ1xcXFx1MjJBMyc6J2Rhc2h2JywnXFxcXHUyMkE0JzondG9wJywnXFxcXHUyMkE1JzonYm90JywnXFxcXHUyMkE3JzonbW9kZWxzJywnXFxcXHUyMkE4JzondkRhc2gnLCdcXFxcdTIyQUQnOidudkRhc2gnLCdcXFxcdTIyQTknOidWZGFzaCcsJ1xcXFx1MjJBRSc6J25WZGFzaCcsJ1xcXFx1MjJBQSc6J1Z2ZGFzaCcsJ1xcXFx1MjJBQic6J1ZEYXNoJywnXFxcXHUyMkFGJzonblZEYXNoJywnXFxcXHUyMkIwJzoncHJ1cmVsJywnXFxcXHUyMkIyJzondmx0cmknLCdcXFxcdTIyRUEnOidubHRyaScsJ1xcXFx1MjJCMyc6J3ZydHJpJywnXFxcXHUyMkVCJzonbnJ0cmknLCdcXFxcdTIyQjQnOidsdHJpZScsJ1xcXFx1MjJFQyc6J25sdHJpZScsJ1xcXFx1MjJCNFxcXFx1MjBEMic6J252bHRyaWUnLCdcXFxcdTIyQjUnOidydHJpZScsJ1xcXFx1MjJFRCc6J25ydHJpZScsJ1xcXFx1MjJCNVxcXFx1MjBEMic6J252cnRyaWUnLCdcXFxcdTIyQjYnOidvcmlnb2YnLCdcXFxcdTIyQjcnOidpbW9mJywnXFxcXHUyMkI4JzonbXVtYXAnLCdcXFxcdTIyQjknOidoZXJjb24nLCdcXFxcdTIyQkEnOidpbnRjYWwnLCdcXFxcdTIyQkInOid2ZWViYXInLCdcXFxcdTIyQkQnOidiYXJ2ZWUnLCdcXFxcdTIyQkUnOidhbmdydHZiJywnXFxcXHUyMkJGJzonbHJ0cmknLCdcXFxcdTIyQzAnOidXZWRnZScsJ1xcXFx1MjJDMSc6J1ZlZScsJ1xcXFx1MjJDMic6J3hjYXAnLCdcXFxcdTIyQzMnOid4Y3VwJywnXFxcXHUyMkM0JzonZGlhbScsJ1xcXFx1MjJDNSc6J3Nkb3QnLCdcXFxcdTIyQzYnOidTdGFyJywnXFxcXHUyMkM3JzonZGl2b254JywnXFxcXHUyMkM4JzonYm93dGllJywnXFxcXHUyMkM5JzonbHRpbWVzJywnXFxcXHUyMkNBJzoncnRpbWVzJywnXFxcXHUyMkNCJzonbHRocmVlJywnXFxcXHUyMkNDJzoncnRocmVlJywnXFxcXHUyMkNEJzonYnNpbWUnLCdcXFxcdTIyQ0UnOidjdXZlZScsJ1xcXFx1MjJDRic6J2N1d2VkJywnXFxcXHUyMkQwJzonU3ViJywnXFxcXHUyMkQxJzonU3VwJywnXFxcXHUyMkQyJzonQ2FwJywnXFxcXHUyMkQzJzonQ3VwJywnXFxcXHUyMkQ0JzonZm9yaycsJ1xcXFx1MjJENSc6J2VwYXInLCdcXFxcdTIyRDYnOidsdGRvdCcsJ1xcXFx1MjJENyc6J2d0ZG90JywnXFxcXHUyMkQ4JzonTGwnLCdcXFxcdTIyRDhcXFxcdTAzMzgnOiduTGwnLCdcXFxcdTIyRDknOidHZycsJ1xcXFx1MjJEOVxcXFx1MDMzOCc6J25HZycsJ1xcXFx1MjJEQVxcXFx1RkUwMCc6J2xlc2cnLCdcXFxcdTIyREEnOidsZWcnLCdcXFxcdTIyREInOidnZWwnLCdcXFxcdTIyREJcXFxcdUZFMDAnOidnZXNsJywnXFxcXHUyMkRFJzonY3VlcHInLCdcXFxcdTIyREYnOidjdWVzYycsJ1xcXFx1MjJFNic6J2xuc2ltJywnXFxcXHUyMkU3JzonZ25zaW0nLCdcXFxcdTIyRTgnOidwcm5zaW0nLCdcXFxcdTIyRTknOidzY25zaW0nLCdcXFxcdTIyRUUnOid2ZWxsaXAnLCdcXFxcdTIyRUYnOidjdGRvdCcsJ1xcXFx1MjJGMCc6J3V0ZG90JywnXFxcXHUyMkYxJzonZHRkb3QnLCdcXFxcdTIyRjInOidkaXNpbicsJ1xcXFx1MjJGMyc6J2lzaW5zdicsJ1xcXFx1MjJGNCc6J2lzaW5zJywnXFxcXHUyMkY1JzonaXNpbmRvdCcsJ1xcXFx1MjJGNVxcXFx1MDMzOCc6J25vdGluZG90JywnXFxcXHUyMkY2Jzonbm90aW52YycsJ1xcXFx1MjJGNyc6J25vdGludmInLCdcXFxcdTIyRjknOidpc2luRScsJ1xcXFx1MjJGOVxcXFx1MDMzOCc6J25vdGluRScsJ1xcXFx1MjJGQSc6J25pc2QnLCdcXFxcdTIyRkInOid4bmlzJywnXFxcXHUyMkZDJzonbmlzJywnXFxcXHUyMkZEJzonbm90bml2YycsJ1xcXFx1MjJGRSc6J25vdG5pdmInLCdcXFxcdTIzMDUnOidiYXJ3ZWQnLCdcXFxcdTIzMDYnOidCYXJ3ZWQnLCdcXFxcdTIzMEMnOidkcmNyb3AnLCdcXFxcdTIzMEQnOidkbGNyb3AnLCdcXFxcdTIzMEUnOid1cmNyb3AnLCdcXFxcdTIzMEYnOid1bGNyb3AnLCdcXFxcdTIzMTAnOidibm90JywnXFxcXHUyMzEyJzoncHJvZmxpbmUnLCdcXFxcdTIzMTMnOidwcm9mc3VyZicsJ1xcXFx1MjMxNSc6J3RlbHJlYycsJ1xcXFx1MjMxNic6J3RhcmdldCcsJ1xcXFx1MjMxQyc6J3VsY29ybicsJ1xcXFx1MjMxRCc6J3VyY29ybicsJ1xcXFx1MjMxRSc6J2RsY29ybicsJ1xcXFx1MjMxRic6J2RyY29ybicsJ1xcXFx1MjMyMic6J2Zyb3duJywnXFxcXHUyMzIzJzonc21pbGUnLCdcXFxcdTIzMkQnOidjeWxjdHknLCdcXFxcdTIzMkUnOidwcm9mYWxhcicsJ1xcXFx1MjMzNic6J3RvcGJvdCcsJ1xcXFx1MjMzRCc6J292YmFyJywnXFxcXHUyMzNGJzonc29sYmFyJywnXFxcXHUyMzdDJzonYW5nemFycicsJ1xcXFx1MjNCMCc6J2xtb3VzdCcsJ1xcXFx1MjNCMSc6J3Jtb3VzdCcsJ1xcXFx1MjNCNCc6J3RicmsnLCdcXFxcdTIzQjUnOidiYnJrJywnXFxcXHUyM0I2JzonYmJya3RicmsnLCdcXFxcdTIzREMnOidPdmVyUGFyZW50aGVzaXMnLCdcXFxcdTIzREQnOidVbmRlclBhcmVudGhlc2lzJywnXFxcXHUyM0RFJzonT3ZlckJyYWNlJywnXFxcXHUyM0RGJzonVW5kZXJCcmFjZScsJ1xcXFx1MjNFMic6J3RycGV6aXVtJywnXFxcXHUyM0U3JzonZWxpbnRlcnMnLCdcXFxcdTI0MjMnOidibGFuaycsJ1xcXFx1MjUwMCc6J2JveGgnLCdcXFxcdTI1MDInOidib3h2JywnXFxcXHUyNTBDJzonYm94ZHInLCdcXFxcdTI1MTAnOidib3hkbCcsJ1xcXFx1MjUxNCc6J2JveHVyJywnXFxcXHUyNTE4JzonYm94dWwnLCdcXFxcdTI1MUMnOidib3h2cicsJ1xcXFx1MjUyNCc6J2JveHZsJywnXFxcXHUyNTJDJzonYm94aGQnLCdcXFxcdTI1MzQnOidib3hodScsJ1xcXFx1MjUzQyc6J2JveHZoJywnXFxcXHUyNTUwJzonYm94SCcsJ1xcXFx1MjU1MSc6J2JveFYnLCdcXFxcdTI1NTInOidib3hkUicsJ1xcXFx1MjU1Myc6J2JveERyJywnXFxcXHUyNTU0JzonYm94RFInLCdcXFxcdTI1NTUnOidib3hkTCcsJ1xcXFx1MjU1Nic6J2JveERsJywnXFxcXHUyNTU3JzonYm94REwnLCdcXFxcdTI1NTgnOidib3h1UicsJ1xcXFx1MjU1OSc6J2JveFVyJywnXFxcXHUyNTVBJzonYm94VVInLCdcXFxcdTI1NUInOidib3h1TCcsJ1xcXFx1MjU1Qyc6J2JveFVsJywnXFxcXHUyNTVEJzonYm94VUwnLCdcXFxcdTI1NUUnOidib3h2UicsJ1xcXFx1MjU1Ric6J2JveFZyJywnXFxcXHUyNTYwJzonYm94VlInLCdcXFxcdTI1NjEnOidib3h2TCcsJ1xcXFx1MjU2Mic6J2JveFZsJywnXFxcXHUyNTYzJzonYm94VkwnLCdcXFxcdTI1NjQnOidib3hIZCcsJ1xcXFx1MjU2NSc6J2JveGhEJywnXFxcXHUyNTY2JzonYm94SEQnLCdcXFxcdTI1NjcnOidib3hIdScsJ1xcXFx1MjU2OCc6J2JveGhVJywnXFxcXHUyNTY5JzonYm94SFUnLCdcXFxcdTI1NkEnOidib3h2SCcsJ1xcXFx1MjU2Qic6J2JveFZoJywnXFxcXHUyNTZDJzonYm94VkgnLCdcXFxcdTI1ODAnOid1aGJsaycsJ1xcXFx1MjU4NCc6J2xoYmxrJywnXFxcXHUyNTg4JzonYmxvY2snLCdcXFxcdTI1OTEnOidibGsxNCcsJ1xcXFx1MjU5Mic6J2JsazEyJywnXFxcXHUyNTkzJzonYmxrMzQnLCdcXFxcdTI1QTEnOidzcXUnLCdcXFxcdTI1QUEnOidzcXVmJywnXFxcXHUyNUFCJzonRW1wdHlWZXJ5U21hbGxTcXVhcmUnLCdcXFxcdTI1QUQnOidyZWN0JywnXFxcXHUyNUFFJzonbWFya2VyJywnXFxcXHUyNUIxJzonZmx0bnMnLCdcXFxcdTI1QjMnOid4dXRyaScsJ1xcXFx1MjVCNCc6J3V0cmlmJywnXFxcXHUyNUI1JzondXRyaScsJ1xcXFx1MjVCOCc6J3J0cmlmJywnXFxcXHUyNUI5JzoncnRyaScsJ1xcXFx1MjVCRCc6J3hkdHJpJywnXFxcXHUyNUJFJzonZHRyaWYnLCdcXFxcdTI1QkYnOidkdHJpJywnXFxcXHUyNUMyJzonbHRyaWYnLCdcXFxcdTI1QzMnOidsdHJpJywnXFxcXHUyNUNBJzonbG96JywnXFxcXHUyNUNCJzonY2lyJywnXFxcXHUyNUVDJzondHJpZG90JywnXFxcXHUyNUVGJzoneGNpcmMnLCdcXFxcdTI1RjgnOid1bHRyaScsJ1xcXFx1MjVGOSc6J3VydHJpJywnXFxcXHUyNUZBJzonbGx0cmknLCdcXFxcdTI1RkInOidFbXB0eVNtYWxsU3F1YXJlJywnXFxcXHUyNUZDJzonRmlsbGVkU21hbGxTcXVhcmUnLCdcXFxcdTI2MDUnOidzdGFyZicsJ1xcXFx1MjYwNic6J3N0YXInLCdcXFxcdTI2MEUnOidwaG9uZScsJ1xcXFx1MjY0MCc6J2ZlbWFsZScsJ1xcXFx1MjY0Mic6J21hbGUnLCdcXFxcdTI2NjAnOidzcGFkZXMnLCdcXFxcdTI2NjMnOidjbHVicycsJ1xcXFx1MjY2NSc6J2hlYXJ0cycsJ1xcXFx1MjY2Nic6J2RpYW1zJywnXFxcXHUyNjZBJzonc3VuZycsJ1xcXFx1MjcxMyc6J2NoZWNrJywnXFxcXHUyNzE3JzonY3Jvc3MnLCdcXFxcdTI3MjAnOidtYWx0JywnXFxcXHUyNzM2Jzonc2V4dCcsJ1xcXFx1Mjc1OCc6J1ZlcnRpY2FsU2VwYXJhdG9yJywnXFxcXHUyN0M4JzonYnNvbGhzdWInLCdcXFxcdTI3QzknOidzdXBoc29sJywnXFxcXHUyN0Y1JzoneGxhcnInLCdcXFxcdTI3RjYnOid4cmFycicsJ1xcXFx1MjdGNyc6J3hoYXJyJywnXFxcXHUyN0Y4JzoneGxBcnInLCdcXFxcdTI3RjknOid4ckFycicsJ1xcXFx1MjdGQSc6J3hoQXJyJywnXFxcXHUyN0ZDJzoneG1hcCcsJ1xcXFx1MjdGRic6J2R6aWdyYXJyJywnXFxcXHUyOTAyJzonbnZsQXJyJywnXFxcXHUyOTAzJzonbnZyQXJyJywnXFxcXHUyOTA0JzonbnZIYXJyJywnXFxcXHUyOTA1JzonTWFwJywnXFxcXHUyOTBDJzonbGJhcnInLCdcXFxcdTI5MEQnOidyYmFycicsJ1xcXFx1MjkwRSc6J2xCYXJyJywnXFxcXHUyOTBGJzonckJhcnInLCdcXFxcdTI5MTAnOidSQmFycicsJ1xcXFx1MjkxMSc6J0REb3RyYWhkJywnXFxcXHUyOTEyJzonVXBBcnJvd0JhcicsJ1xcXFx1MjkxMyc6J0Rvd25BcnJvd0JhcicsJ1xcXFx1MjkxNic6J1JhcnJ0bCcsJ1xcXFx1MjkxOSc6J2xhdGFpbCcsJ1xcXFx1MjkxQSc6J3JhdGFpbCcsJ1xcXFx1MjkxQic6J2xBdGFpbCcsJ1xcXFx1MjkxQyc6J3JBdGFpbCcsJ1xcXFx1MjkxRCc6J2xhcnJmcycsJ1xcXFx1MjkxRSc6J3JhcnJmcycsJ1xcXFx1MjkxRic6J2xhcnJiZnMnLCdcXFxcdTI5MjAnOidyYXJyYmZzJywnXFxcXHUyOTIzJzonbndhcmhrJywnXFxcXHUyOTI0JzonbmVhcmhrJywnXFxcXHUyOTI1Jzonc2VhcmhrJywnXFxcXHUyOTI2Jzonc3dhcmhrJywnXFxcXHUyOTI3JzonbnduZWFyJywnXFxcXHUyOTI4JzondG9lYScsJ1xcXFx1MjkyOSc6J3Rvc2EnLCdcXFxcdTI5MkEnOidzd253YXInLCdcXFxcdTI5MzMnOidyYXJyYycsJ1xcXFx1MjkzM1xcXFx1MDMzOCc6J25yYXJyYycsJ1xcXFx1MjkzNSc6J2N1ZGFycnInLCdcXFxcdTI5MzYnOidsZGNhJywnXFxcXHUyOTM3JzoncmRjYScsJ1xcXFx1MjkzOCc6J2N1ZGFycmwnLCdcXFxcdTI5MzknOidsYXJycGwnLCdcXFxcdTI5M0MnOidjdXJhcnJtJywnXFxcXHUyOTNEJzonY3VsYXJycCcsJ1xcXFx1Mjk0NSc6J3JhcnJwbCcsJ1xcXFx1Mjk0OCc6J2hhcnJjaXInLCdcXFxcdTI5NDknOidVYXJyb2NpcicsJ1xcXFx1Mjk0QSc6J2x1cmRzaGFyJywnXFxcXHUyOTRCJzonbGRydXNoYXInLCdcXFxcdTI5NEUnOidMZWZ0UmlnaHRWZWN0b3InLCdcXFxcdTI5NEYnOidSaWdodFVwRG93blZlY3RvcicsJ1xcXFx1Mjk1MCc6J0Rvd25MZWZ0UmlnaHRWZWN0b3InLCdcXFxcdTI5NTEnOidMZWZ0VXBEb3duVmVjdG9yJywnXFxcXHUyOTUyJzonTGVmdFZlY3RvckJhcicsJ1xcXFx1Mjk1Myc6J1JpZ2h0VmVjdG9yQmFyJywnXFxcXHUyOTU0JzonUmlnaHRVcFZlY3RvckJhcicsJ1xcXFx1Mjk1NSc6J1JpZ2h0RG93blZlY3RvckJhcicsJ1xcXFx1Mjk1Nic6J0Rvd25MZWZ0VmVjdG9yQmFyJywnXFxcXHUyOTU3JzonRG93blJpZ2h0VmVjdG9yQmFyJywnXFxcXHUyOTU4JzonTGVmdFVwVmVjdG9yQmFyJywnXFxcXHUyOTU5JzonTGVmdERvd25WZWN0b3JCYXInLCdcXFxcdTI5NUEnOidMZWZ0VGVlVmVjdG9yJywnXFxcXHUyOTVCJzonUmlnaHRUZWVWZWN0b3InLCdcXFxcdTI5NUMnOidSaWdodFVwVGVlVmVjdG9yJywnXFxcXHUyOTVEJzonUmlnaHREb3duVGVlVmVjdG9yJywnXFxcXHUyOTVFJzonRG93bkxlZnRUZWVWZWN0b3InLCdcXFxcdTI5NUYnOidEb3duUmlnaHRUZWVWZWN0b3InLCdcXFxcdTI5NjAnOidMZWZ0VXBUZWVWZWN0b3InLCdcXFxcdTI5NjEnOidMZWZ0RG93blRlZVZlY3RvcicsJ1xcXFx1Mjk2Mic6J2xIYXInLCdcXFxcdTI5NjMnOid1SGFyJywnXFxcXHUyOTY0JzonckhhcicsJ1xcXFx1Mjk2NSc6J2RIYXInLCdcXFxcdTI5NjYnOidsdXJ1aGFyJywnXFxcXHUyOTY3JzonbGRyZGhhcicsJ1xcXFx1Mjk2OCc6J3J1bHVoYXInLCdcXFxcdTI5NjknOidyZGxkaGFyJywnXFxcXHUyOTZBJzonbGhhcnVsJywnXFxcXHUyOTZCJzonbGxoYXJkJywnXFxcXHUyOTZDJzoncmhhcnVsJywnXFxcXHUyOTZEJzonbHJoYXJkJywnXFxcXHUyOTZFJzondWRoYXInLCdcXFxcdTI5NkYnOidkdWhhcicsJ1xcXFx1Mjk3MCc6J1JvdW5kSW1wbGllcycsJ1xcXFx1Mjk3MSc6J2VyYXJyJywnXFxcXHUyOTcyJzonc2ltcmFycicsJ1xcXFx1Mjk3Myc6J2xhcnJzaW0nLCdcXFxcdTI5NzQnOidyYXJyc2ltJywnXFxcXHUyOTc1JzoncmFycmFwJywnXFxcXHUyOTc2JzonbHRsYXJyJywnXFxcXHUyOTc4JzonZ3RyYXJyJywnXFxcXHUyOTc5Jzonc3VicmFycicsJ1xcXFx1Mjk3Qic6J3N1cGxhcnInLCdcXFxcdTI5N0MnOidsZmlzaHQnLCdcXFxcdTI5N0QnOidyZmlzaHQnLCdcXFxcdTI5N0UnOid1ZmlzaHQnLCdcXFxcdTI5N0YnOidkZmlzaHQnLCdcXFxcdTI5OUEnOid2emlnemFnJywnXFxcXHUyOTlDJzondmFuZ3J0JywnXFxcXHUyOTlEJzonYW5ncnR2YmQnLCdcXFxcdTI5QTQnOidhbmdlJywnXFxcXHUyOUE1JzoncmFuZ2UnLCdcXFxcdTI5QTYnOidkd2FuZ2xlJywnXFxcXHUyOUE3JzondXdhbmdsZScsJ1xcXFx1MjlBOCc6J2FuZ21zZGFhJywnXFxcXHUyOUE5JzonYW5nbXNkYWInLCdcXFxcdTI5QUEnOidhbmdtc2RhYycsJ1xcXFx1MjlBQic6J2FuZ21zZGFkJywnXFxcXHUyOUFDJzonYW5nbXNkYWUnLCdcXFxcdTI5QUQnOidhbmdtc2RhZicsJ1xcXFx1MjlBRSc6J2FuZ21zZGFnJywnXFxcXHUyOUFGJzonYW5nbXNkYWgnLCdcXFxcdTI5QjAnOidiZW1wdHl2JywnXFxcXHUyOUIxJzonZGVtcHR5dicsJ1xcXFx1MjlCMic6J2NlbXB0eXYnLCdcXFxcdTI5QjMnOidyYWVtcHR5dicsJ1xcXFx1MjlCNCc6J2xhZW1wdHl2JywnXFxcXHUyOUI1Jzonb2hiYXInLCdcXFxcdTI5QjYnOidvbWlkJywnXFxcXHUyOUI3Jzonb3BhcicsJ1xcXFx1MjlCOSc6J29wZXJwJywnXFxcXHUyOUJCJzonb2xjcm9zcycsJ1xcXFx1MjlCQyc6J29kc29sZCcsJ1xcXFx1MjlCRSc6J29sY2lyJywnXFxcXHUyOUJGJzonb2ZjaXInLCdcXFxcdTI5QzAnOidvbHQnLCdcXFxcdTI5QzEnOidvZ3QnLCdcXFxcdTI5QzInOidjaXJzY2lyJywnXFxcXHUyOUMzJzonY2lyRScsJ1xcXFx1MjlDNCc6J3NvbGInLCdcXFxcdTI5QzUnOidic29sYicsJ1xcXFx1MjlDOSc6J2JveGJveCcsJ1xcXFx1MjlDRCc6J3RyaXNiJywnXFxcXHUyOUNFJzoncnRyaWx0cmknLCdcXFxcdTI5Q0YnOidMZWZ0VHJpYW5nbGVCYXInLCdcXFxcdTI5Q0ZcXFxcdTAzMzgnOidOb3RMZWZ0VHJpYW5nbGVCYXInLCdcXFxcdTI5RDAnOidSaWdodFRyaWFuZ2xlQmFyJywnXFxcXHUyOUQwXFxcXHUwMzM4JzonTm90UmlnaHRUcmlhbmdsZUJhcicsJ1xcXFx1MjlEQyc6J2lpbmZpbicsJ1xcXFx1MjlERCc6J2luZmludGllJywnXFxcXHUyOURFJzonbnZpbmZpbicsJ1xcXFx1MjlFMyc6J2VwYXJzbCcsJ1xcXFx1MjlFNCc6J3NtZXBhcnNsJywnXFxcXHUyOUU1JzonZXF2cGFyc2wnLCdcXFxcdTI5RUInOidsb3pmJywnXFxcXHUyOUY0JzonUnVsZURlbGF5ZWQnLCdcXFxcdTI5RjYnOidkc29sJywnXFxcXHUyQTAwJzoneG9kb3QnLCdcXFxcdTJBMDEnOid4b3BsdXMnLCdcXFxcdTJBMDInOid4b3RpbWUnLCdcXFxcdTJBMDQnOid4dXBsdXMnLCdcXFxcdTJBMDYnOid4c3FjdXAnLCdcXFxcdTJBMEQnOidmcGFydGludCcsJ1xcXFx1MkExMCc6J2NpcmZuaW50JywnXFxcXHUyQTExJzonYXdpbnQnLCdcXFxcdTJBMTInOidycHBvbGludCcsJ1xcXFx1MkExMyc6J3NjcG9saW50JywnXFxcXHUyQTE0JzonbnBvbGludCcsJ1xcXFx1MkExNSc6J3BvaW50aW50JywnXFxcXHUyQTE2JzoncXVhdGludCcsJ1xcXFx1MkExNyc6J2ludGxhcmhrJywnXFxcXHUyQTIyJzoncGx1c2NpcicsJ1xcXFx1MkEyMyc6J3BsdXNhY2lyJywnXFxcXHUyQTI0Jzonc2ltcGx1cycsJ1xcXFx1MkEyNSc6J3BsdXNkdScsJ1xcXFx1MkEyNic6J3BsdXNzaW0nLCdcXFxcdTJBMjcnOidwbHVzdHdvJywnXFxcXHUyQTI5JzonbWNvbW1hJywnXFxcXHUyQTJBJzonbWludXNkdScsJ1xcXFx1MkEyRCc6J2xvcGx1cycsJ1xcXFx1MkEyRSc6J3JvcGx1cycsJ1xcXFx1MkEyRic6J0Nyb3NzJywnXFxcXHUyQTMwJzondGltZXNkJywnXFxcXHUyQTMxJzondGltZXNiYXInLCdcXFxcdTJBMzMnOidzbWFzaHAnLCdcXFxcdTJBMzQnOidsb3RpbWVzJywnXFxcXHUyQTM1Jzoncm90aW1lcycsJ1xcXFx1MkEzNic6J290aW1lc2FzJywnXFxcXHUyQTM3JzonT3RpbWVzJywnXFxcXHUyQTM4Jzonb2RpdicsJ1xcXFx1MkEzOSc6J3RyaXBsdXMnLCdcXFxcdTJBM0EnOid0cmltaW51cycsJ1xcXFx1MkEzQic6J3RyaXRpbWUnLCdcXFxcdTJBM0MnOidpcHJvZCcsJ1xcXFx1MkEzRic6J2FtYWxnJywnXFxcXHUyQTQwJzonY2FwZG90JywnXFxcXHUyQTQyJzonbmN1cCcsJ1xcXFx1MkE0Myc6J25jYXAnLCdcXFxcdTJBNDQnOidjYXBhbmQnLCdcXFxcdTJBNDUnOidjdXBvcicsJ1xcXFx1MkE0Nic6J2N1cGNhcCcsJ1xcXFx1MkE0Nyc6J2NhcGN1cCcsJ1xcXFx1MkE0OCc6J2N1cGJyY2FwJywnXFxcXHUyQTQ5JzonY2FwYnJjdXAnLCdcXFxcdTJBNEEnOidjdXBjdXAnLCdcXFxcdTJBNEInOidjYXBjYXAnLCdcXFxcdTJBNEMnOidjY3VwcycsJ1xcXFx1MkE0RCc6J2NjYXBzJywnXFxcXHUyQTUwJzonY2N1cHNzbScsJ1xcXFx1MkE1Myc6J0FuZCcsJ1xcXFx1MkE1NCc6J09yJywnXFxcXHUyQTU1JzonYW5kYW5kJywnXFxcXHUyQTU2Jzonb3JvcicsJ1xcXFx1MkE1Nyc6J29yc2xvcGUnLCdcXFxcdTJBNTgnOidhbmRzbG9wZScsJ1xcXFx1MkE1QSc6J2FuZHYnLCdcXFxcdTJBNUInOidvcnYnLCdcXFxcdTJBNUMnOidhbmRkJywnXFxcXHUyQTVEJzonb3JkJywnXFxcXHUyQTVGJzond2VkYmFyJywnXFxcXHUyQTY2Jzonc2RvdGUnLCdcXFxcdTJBNkEnOidzaW1kb3QnLCdcXFxcdTJBNkQnOidjb25nZG90JywnXFxcXHUyQTZEXFxcXHUwMzM4JzonbmNvbmdkb3QnLCdcXFxcdTJBNkUnOidlYXN0ZXInLCdcXFxcdTJBNkYnOidhcGFjaXInLCdcXFxcdTJBNzAnOidhcEUnLCdcXFxcdTJBNzBcXFxcdTAzMzgnOiduYXBFJywnXFxcXHUyQTcxJzonZXBsdXMnLCdcXFxcdTJBNzInOidwbHVzZScsJ1xcXFx1MkE3Myc6J0VzaW0nLCdcXFxcdTJBNzcnOidlRERvdCcsJ1xcXFx1MkE3OCc6J2VxdWl2REQnLCdcXFxcdTJBNzknOidsdGNpcicsJ1xcXFx1MkE3QSc6J2d0Y2lyJywnXFxcXHUyQTdCJzonbHRxdWVzdCcsJ1xcXFx1MkE3Qyc6J2d0cXVlc3QnLCdcXFxcdTJBN0QnOidsZXMnLCdcXFxcdTJBN0RcXFxcdTAzMzgnOidubGVzJywnXFxcXHUyQTdFJzonZ2VzJywnXFxcXHUyQTdFXFxcXHUwMzM4JzonbmdlcycsJ1xcXFx1MkE3Ric6J2xlc2RvdCcsJ1xcXFx1MkE4MCc6J2dlc2RvdCcsJ1xcXFx1MkE4MSc6J2xlc2RvdG8nLCdcXFxcdTJBODInOidnZXNkb3RvJywnXFxcXHUyQTgzJzonbGVzZG90b3InLCdcXFxcdTJBODQnOidnZXNkb3RvbCcsJ1xcXFx1MkE4NSc6J2xhcCcsJ1xcXFx1MkE4Nic6J2dhcCcsJ1xcXFx1MkE4Nyc6J2xuZScsJ1xcXFx1MkE4OCc6J2duZScsJ1xcXFx1MkE4OSc6J2xuYXAnLCdcXFxcdTJBOEEnOidnbmFwJywnXFxcXHUyQThCJzonbEVnJywnXFxcXHUyQThDJzonZ0VsJywnXFxcXHUyQThEJzonbHNpbWUnLCdcXFxcdTJBOEUnOidnc2ltZScsJ1xcXFx1MkE4Ric6J2xzaW1nJywnXFxcXHUyQTkwJzonZ3NpbWwnLCdcXFxcdTJBOTEnOidsZ0UnLCdcXFxcdTJBOTInOidnbEUnLCdcXFxcdTJBOTMnOidsZXNnZXMnLCdcXFxcdTJBOTQnOidnZXNsZXMnLCdcXFxcdTJBOTUnOidlbHMnLCdcXFxcdTJBOTYnOidlZ3MnLCdcXFxcdTJBOTcnOidlbHNkb3QnLCdcXFxcdTJBOTgnOidlZ3Nkb3QnLCdcXFxcdTJBOTknOidlbCcsJ1xcXFx1MkE5QSc6J2VnJywnXFxcXHUyQTlEJzonc2ltbCcsJ1xcXFx1MkE5RSc6J3NpbWcnLCdcXFxcdTJBOUYnOidzaW1sRScsJ1xcXFx1MkFBMCc6J3NpbWdFJywnXFxcXHUyQUExJzonTGVzc0xlc3MnLCdcXFxcdTJBQTFcXFxcdTAzMzgnOidOb3ROZXN0ZWRMZXNzTGVzcycsJ1xcXFx1MkFBMic6J0dyZWF0ZXJHcmVhdGVyJywnXFxcXHUyQUEyXFxcXHUwMzM4JzonTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInLCdcXFxcdTJBQTQnOidnbGonLCdcXFxcdTJBQTUnOidnbGEnLCdcXFxcdTJBQTYnOidsdGNjJywnXFxcXHUyQUE3JzonZ3RjYycsJ1xcXFx1MkFBOCc6J2xlc2NjJywnXFxcXHUyQUE5JzonZ2VzY2MnLCdcXFxcdTJBQUEnOidzbXQnLCdcXFxcdTJBQUInOidsYXQnLCdcXFxcdTJBQUMnOidzbXRlJywnXFxcXHUyQUFDXFxcXHVGRTAwJzonc210ZXMnLCdcXFxcdTJBQUQnOidsYXRlJywnXFxcXHUyQUFEXFxcXHVGRTAwJzonbGF0ZXMnLCdcXFxcdTJBQUUnOididW1wRScsJ1xcXFx1MkFBRic6J3ByZScsJ1xcXFx1MkFBRlxcXFx1MDMzOCc6J25wcmUnLCdcXFxcdTJBQjAnOidzY2UnLCdcXFxcdTJBQjBcXFxcdTAzMzgnOiduc2NlJywnXFxcXHUyQUIzJzoncHJFJywnXFxcXHUyQUI0Jzonc2NFJywnXFxcXHUyQUI1JzoncHJuRScsJ1xcXFx1MkFCNic6J3NjbkUnLCdcXFxcdTJBQjcnOidwcmFwJywnXFxcXHUyQUI4Jzonc2NhcCcsJ1xcXFx1MkFCOSc6J3BybmFwJywnXFxcXHUyQUJBJzonc2NuYXAnLCdcXFxcdTJBQkInOidQcicsJ1xcXFx1MkFCQyc6J1NjJywnXFxcXHUyQUJEJzonc3ViZG90JywnXFxcXHUyQUJFJzonc3VwZG90JywnXFxcXHUyQUJGJzonc3VicGx1cycsJ1xcXFx1MkFDMCc6J3N1cHBsdXMnLCdcXFxcdTJBQzEnOidzdWJtdWx0JywnXFxcXHUyQUMyJzonc3VwbXVsdCcsJ1xcXFx1MkFDMyc6J3N1YmVkb3QnLCdcXFxcdTJBQzQnOidzdXBlZG90JywnXFxcXHUyQUM1Jzonc3ViRScsJ1xcXFx1MkFDNVxcXFx1MDMzOCc6J25zdWJFJywnXFxcXHUyQUM2Jzonc3VwRScsJ1xcXFx1MkFDNlxcXFx1MDMzOCc6J25zdXBFJywnXFxcXHUyQUM3Jzonc3Vic2ltJywnXFxcXHUyQUM4Jzonc3Vwc2ltJywnXFxcXHUyQUNCXFxcXHVGRTAwJzondnN1Ym5FJywnXFxcXHUyQUNCJzonc3VibkUnLCdcXFxcdTJBQ0NcXFxcdUZFMDAnOid2c3VwbkUnLCdcXFxcdTJBQ0MnOidzdXBuRScsJ1xcXFx1MkFDRic6J2NzdWInLCdcXFxcdTJBRDAnOidjc3VwJywnXFxcXHUyQUQxJzonY3N1YmUnLCdcXFxcdTJBRDInOidjc3VwZScsJ1xcXFx1MkFEMyc6J3N1YnN1cCcsJ1xcXFx1MkFENCc6J3N1cHN1YicsJ1xcXFx1MkFENSc6J3N1YnN1YicsJ1xcXFx1MkFENic6J3N1cHN1cCcsJ1xcXFx1MkFENyc6J3N1cGhzdWInLCdcXFxcdTJBRDgnOidzdXBkc3ViJywnXFxcXHUyQUQ5JzonZm9ya3YnLCdcXFxcdTJBREEnOid0b3Bmb3JrJywnXFxcXHUyQURCJzonbWxjcCcsJ1xcXFx1MkFFNCc6J0Rhc2h2JywnXFxcXHUyQUU2JzonVmRhc2hsJywnXFxcXHUyQUU3JzonQmFydicsJ1xcXFx1MkFFOCc6J3ZCYXInLCdcXFxcdTJBRTknOid2QmFydicsJ1xcXFx1MkFFQic6J1ZiYXInLCdcXFxcdTJBRUMnOidOb3QnLCdcXFxcdTJBRUQnOidiTm90JywnXFxcXHUyQUVFJzoncm5taWQnLCdcXFxcdTJBRUYnOidjaXJtaWQnLCdcXFxcdTJBRjAnOidtaWRjaXInLCdcXFxcdTJBRjEnOid0b3BjaXInLCdcXFxcdTJBRjInOiduaHBhcicsJ1xcXFx1MkFGMyc6J3BhcnNpbScsJ1xcXFx1MkFGRCc6J3BhcnNsJywnXFxcXHUyQUZEXFxcXHUyMEU1JzonbnBhcnNsJywnXFxcXHUyNjZEJzonZmxhdCcsJ1xcXFx1MjY2RSc6J25hdHVyJywnXFxcXHUyNjZGJzonc2hhcnAnLCdcXFxceEE0JzonY3VycmVuJywnXFxcXHhBMic6J2NlbnQnLCckJzonZG9sbGFyJywnXFxcXHhBMyc6J3BvdW5kJywnXFxcXHhBNSc6J3llbicsJ1xcXFx1MjBBQyc6J2V1cm8nLCdcXFxceEI5Jzonc3VwMScsJ1xcXFx4QkQnOidoYWxmJywnXFxcXHUyMTUzJzonZnJhYzEzJywnXFxcXHhCQyc6J2ZyYWMxNCcsJ1xcXFx1MjE1NSc6J2ZyYWMxNScsJ1xcXFx1MjE1OSc6J2ZyYWMxNicsJ1xcXFx1MjE1Qic6J2ZyYWMxOCcsJ1xcXFx4QjInOidzdXAyJywnXFxcXHUyMTU0JzonZnJhYzIzJywnXFxcXHUyMTU2JzonZnJhYzI1JywnXFxcXHhCMyc6J3N1cDMnLCdcXFxceEJFJzonZnJhYzM0JywnXFxcXHUyMTU3JzonZnJhYzM1JywnXFxcXHUyMTVDJzonZnJhYzM4JywnXFxcXHUyMTU4JzonZnJhYzQ1JywnXFxcXHUyMTVBJzonZnJhYzU2JywnXFxcXHUyMTVEJzonZnJhYzU4JywnXFxcXHUyMTVFJzonZnJhYzc4JywnXFxcXHVEODM1XFxcXHVEQ0I2JzonYXNjcicsJ1xcXFx1RDgzNVxcXFx1REQ1Mic6J2FvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMUUnOidhZnInLCdcXFxcdUQ4MzVcXFxcdUREMzgnOidBb3BmJywnXFxcXHVEODM1XFxcXHVERDA0JzonQWZyJywnXFxcXHVEODM1XFxcXHVEQzlDJzonQXNjcicsJ1xcXFx4QUEnOidvcmRmJywnXFxcXHhFMSc6J2FhY3V0ZScsJ1xcXFx4QzEnOidBYWN1dGUnLCdcXFxceEUwJzonYWdyYXZlJywnXFxcXHhDMCc6J0FncmF2ZScsJ1xcXFx1MDEwMyc6J2FicmV2ZScsJ1xcXFx1MDEwMic6J0FicmV2ZScsJ1xcXFx4RTInOidhY2lyYycsJ1xcXFx4QzInOidBY2lyYycsJ1xcXFx4RTUnOidhcmluZycsJ1xcXFx4QzUnOidhbmdzdCcsJ1xcXFx4RTQnOidhdW1sJywnXFxcXHhDNCc6J0F1bWwnLCdcXFxceEUzJzonYXRpbGRlJywnXFxcXHhDMyc6J0F0aWxkZScsJ1xcXFx1MDEwNSc6J2FvZ29uJywnXFxcXHUwMTA0JzonQW9nb24nLCdcXFxcdTAxMDEnOidhbWFjcicsJ1xcXFx1MDEwMCc6J0FtYWNyJywnXFxcXHhFNic6J2FlbGlnJywnXFxcXHhDNic6J0FFbGlnJywnXFxcXHVEODM1XFxcXHVEQ0I3JzonYnNjcicsJ1xcXFx1RDgzNVxcXFx1REQ1Myc6J2JvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMUYnOidiZnInLCdcXFxcdUQ4MzVcXFxcdUREMzknOidCb3BmJywnXFxcXHUyMTJDJzonQnNjcicsJ1xcXFx1RDgzNVxcXFx1REQwNSc6J0JmcicsJ1xcXFx1RDgzNVxcXFx1REQyMCc6J2NmcicsJ1xcXFx1RDgzNVxcXFx1RENCOCc6J2NzY3InLCdcXFxcdUQ4MzVcXFxcdURENTQnOidjb3BmJywnXFxcXHUyMTJEJzonQ2ZyJywnXFxcXHVEODM1XFxcXHVEQzlFJzonQ3NjcicsJ1xcXFx1MjEwMic6J0NvcGYnLCdcXFxcdTAxMDcnOidjYWN1dGUnLCdcXFxcdTAxMDYnOidDYWN1dGUnLCdcXFxcdTAxMDknOidjY2lyYycsJ1xcXFx1MDEwOCc6J0NjaXJjJywnXFxcXHUwMTBEJzonY2Nhcm9uJywnXFxcXHUwMTBDJzonQ2Nhcm9uJywnXFxcXHUwMTBCJzonY2RvdCcsJ1xcXFx1MDEwQSc6J0Nkb3QnLCdcXFxceEU3JzonY2NlZGlsJywnXFxcXHhDNyc6J0NjZWRpbCcsJ1xcXFx1MjEwNSc6J2luY2FyZScsJ1xcXFx1RDgzNVxcXFx1REQyMSc6J2RmcicsJ1xcXFx1MjE0Nic6J2RkJywnXFxcXHVEODM1XFxcXHVERDU1JzonZG9wZicsJ1xcXFx1RDgzNVxcXFx1RENCOSc6J2RzY3InLCdcXFxcdUQ4MzVcXFxcdURDOUYnOidEc2NyJywnXFxcXHVEODM1XFxcXHVERDA3JzonRGZyJywnXFxcXHUyMTQ1JzonREQnLCdcXFxcdUQ4MzVcXFxcdUREM0InOidEb3BmJywnXFxcXHUwMTBGJzonZGNhcm9uJywnXFxcXHUwMTBFJzonRGNhcm9uJywnXFxcXHUwMTExJzonZHN0cm9rJywnXFxcXHUwMTEwJzonRHN0cm9rJywnXFxcXHhGMCc6J2V0aCcsJ1xcXFx4RDAnOidFVEgnLCdcXFxcdTIxNDcnOidlZScsJ1xcXFx1MjEyRic6J2VzY3InLCdcXFxcdUQ4MzVcXFxcdUREMjInOidlZnInLCdcXFxcdUQ4MzVcXFxcdURENTYnOidlb3BmJywnXFxcXHUyMTMwJzonRXNjcicsJ1xcXFx1RDgzNVxcXFx1REQwOCc6J0VmcicsJ1xcXFx1RDgzNVxcXFx1REQzQyc6J0VvcGYnLCdcXFxceEU5JzonZWFjdXRlJywnXFxcXHhDOSc6J0VhY3V0ZScsJ1xcXFx4RTgnOidlZ3JhdmUnLCdcXFxceEM4JzonRWdyYXZlJywnXFxcXHhFQSc6J2VjaXJjJywnXFxcXHhDQSc6J0VjaXJjJywnXFxcXHUwMTFCJzonZWNhcm9uJywnXFxcXHUwMTFBJzonRWNhcm9uJywnXFxcXHhFQic6J2V1bWwnLCdcXFxceENCJzonRXVtbCcsJ1xcXFx1MDExNyc6J2Vkb3QnLCdcXFxcdTAxMTYnOidFZG90JywnXFxcXHUwMTE5JzonZW9nb24nLCdcXFxcdTAxMTgnOidFb2dvbicsJ1xcXFx1MDExMyc6J2VtYWNyJywnXFxcXHUwMTEyJzonRW1hY3InLCdcXFxcdUQ4MzVcXFxcdUREMjMnOidmZnInLCdcXFxcdUQ4MzVcXFxcdURENTcnOidmb3BmJywnXFxcXHVEODM1XFxcXHVEQ0JCJzonZnNjcicsJ1xcXFx1RDgzNVxcXFx1REQwOSc6J0ZmcicsJ1xcXFx1RDgzNVxcXFx1REQzRCc6J0ZvcGYnLCdcXFxcdTIxMzEnOidGc2NyJywnXFxcXHVGQjAwJzonZmZsaWcnLCdcXFxcdUZCMDMnOidmZmlsaWcnLCdcXFxcdUZCMDQnOidmZmxsaWcnLCdcXFxcdUZCMDEnOidmaWxpZycsJ2ZqJzonZmpsaWcnLCdcXFxcdUZCMDInOidmbGxpZycsJ1xcXFx1MDE5Mic6J2Zub2YnLCdcXFxcdTIxMEEnOidnc2NyJywnXFxcXHVEODM1XFxcXHVERDU4JzonZ29wZicsJ1xcXFx1RDgzNVxcXFx1REQyNCc6J2dmcicsJ1xcXFx1RDgzNVxcXFx1RENBMic6J0dzY3InLCdcXFxcdUQ4MzVcXFxcdUREM0UnOidHb3BmJywnXFxcXHVEODM1XFxcXHVERDBBJzonR2ZyJywnXFxcXHUwMUY1JzonZ2FjdXRlJywnXFxcXHUwMTFGJzonZ2JyZXZlJywnXFxcXHUwMTFFJzonR2JyZXZlJywnXFxcXHUwMTFEJzonZ2NpcmMnLCdcXFxcdTAxMUMnOidHY2lyYycsJ1xcXFx1MDEyMSc6J2dkb3QnLCdcXFxcdTAxMjAnOidHZG90JywnXFxcXHUwMTIyJzonR2NlZGlsJywnXFxcXHVEODM1XFxcXHVERDI1JzonaGZyJywnXFxcXHUyMTBFJzoncGxhbmNraCcsJ1xcXFx1RDgzNVxcXFx1RENCRCc6J2hzY3InLCdcXFxcdUQ4MzVcXFxcdURENTknOidob3BmJywnXFxcXHUyMTBCJzonSHNjcicsJ1xcXFx1MjEwQyc6J0hmcicsJ1xcXFx1MjEwRCc6J0hvcGYnLCdcXFxcdTAxMjUnOidoY2lyYycsJ1xcXFx1MDEyNCc6J0hjaXJjJywnXFxcXHUyMTBGJzonaGJhcicsJ1xcXFx1MDEyNyc6J2hzdHJvaycsJ1xcXFx1MDEyNic6J0hzdHJvaycsJ1xcXFx1RDgzNVxcXFx1REQ1QSc6J2lvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMjYnOidpZnInLCdcXFxcdUQ4MzVcXFxcdURDQkUnOidpc2NyJywnXFxcXHUyMTQ4JzonaWknLCdcXFxcdUQ4MzVcXFxcdURENDAnOidJb3BmJywnXFxcXHUyMTEwJzonSXNjcicsJ1xcXFx1MjExMSc6J0ltJywnXFxcXHhFRCc6J2lhY3V0ZScsJ1xcXFx4Q0QnOidJYWN1dGUnLCdcXFxceEVDJzonaWdyYXZlJywnXFxcXHhDQyc6J0lncmF2ZScsJ1xcXFx4RUUnOidpY2lyYycsJ1xcXFx4Q0UnOidJY2lyYycsJ1xcXFx4RUYnOidpdW1sJywnXFxcXHhDRic6J0l1bWwnLCdcXFxcdTAxMjknOidpdGlsZGUnLCdcXFxcdTAxMjgnOidJdGlsZGUnLCdcXFxcdTAxMzAnOidJZG90JywnXFxcXHUwMTJGJzonaW9nb24nLCdcXFxcdTAxMkUnOidJb2dvbicsJ1xcXFx1MDEyQic6J2ltYWNyJywnXFxcXHUwMTJBJzonSW1hY3InLCdcXFxcdTAxMzMnOidpamxpZycsJ1xcXFx1MDEzMic6J0lKbGlnJywnXFxcXHUwMTMxJzonaW1hdGgnLCdcXFxcdUQ4MzVcXFxcdURDQkYnOidqc2NyJywnXFxcXHVEODM1XFxcXHVERDVCJzonam9wZicsJ1xcXFx1RDgzNVxcXFx1REQyNyc6J2pmcicsJ1xcXFx1RDgzNVxcXFx1RENBNSc6J0pzY3InLCdcXFxcdUQ4MzVcXFxcdUREMEQnOidKZnInLCdcXFxcdUQ4MzVcXFxcdURENDEnOidKb3BmJywnXFxcXHUwMTM1JzonamNpcmMnLCdcXFxcdTAxMzQnOidKY2lyYycsJ1xcXFx1MDIzNyc6J2ptYXRoJywnXFxcXHVEODM1XFxcXHVERDVDJzona29wZicsJ1xcXFx1RDgzNVxcXFx1RENDMCc6J2tzY3InLCdcXFxcdUQ4MzVcXFxcdUREMjgnOidrZnInLCdcXFxcdUQ4MzVcXFxcdURDQTYnOidLc2NyJywnXFxcXHVEODM1XFxcXHVERDQyJzonS29wZicsJ1xcXFx1RDgzNVxcXFx1REQwRSc6J0tmcicsJ1xcXFx1MDEzNyc6J2tjZWRpbCcsJ1xcXFx1MDEzNic6J0tjZWRpbCcsJ1xcXFx1RDgzNVxcXFx1REQyOSc6J2xmcicsJ1xcXFx1RDgzNVxcXFx1RENDMSc6J2xzY3InLCdcXFxcdTIxMTMnOidlbGwnLCdcXFxcdUQ4MzVcXFxcdURENUQnOidsb3BmJywnXFxcXHUyMTEyJzonTHNjcicsJ1xcXFx1RDgzNVxcXFx1REQwRic6J0xmcicsJ1xcXFx1RDgzNVxcXFx1REQ0Myc6J0xvcGYnLCdcXFxcdTAxM0EnOidsYWN1dGUnLCdcXFxcdTAxMzknOidMYWN1dGUnLCdcXFxcdTAxM0UnOidsY2Fyb24nLCdcXFxcdTAxM0QnOidMY2Fyb24nLCdcXFxcdTAxM0MnOidsY2VkaWwnLCdcXFxcdTAxM0InOidMY2VkaWwnLCdcXFxcdTAxNDInOidsc3Ryb2snLCdcXFxcdTAxNDEnOidMc3Ryb2snLCdcXFxcdTAxNDAnOidsbWlkb3QnLCdcXFxcdTAxM0YnOidMbWlkb3QnLCdcXFxcdUQ4MzVcXFxcdUREMkEnOidtZnInLCdcXFxcdUQ4MzVcXFxcdURENUUnOidtb3BmJywnXFxcXHVEODM1XFxcXHVEQ0MyJzonbXNjcicsJ1xcXFx1RDgzNVxcXFx1REQxMCc6J01mcicsJ1xcXFx1RDgzNVxcXFx1REQ0NCc6J01vcGYnLCdcXFxcdTIxMzMnOidNc2NyJywnXFxcXHVEODM1XFxcXHVERDJCJzonbmZyJywnXFxcXHVEODM1XFxcXHVERDVGJzonbm9wZicsJ1xcXFx1RDgzNVxcXFx1RENDMyc6J25zY3InLCdcXFxcdTIxMTUnOidOb3BmJywnXFxcXHVEODM1XFxcXHVEQ0E5JzonTnNjcicsJ1xcXFx1RDgzNVxcXFx1REQxMSc6J05mcicsJ1xcXFx1MDE0NCc6J25hY3V0ZScsJ1xcXFx1MDE0Myc6J05hY3V0ZScsJ1xcXFx1MDE0OCc6J25jYXJvbicsJ1xcXFx1MDE0Nyc6J05jYXJvbicsJ1xcXFx4RjEnOidudGlsZGUnLCdcXFxceEQxJzonTnRpbGRlJywnXFxcXHUwMTQ2JzonbmNlZGlsJywnXFxcXHUwMTQ1JzonTmNlZGlsJywnXFxcXHUyMTE2JzonbnVtZXJvJywnXFxcXHUwMTRCJzonZW5nJywnXFxcXHUwMTRBJzonRU5HJywnXFxcXHVEODM1XFxcXHVERDYwJzonb29wZicsJ1xcXFx1RDgzNVxcXFx1REQyQyc6J29mcicsJ1xcXFx1MjEzNCc6J29zY3InLCdcXFxcdUQ4MzVcXFxcdURDQUEnOidPc2NyJywnXFxcXHVEODM1XFxcXHVERDEyJzonT2ZyJywnXFxcXHVEODM1XFxcXHVERDQ2JzonT29wZicsJ1xcXFx4QkEnOidvcmRtJywnXFxcXHhGMyc6J29hY3V0ZScsJ1xcXFx4RDMnOidPYWN1dGUnLCdcXFxceEYyJzonb2dyYXZlJywnXFxcXHhEMic6J09ncmF2ZScsJ1xcXFx4RjQnOidvY2lyYycsJ1xcXFx4RDQnOidPY2lyYycsJ1xcXFx4RjYnOidvdW1sJywnXFxcXHhENic6J091bWwnLCdcXFxcdTAxNTEnOidvZGJsYWMnLCdcXFxcdTAxNTAnOidPZGJsYWMnLCdcXFxceEY1Jzonb3RpbGRlJywnXFxcXHhENSc6J090aWxkZScsJ1xcXFx4RjgnOidvc2xhc2gnLCdcXFxceEQ4JzonT3NsYXNoJywnXFxcXHUwMTREJzonb21hY3InLCdcXFxcdTAxNEMnOidPbWFjcicsJ1xcXFx1MDE1Myc6J29lbGlnJywnXFxcXHUwMTUyJzonT0VsaWcnLCdcXFxcdUQ4MzVcXFxcdUREMkQnOidwZnInLCdcXFxcdUQ4MzVcXFxcdURDQzUnOidwc2NyJywnXFxcXHVEODM1XFxcXHVERDYxJzoncG9wZicsJ1xcXFx1MjExOSc6J1BvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMTMnOidQZnInLCdcXFxcdUQ4MzVcXFxcdURDQUInOidQc2NyJywnXFxcXHVEODM1XFxcXHVERDYyJzoncW9wZicsJ1xcXFx1RDgzNVxcXFx1REQyRSc6J3FmcicsJ1xcXFx1RDgzNVxcXFx1RENDNic6J3FzY3InLCdcXFxcdUQ4MzVcXFxcdURDQUMnOidRc2NyJywnXFxcXHVEODM1XFxcXHVERDE0JzonUWZyJywnXFxcXHUyMTFBJzonUW9wZicsJ1xcXFx1MDEzOCc6J2tncmVlbicsJ1xcXFx1RDgzNVxcXFx1REQyRic6J3JmcicsJ1xcXFx1RDgzNVxcXFx1REQ2Myc6J3JvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQzcnOidyc2NyJywnXFxcXHUyMTFCJzonUnNjcicsJ1xcXFx1MjExQyc6J1JlJywnXFxcXHUyMTFEJzonUm9wZicsJ1xcXFx1MDE1NSc6J3JhY3V0ZScsJ1xcXFx1MDE1NCc6J1JhY3V0ZScsJ1xcXFx1MDE1OSc6J3JjYXJvbicsJ1xcXFx1MDE1OCc6J1JjYXJvbicsJ1xcXFx1MDE1Nyc6J3JjZWRpbCcsJ1xcXFx1MDE1Nic6J1JjZWRpbCcsJ1xcXFx1RDgzNVxcXFx1REQ2NCc6J3NvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQzgnOidzc2NyJywnXFxcXHVEODM1XFxcXHVERDMwJzonc2ZyJywnXFxcXHVEODM1XFxcXHVERDRBJzonU29wZicsJ1xcXFx1RDgzNVxcXFx1REQxNic6J1NmcicsJ1xcXFx1RDgzNVxcXFx1RENBRSc6J1NzY3InLCdcXFxcdTI0QzgnOidvUycsJ1xcXFx1MDE1Qic6J3NhY3V0ZScsJ1xcXFx1MDE1QSc6J1NhY3V0ZScsJ1xcXFx1MDE1RCc6J3NjaXJjJywnXFxcXHUwMTVDJzonU2NpcmMnLCdcXFxcdTAxNjEnOidzY2Fyb24nLCdcXFxcdTAxNjAnOidTY2Fyb24nLCdcXFxcdTAxNUYnOidzY2VkaWwnLCdcXFxcdTAxNUUnOidTY2VkaWwnLCdcXFxceERGJzonc3psaWcnLCdcXFxcdUQ4MzVcXFxcdUREMzEnOid0ZnInLCdcXFxcdUQ4MzVcXFxcdURDQzknOid0c2NyJywnXFxcXHVEODM1XFxcXHVERDY1JzondG9wZicsJ1xcXFx1RDgzNVxcXFx1RENBRic6J1RzY3InLCdcXFxcdUQ4MzVcXFxcdUREMTcnOidUZnInLCdcXFxcdUQ4MzVcXFxcdURENEInOidUb3BmJywnXFxcXHUwMTY1JzondGNhcm9uJywnXFxcXHUwMTY0JzonVGNhcm9uJywnXFxcXHUwMTYzJzondGNlZGlsJywnXFxcXHUwMTYyJzonVGNlZGlsJywnXFxcXHUyMTIyJzondHJhZGUnLCdcXFxcdTAxNjcnOid0c3Ryb2snLCdcXFxcdTAxNjYnOidUc3Ryb2snLCdcXFxcdUQ4MzVcXFxcdURDQ0EnOid1c2NyJywnXFxcXHVEODM1XFxcXHVERDY2JzondW9wZicsJ1xcXFx1RDgzNVxcXFx1REQzMic6J3VmcicsJ1xcXFx1RDgzNVxcXFx1REQ0Qyc6J1VvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMTgnOidVZnInLCdcXFxcdUQ4MzVcXFxcdURDQjAnOidVc2NyJywnXFxcXHhGQSc6J3VhY3V0ZScsJ1xcXFx4REEnOidVYWN1dGUnLCdcXFxceEY5JzondWdyYXZlJywnXFxcXHhEOSc6J1VncmF2ZScsJ1xcXFx1MDE2RCc6J3VicmV2ZScsJ1xcXFx1MDE2Qyc6J1VicmV2ZScsJ1xcXFx4RkInOid1Y2lyYycsJ1xcXFx4REInOidVY2lyYycsJ1xcXFx1MDE2Ric6J3VyaW5nJywnXFxcXHUwMTZFJzonVXJpbmcnLCdcXFxceEZDJzondXVtbCcsJ1xcXFx4REMnOidVdW1sJywnXFxcXHUwMTcxJzondWRibGFjJywnXFxcXHUwMTcwJzonVWRibGFjJywnXFxcXHUwMTY5JzondXRpbGRlJywnXFxcXHUwMTY4JzonVXRpbGRlJywnXFxcXHUwMTczJzondW9nb24nLCdcXFxcdTAxNzInOidVb2dvbicsJ1xcXFx1MDE2Qic6J3VtYWNyJywnXFxcXHUwMTZBJzonVW1hY3InLCdcXFxcdUQ4MzVcXFxcdUREMzMnOid2ZnInLCdcXFxcdUQ4MzVcXFxcdURENjcnOid2b3BmJywnXFxcXHVEODM1XFxcXHVEQ0NCJzondnNjcicsJ1xcXFx1RDgzNVxcXFx1REQxOSc6J1ZmcicsJ1xcXFx1RDgzNVxcXFx1REQ0RCc6J1ZvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQjEnOidWc2NyJywnXFxcXHVEODM1XFxcXHVERDY4Jzond29wZicsJ1xcXFx1RDgzNVxcXFx1RENDQyc6J3dzY3InLCdcXFxcdUQ4MzVcXFxcdUREMzQnOid3ZnInLCdcXFxcdUQ4MzVcXFxcdURDQjInOidXc2NyJywnXFxcXHVEODM1XFxcXHVERDRFJzonV29wZicsJ1xcXFx1RDgzNVxcXFx1REQxQSc6J1dmcicsJ1xcXFx1MDE3NSc6J3djaXJjJywnXFxcXHUwMTc0JzonV2NpcmMnLCdcXFxcdUQ4MzVcXFxcdUREMzUnOid4ZnInLCdcXFxcdUQ4MzVcXFxcdURDQ0QnOid4c2NyJywnXFxcXHVEODM1XFxcXHVERDY5JzoneG9wZicsJ1xcXFx1RDgzNVxcXFx1REQ0Ric6J1hvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMUInOidYZnInLCdcXFxcdUQ4MzVcXFxcdURDQjMnOidYc2NyJywnXFxcXHVEODM1XFxcXHVERDM2JzoneWZyJywnXFxcXHVEODM1XFxcXHVEQ0NFJzoneXNjcicsJ1xcXFx1RDgzNVxcXFx1REQ2QSc6J3lvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQjQnOidZc2NyJywnXFxcXHVEODM1XFxcXHVERDFDJzonWWZyJywnXFxcXHVEODM1XFxcXHVERDUwJzonWW9wZicsJ1xcXFx4RkQnOid5YWN1dGUnLCdcXFxceEREJzonWWFjdXRlJywnXFxcXHUwMTc3JzoneWNpcmMnLCdcXFxcdTAxNzYnOidZY2lyYycsJ1xcXFx4RkYnOid5dW1sJywnXFxcXHUwMTc4JzonWXVtbCcsJ1xcXFx1RDgzNVxcXFx1RENDRic6J3pzY3InLCdcXFxcdUQ4MzVcXFxcdUREMzcnOid6ZnInLCdcXFxcdUQ4MzVcXFxcdURENkInOid6b3BmJywnXFxcXHUyMTI4JzonWmZyJywnXFxcXHUyMTI0JzonWm9wZicsJ1xcXFx1RDgzNVxcXFx1RENCNSc6J1pzY3InLCdcXFxcdTAxN0EnOid6YWN1dGUnLCdcXFxcdTAxNzknOidaYWN1dGUnLCdcXFxcdTAxN0UnOid6Y2Fyb24nLCdcXFxcdTAxN0QnOidaY2Fyb24nLCdcXFxcdTAxN0MnOid6ZG90JywnXFxcXHUwMTdCJzonWmRvdCcsJ1xcXFx1MDFCNSc6J2ltcGVkJywnXFxcXHhGRSc6J3Rob3JuJywnXFxcXHhERSc6J1RIT1JOJywnXFxcXHUwMTQ5JzonbmFwb3MnLCdcXFxcdTAzQjEnOidhbHBoYScsJ1xcXFx1MDM5MSc6J0FscGhhJywnXFxcXHUwM0IyJzonYmV0YScsJ1xcXFx1MDM5Mic6J0JldGEnLCdcXFxcdTAzQjMnOidnYW1tYScsJ1xcXFx1MDM5Myc6J0dhbW1hJywnXFxcXHUwM0I0JzonZGVsdGEnLCdcXFxcdTAzOTQnOidEZWx0YScsJ1xcXFx1MDNCNSc6J2Vwc2knLCdcXFxcdTAzRjUnOidlcHNpdicsJ1xcXFx1MDM5NSc6J0Vwc2lsb24nLCdcXFxcdTAzREQnOidnYW1tYWQnLCdcXFxcdTAzREMnOidHYW1tYWQnLCdcXFxcdTAzQjYnOid6ZXRhJywnXFxcXHUwMzk2JzonWmV0YScsJ1xcXFx1MDNCNyc6J2V0YScsJ1xcXFx1MDM5Nyc6J0V0YScsJ1xcXFx1MDNCOCc6J3RoZXRhJywnXFxcXHUwM0QxJzondGhldGF2JywnXFxcXHUwMzk4JzonVGhldGEnLCdcXFxcdTAzQjknOidpb3RhJywnXFxcXHUwMzk5JzonSW90YScsJ1xcXFx1MDNCQSc6J2thcHBhJywnXFxcXHUwM0YwJzona2FwcGF2JywnXFxcXHUwMzlBJzonS2FwcGEnLCdcXFxcdTAzQkInOidsYW1iZGEnLCdcXFxcdTAzOUInOidMYW1iZGEnLCdcXFxcdTAzQkMnOidtdScsJ1xcXFx4QjUnOidtaWNybycsJ1xcXFx1MDM5Qyc6J011JywnXFxcXHUwM0JEJzonbnUnLCdcXFxcdTAzOUQnOidOdScsJ1xcXFx1MDNCRSc6J3hpJywnXFxcXHUwMzlFJzonWGknLCdcXFxcdTAzQkYnOidvbWljcm9uJywnXFxcXHUwMzlGJzonT21pY3JvbicsJ1xcXFx1MDNDMCc6J3BpJywnXFxcXHUwM0Q2JzoncGl2JywnXFxcXHUwM0EwJzonUGknLCdcXFxcdTAzQzEnOidyaG8nLCdcXFxcdTAzRjEnOidyaG92JywnXFxcXHUwM0ExJzonUmhvJywnXFxcXHUwM0MzJzonc2lnbWEnLCdcXFxcdTAzQTMnOidTaWdtYScsJ1xcXFx1MDNDMic6J3NpZ21hZicsJ1xcXFx1MDNDNCc6J3RhdScsJ1xcXFx1MDNBNCc6J1RhdScsJ1xcXFx1MDNDNSc6J3Vwc2knLCdcXFxcdTAzQTUnOidVcHNpbG9uJywnXFxcXHUwM0QyJzonVXBzaScsJ1xcXFx1MDNDNic6J3BoaScsJ1xcXFx1MDNENSc6J3BoaXYnLCdcXFxcdTAzQTYnOidQaGknLCdcXFxcdTAzQzcnOidjaGknLCdcXFxcdTAzQTcnOidDaGknLCdcXFxcdTAzQzgnOidwc2knLCdcXFxcdTAzQTgnOidQc2knLCdcXFxcdTAzQzknOidvbWVnYScsJ1xcXFx1MDNBOSc6J29obScsJ1xcXFx1MDQzMCc6J2FjeScsJ1xcXFx1MDQxMCc6J0FjeScsJ1xcXFx1MDQzMSc6J2JjeScsJ1xcXFx1MDQxMSc6J0JjeScsJ1xcXFx1MDQzMic6J3ZjeScsJ1xcXFx1MDQxMic6J1ZjeScsJ1xcXFx1MDQzMyc6J2djeScsJ1xcXFx1MDQxMyc6J0djeScsJ1xcXFx1MDQ1Myc6J2dqY3knLCdcXFxcdTA0MDMnOidHSmN5JywnXFxcXHUwNDM0JzonZGN5JywnXFxcXHUwNDE0JzonRGN5JywnXFxcXHUwNDUyJzonZGpjeScsJ1xcXFx1MDQwMic6J0RKY3knLCdcXFxcdTA0MzUnOidpZWN5JywnXFxcXHUwNDE1JzonSUVjeScsJ1xcXFx1MDQ1MSc6J2lvY3knLCdcXFxcdTA0MDEnOidJT2N5JywnXFxcXHUwNDU0JzonanVrY3knLCdcXFxcdTA0MDQnOidKdWtjeScsJ1xcXFx1MDQzNic6J3poY3knLCdcXFxcdTA0MTYnOidaSGN5JywnXFxcXHUwNDM3JzonemN5JywnXFxcXHUwNDE3JzonWmN5JywnXFxcXHUwNDU1JzonZHNjeScsJ1xcXFx1MDQwNSc6J0RTY3knLCdcXFxcdTA0MzgnOidpY3knLCdcXFxcdTA0MTgnOidJY3knLCdcXFxcdTA0NTYnOidpdWtjeScsJ1xcXFx1MDQwNic6J0l1a2N5JywnXFxcXHUwNDU3JzoneWljeScsJ1xcXFx1MDQwNyc6J1lJY3knLCdcXFxcdTA0MzknOidqY3knLCdcXFxcdTA0MTknOidKY3knLCdcXFxcdTA0NTgnOidqc2VyY3knLCdcXFxcdTA0MDgnOidKc2VyY3knLCdcXFxcdTA0M0EnOidrY3knLCdcXFxcdTA0MUEnOidLY3knLCdcXFxcdTA0NUMnOidramN5JywnXFxcXHUwNDBDJzonS0pjeScsJ1xcXFx1MDQzQic6J2xjeScsJ1xcXFx1MDQxQic6J0xjeScsJ1xcXFx1MDQ1OSc6J2xqY3knLCdcXFxcdTA0MDknOidMSmN5JywnXFxcXHUwNDNDJzonbWN5JywnXFxcXHUwNDFDJzonTWN5JywnXFxcXHUwNDNEJzonbmN5JywnXFxcXHUwNDFEJzonTmN5JywnXFxcXHUwNDVBJzonbmpjeScsJ1xcXFx1MDQwQSc6J05KY3knLCdcXFxcdTA0M0UnOidvY3knLCdcXFxcdTA0MUUnOidPY3knLCdcXFxcdTA0M0YnOidwY3knLCdcXFxcdTA0MUYnOidQY3knLCdcXFxcdTA0NDAnOidyY3knLCdcXFxcdTA0MjAnOidSY3knLCdcXFxcdTA0NDEnOidzY3knLCdcXFxcdTA0MjEnOidTY3knLCdcXFxcdTA0NDInOid0Y3knLCdcXFxcdTA0MjInOidUY3knLCdcXFxcdTA0NUInOid0c2hjeScsJ1xcXFx1MDQwQic6J1RTSGN5JywnXFxcXHUwNDQzJzondWN5JywnXFxcXHUwNDIzJzonVWN5JywnXFxcXHUwNDVFJzondWJyY3knLCdcXFxcdTA0MEUnOidVYnJjeScsJ1xcXFx1MDQ0NCc6J2ZjeScsJ1xcXFx1MDQyNCc6J0ZjeScsJ1xcXFx1MDQ0NSc6J2toY3knLCdcXFxcdTA0MjUnOidLSGN5JywnXFxcXHUwNDQ2JzondHNjeScsJ1xcXFx1MDQyNic6J1RTY3knLCdcXFxcdTA0NDcnOidjaGN5JywnXFxcXHUwNDI3JzonQ0hjeScsJ1xcXFx1MDQ1Ric6J2R6Y3knLCdcXFxcdTA0MEYnOidEWmN5JywnXFxcXHUwNDQ4Jzonc2hjeScsJ1xcXFx1MDQyOCc6J1NIY3knLCdcXFxcdTA0NDknOidzaGNoY3knLCdcXFxcdTA0MjknOidTSENIY3knLCdcXFxcdTA0NEEnOidoYXJkY3knLCdcXFxcdTA0MkEnOidIQVJEY3knLCdcXFxcdTA0NEInOid5Y3knLCdcXFxcdTA0MkInOidZY3knLCdcXFxcdTA0NEMnOidzb2Z0Y3knLCdcXFxcdTA0MkMnOidTT0ZUY3knLCdcXFxcdTA0NEQnOidlY3knLCdcXFxcdTA0MkQnOidFY3knLCdcXFxcdTA0NEUnOid5dWN5JywnXFxcXHUwNDJFJzonWVVjeScsJ1xcXFx1MDQ0Ric6J3lhY3knLCdcXFxcdTA0MkYnOidZQWN5JywnXFxcXHUyMTM1JzonYWxlcGgnLCdcXFxcdTIxMzYnOidiZXRoJywnXFxcXHUyMTM3JzonZ2ltZWwnLCdcXFxcdTIxMzgnOidkYWxldGgnfTtcXG5cXG5cXHR2YXIgcmVnZXhFc2NhcGUgPSAvW1xcXCImJzw+YF0vZztcXG5cXHR2YXIgZXNjYXBlTWFwID0ge1xcblxcdFxcdCdcXFwiJzogJyZxdW90OycsXFxuXFx0XFx0JyYnOiAnJmFtcDsnLFxcblxcdFxcdCdcXFxcJyc6ICcmI3gyNzsnLFxcblxcdFxcdCc8JzogJyZsdDsnLFxcblxcdFxcdC8vIFNlZSBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHM6IGluIEhUTUwsIHRoZVxcblxcdFxcdC8vIGZvbGxvd2luZyBpcyBub3Qgc3RyaWN0bHkgbmVjZXNzYXJ5IHVubGVzcyBpdOKAmXMgcGFydCBvZiBhIHRhZyBvciBhblxcblxcdFxcdC8vIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gV2XigJlyZSBvbmx5IGVzY2FwaW5nIGl0IHRvIHN1cHBvcnQgdGhvc2VcXG5cXHRcXHQvLyBzaXR1YXRpb25zLCBhbmQgZm9yIFhNTCBzdXBwb3J0LlxcblxcdFxcdCc+JzogJyZndDsnLFxcblxcdFxcdC8vIEluIEludGVybmV0IEV4cGxvcmVyIOKJpCA4LCB0aGUgYmFja3RpY2sgY2hhcmFjdGVyIGNhbiBiZSB1c2VkXFxuXFx0XFx0Ly8gdG8gYnJlYWsgb3V0IG9mICh1bilxdW90ZWQgYXR0cmlidXRlIHZhbHVlcyBvciBIVE1MIGNvbW1lbnRzLlxcblxcdFxcdC8vIFNlZSBodHRwOi8vaHRtbDVzZWMub3JnLyMxMDIsIGh0dHA6Ly9odG1sNXNlYy5vcmcvIzEwOCwgYW5kXFxuXFx0XFx0Ly8gaHR0cDovL2h0bWw1c2VjLm9yZy8jMTMzLlxcblxcdFxcdCdgJzogJyYjeDYwOydcXG5cXHR9O1xcblxcblxcdHZhciByZWdleEludmFsaWRFbnRpdHkgPSAvJiMoPzpbeFhdW15hLWZBLUYwLTldfFteMC05eFhdKS87XFxuXFx0dmFyIHJlZ2V4SW52YWxpZFJhd0NvZGVQb2ludCA9IC9bXFxcXDAtXFxcXHgwOFxcXFx4MEJcXFxceDBFLVxcXFx4MUZcXFxceDdGLVxcXFx4OUZcXFxcdUZERDAtXFxcXHVGREVGXFxcXHVGRkZFXFxcXHVGRkZGXXxbXFxcXHVEODNGXFxcXHVEODdGXFxcXHVEOEJGXFxcXHVEOEZGXFxcXHVEOTNGXFxcXHVEOTdGXFxcXHVEOUJGXFxcXHVEOUZGXFxcXHVEQTNGXFxcXHVEQTdGXFxcXHVEQUJGXFxcXHVEQUZGXFxcXHVEQjNGXFxcXHVEQjdGXFxcXHVEQkJGXFxcXHVEQkZGXVtcXFxcdURGRkVcXFxcdURGRkZdfFtcXFxcdUQ4MDAtXFxcXHVEQkZGXSg/IVtcXFxcdURDMDAtXFxcXHVERkZGXSl8KD86W15cXFxcdUQ4MDAtXFxcXHVEQkZGXXxeKVtcXFxcdURDMDAtXFxcXHVERkZGXS87XFxuXFx0dmFyIHJlZ2V4RGVjb2RlID0gLyYjKFswLTldKykoOz8pfCYjW3hYXShbYS1mQS1GMC05XSspKDs/KXwmKFswLTlhLXpBLVpdKyk7fCYoQWFjdXRlfEFncmF2ZXxBdGlsZGV8Q2NlZGlsfEVhY3V0ZXxFZ3JhdmV8SWFjdXRlfElncmF2ZXxOdGlsZGV8T2FjdXRlfE9ncmF2ZXxPc2xhc2h8T3RpbGRlfFVhY3V0ZXxVZ3JhdmV8WWFjdXRlfGFhY3V0ZXxhZ3JhdmV8YXRpbGRlfGJydmJhcnxjY2VkaWx8Y3VycmVufGRpdmlkZXxlYWN1dGV8ZWdyYXZlfGZyYWMxMnxmcmFjMTR8ZnJhYzM0fGlhY3V0ZXxpZ3JhdmV8aXF1ZXN0fG1pZGRvdHxudGlsZGV8b2FjdXRlfG9ncmF2ZXxvc2xhc2h8b3RpbGRlfHBsdXNtbnx1YWN1dGV8dWdyYXZlfHlhY3V0ZXxBRWxpZ3xBY2lyY3xBcmluZ3xFY2lyY3xJY2lyY3xPY2lyY3xUSE9STnxVY2lyY3xhY2lyY3xhY3V0ZXxhZWxpZ3xhcmluZ3xjZWRpbHxlY2lyY3xpY2lyY3xpZXhjbHxsYXF1b3xtaWNyb3xvY2lyY3xwb3VuZHxyYXF1b3xzemxpZ3x0aG9ybnx0aW1lc3x1Y2lyY3xBdW1sfENPUFl8RXVtbHxJdW1sfE91bWx8UVVPVHxVdW1sfGF1bWx8Y2VudHxjb3B5fGV1bWx8aXVtbHxtYWNyfG5ic3B8b3JkZnxvcmRtfG91bWx8cGFyYXxxdW90fHNlY3R8c3VwMXxzdXAyfHN1cDN8dXVtbHx5dW1sfEFNUHxFVEh8UkVHfGFtcHxkZWd8ZXRofG5vdHxyZWd8c2h5fHVtbHx5ZW58R1R8TFR8Z3R8bHQpKFs9YS16QS1aMC05XSk/L2c7XFxuXFx0dmFyIGRlY29kZU1hcCA9IHsnYWFjdXRlJzonXFxcXHhFMScsJ0FhY3V0ZSc6J1xcXFx4QzEnLCdhYnJldmUnOidcXFxcdTAxMDMnLCdBYnJldmUnOidcXFxcdTAxMDInLCdhYyc6J1xcXFx1MjIzRScsJ2FjZCc6J1xcXFx1MjIzRicsJ2FjRSc6J1xcXFx1MjIzRVxcXFx1MDMzMycsJ2FjaXJjJzonXFxcXHhFMicsJ0FjaXJjJzonXFxcXHhDMicsJ2FjdXRlJzonXFxcXHhCNCcsJ2FjeSc6J1xcXFx1MDQzMCcsJ0FjeSc6J1xcXFx1MDQxMCcsJ2FlbGlnJzonXFxcXHhFNicsJ0FFbGlnJzonXFxcXHhDNicsJ2FmJzonXFxcXHUyMDYxJywnYWZyJzonXFxcXHVEODM1XFxcXHVERDFFJywnQWZyJzonXFxcXHVEODM1XFxcXHVERDA0JywnYWdyYXZlJzonXFxcXHhFMCcsJ0FncmF2ZSc6J1xcXFx4QzAnLCdhbGVmc3ltJzonXFxcXHUyMTM1JywnYWxlcGgnOidcXFxcdTIxMzUnLCdhbHBoYSc6J1xcXFx1MDNCMScsJ0FscGhhJzonXFxcXHUwMzkxJywnYW1hY3InOidcXFxcdTAxMDEnLCdBbWFjcic6J1xcXFx1MDEwMCcsJ2FtYWxnJzonXFxcXHUyQTNGJywnYW1wJzonJicsJ0FNUCc6JyYnLCdhbmQnOidcXFxcdTIyMjcnLCdBbmQnOidcXFxcdTJBNTMnLCdhbmRhbmQnOidcXFxcdTJBNTUnLCdhbmRkJzonXFxcXHUyQTVDJywnYW5kc2xvcGUnOidcXFxcdTJBNTgnLCdhbmR2JzonXFxcXHUyQTVBJywnYW5nJzonXFxcXHUyMjIwJywnYW5nZSc6J1xcXFx1MjlBNCcsJ2FuZ2xlJzonXFxcXHUyMjIwJywnYW5nbXNkJzonXFxcXHUyMjIxJywnYW5nbXNkYWEnOidcXFxcdTI5QTgnLCdhbmdtc2RhYic6J1xcXFx1MjlBOScsJ2FuZ21zZGFjJzonXFxcXHUyOUFBJywnYW5nbXNkYWQnOidcXFxcdTI5QUInLCdhbmdtc2RhZSc6J1xcXFx1MjlBQycsJ2FuZ21zZGFmJzonXFxcXHUyOUFEJywnYW5nbXNkYWcnOidcXFxcdTI5QUUnLCdhbmdtc2RhaCc6J1xcXFx1MjlBRicsJ2FuZ3J0JzonXFxcXHUyMjFGJywnYW5ncnR2Yic6J1xcXFx1MjJCRScsJ2FuZ3J0dmJkJzonXFxcXHUyOTlEJywnYW5nc3BoJzonXFxcXHUyMjIyJywnYW5nc3QnOidcXFxceEM1JywnYW5nemFycic6J1xcXFx1MjM3QycsJ2FvZ29uJzonXFxcXHUwMTA1JywnQW9nb24nOidcXFxcdTAxMDQnLCdhb3BmJzonXFxcXHVEODM1XFxcXHVERDUyJywnQW9wZic6J1xcXFx1RDgzNVxcXFx1REQzOCcsJ2FwJzonXFxcXHUyMjQ4JywnYXBhY2lyJzonXFxcXHUyQTZGJywnYXBlJzonXFxcXHUyMjRBJywnYXBFJzonXFxcXHUyQTcwJywnYXBpZCc6J1xcXFx1MjI0QicsJ2Fwb3MnOidcXFxcJycsJ0FwcGx5RnVuY3Rpb24nOidcXFxcdTIwNjEnLCdhcHByb3gnOidcXFxcdTIyNDgnLCdhcHByb3hlcSc6J1xcXFx1MjI0QScsJ2FyaW5nJzonXFxcXHhFNScsJ0FyaW5nJzonXFxcXHhDNScsJ2FzY3InOidcXFxcdUQ4MzVcXFxcdURDQjYnLCdBc2NyJzonXFxcXHVEODM1XFxcXHVEQzlDJywnQXNzaWduJzonXFxcXHUyMjU0JywnYXN0JzonKicsJ2FzeW1wJzonXFxcXHUyMjQ4JywnYXN5bXBlcSc6J1xcXFx1MjI0RCcsJ2F0aWxkZSc6J1xcXFx4RTMnLCdBdGlsZGUnOidcXFxceEMzJywnYXVtbCc6J1xcXFx4RTQnLCdBdW1sJzonXFxcXHhDNCcsJ2F3Y29uaW50JzonXFxcXHUyMjMzJywnYXdpbnQnOidcXFxcdTJBMTEnLCdiYWNrY29uZyc6J1xcXFx1MjI0QycsJ2JhY2tlcHNpbG9uJzonXFxcXHUwM0Y2JywnYmFja3ByaW1lJzonXFxcXHUyMDM1JywnYmFja3NpbSc6J1xcXFx1MjIzRCcsJ2JhY2tzaW1lcSc6J1xcXFx1MjJDRCcsJ0JhY2tzbGFzaCc6J1xcXFx1MjIxNicsJ0JhcnYnOidcXFxcdTJBRTcnLCdiYXJ2ZWUnOidcXFxcdTIyQkQnLCdiYXJ3ZWQnOidcXFxcdTIzMDUnLCdCYXJ3ZWQnOidcXFxcdTIzMDYnLCdiYXJ3ZWRnZSc6J1xcXFx1MjMwNScsJ2JicmsnOidcXFxcdTIzQjUnLCdiYnJrdGJyayc6J1xcXFx1MjNCNicsJ2Jjb25nJzonXFxcXHUyMjRDJywnYmN5JzonXFxcXHUwNDMxJywnQmN5JzonXFxcXHUwNDExJywnYmRxdW8nOidcXFxcdTIwMUUnLCdiZWNhdXMnOidcXFxcdTIyMzUnLCdiZWNhdXNlJzonXFxcXHUyMjM1JywnQmVjYXVzZSc6J1xcXFx1MjIzNScsJ2JlbXB0eXYnOidcXFxcdTI5QjAnLCdiZXBzaSc6J1xcXFx1MDNGNicsJ2Jlcm5vdSc6J1xcXFx1MjEyQycsJ0Jlcm5vdWxsaXMnOidcXFxcdTIxMkMnLCdiZXRhJzonXFxcXHUwM0IyJywnQmV0YSc6J1xcXFx1MDM5MicsJ2JldGgnOidcXFxcdTIxMzYnLCdiZXR3ZWVuJzonXFxcXHUyMjZDJywnYmZyJzonXFxcXHVEODM1XFxcXHVERDFGJywnQmZyJzonXFxcXHVEODM1XFxcXHVERDA1JywnYmlnY2FwJzonXFxcXHUyMkMyJywnYmlnY2lyYyc6J1xcXFx1MjVFRicsJ2JpZ2N1cCc6J1xcXFx1MjJDMycsJ2JpZ29kb3QnOidcXFxcdTJBMDAnLCdiaWdvcGx1cyc6J1xcXFx1MkEwMScsJ2JpZ290aW1lcyc6J1xcXFx1MkEwMicsJ2JpZ3NxY3VwJzonXFxcXHUyQTA2JywnYmlnc3Rhcic6J1xcXFx1MjYwNScsJ2JpZ3RyaWFuZ2xlZG93bic6J1xcXFx1MjVCRCcsJ2JpZ3RyaWFuZ2xldXAnOidcXFxcdTI1QjMnLCdiaWd1cGx1cyc6J1xcXFx1MkEwNCcsJ2JpZ3ZlZSc6J1xcXFx1MjJDMScsJ2JpZ3dlZGdlJzonXFxcXHUyMkMwJywnYmthcm93JzonXFxcXHUyOTBEJywnYmxhY2tsb3plbmdlJzonXFxcXHUyOUVCJywnYmxhY2tzcXVhcmUnOidcXFxcdTI1QUEnLCdibGFja3RyaWFuZ2xlJzonXFxcXHUyNUI0JywnYmxhY2t0cmlhbmdsZWRvd24nOidcXFxcdTI1QkUnLCdibGFja3RyaWFuZ2xlbGVmdCc6J1xcXFx1MjVDMicsJ2JsYWNrdHJpYW5nbGVyaWdodCc6J1xcXFx1MjVCOCcsJ2JsYW5rJzonXFxcXHUyNDIzJywnYmxrMTInOidcXFxcdTI1OTInLCdibGsxNCc6J1xcXFx1MjU5MScsJ2JsazM0JzonXFxcXHUyNTkzJywnYmxvY2snOidcXFxcdTI1ODgnLCdibmUnOic9XFxcXHUyMEU1JywnYm5lcXVpdic6J1xcXFx1MjI2MVxcXFx1MjBFNScsJ2Jub3QnOidcXFxcdTIzMTAnLCdiTm90JzonXFxcXHUyQUVEJywnYm9wZic6J1xcXFx1RDgzNVxcXFx1REQ1MycsJ0JvcGYnOidcXFxcdUQ4MzVcXFxcdUREMzknLCdib3QnOidcXFxcdTIyQTUnLCdib3R0b20nOidcXFxcdTIyQTUnLCdib3d0aWUnOidcXFxcdTIyQzgnLCdib3hib3gnOidcXFxcdTI5QzknLCdib3hkbCc6J1xcXFx1MjUxMCcsJ2JveGRMJzonXFxcXHUyNTU1JywnYm94RGwnOidcXFxcdTI1NTYnLCdib3hETCc6J1xcXFx1MjU1NycsJ2JveGRyJzonXFxcXHUyNTBDJywnYm94ZFInOidcXFxcdTI1NTInLCdib3hEcic6J1xcXFx1MjU1MycsJ2JveERSJzonXFxcXHUyNTU0JywnYm94aCc6J1xcXFx1MjUwMCcsJ2JveEgnOidcXFxcdTI1NTAnLCdib3hoZCc6J1xcXFx1MjUyQycsJ2JveGhEJzonXFxcXHUyNTY1JywnYm94SGQnOidcXFxcdTI1NjQnLCdib3hIRCc6J1xcXFx1MjU2NicsJ2JveGh1JzonXFxcXHUyNTM0JywnYm94aFUnOidcXFxcdTI1NjgnLCdib3hIdSc6J1xcXFx1MjU2NycsJ2JveEhVJzonXFxcXHUyNTY5JywnYm94bWludXMnOidcXFxcdTIyOUYnLCdib3hwbHVzJzonXFxcXHUyMjlFJywnYm94dGltZXMnOidcXFxcdTIyQTAnLCdib3h1bCc6J1xcXFx1MjUxOCcsJ2JveHVMJzonXFxcXHUyNTVCJywnYm94VWwnOidcXFxcdTI1NUMnLCdib3hVTCc6J1xcXFx1MjU1RCcsJ2JveHVyJzonXFxcXHUyNTE0JywnYm94dVInOidcXFxcdTI1NTgnLCdib3hVcic6J1xcXFx1MjU1OScsJ2JveFVSJzonXFxcXHUyNTVBJywnYm94dic6J1xcXFx1MjUwMicsJ2JveFYnOidcXFxcdTI1NTEnLCdib3h2aCc6J1xcXFx1MjUzQycsJ2JveHZIJzonXFxcXHUyNTZBJywnYm94VmgnOidcXFxcdTI1NkInLCdib3hWSCc6J1xcXFx1MjU2QycsJ2JveHZsJzonXFxcXHUyNTI0JywnYm94dkwnOidcXFxcdTI1NjEnLCdib3hWbCc6J1xcXFx1MjU2MicsJ2JveFZMJzonXFxcXHUyNTYzJywnYm94dnInOidcXFxcdTI1MUMnLCdib3h2Uic6J1xcXFx1MjU1RScsJ2JveFZyJzonXFxcXHUyNTVGJywnYm94VlInOidcXFxcdTI1NjAnLCdicHJpbWUnOidcXFxcdTIwMzUnLCdicmV2ZSc6J1xcXFx1MDJEOCcsJ0JyZXZlJzonXFxcXHUwMkQ4JywnYnJ2YmFyJzonXFxcXHhBNicsJ2JzY3InOidcXFxcdUQ4MzVcXFxcdURDQjcnLCdCc2NyJzonXFxcXHUyMTJDJywnYnNlbWknOidcXFxcdTIwNEYnLCdic2ltJzonXFxcXHUyMjNEJywnYnNpbWUnOidcXFxcdTIyQ0QnLCdic29sJzonXFxcXFxcXFwnLCdic29sYic6J1xcXFx1MjlDNScsJ2Jzb2xoc3ViJzonXFxcXHUyN0M4JywnYnVsbCc6J1xcXFx1MjAyMicsJ2J1bGxldCc6J1xcXFx1MjAyMicsJ2J1bXAnOidcXFxcdTIyNEUnLCdidW1wZSc6J1xcXFx1MjI0RicsJ2J1bXBFJzonXFxcXHUyQUFFJywnYnVtcGVxJzonXFxcXHUyMjRGJywnQnVtcGVxJzonXFxcXHUyMjRFJywnY2FjdXRlJzonXFxcXHUwMTA3JywnQ2FjdXRlJzonXFxcXHUwMTA2JywnY2FwJzonXFxcXHUyMjI5JywnQ2FwJzonXFxcXHUyMkQyJywnY2FwYW5kJzonXFxcXHUyQTQ0JywnY2FwYnJjdXAnOidcXFxcdTJBNDknLCdjYXBjYXAnOidcXFxcdTJBNEInLCdjYXBjdXAnOidcXFxcdTJBNDcnLCdjYXBkb3QnOidcXFxcdTJBNDAnLCdDYXBpdGFsRGlmZmVyZW50aWFsRCc6J1xcXFx1MjE0NScsJ2NhcHMnOidcXFxcdTIyMjlcXFxcdUZFMDAnLCdjYXJldCc6J1xcXFx1MjA0MScsJ2Nhcm9uJzonXFxcXHUwMkM3JywnQ2F5bGV5cyc6J1xcXFx1MjEyRCcsJ2NjYXBzJzonXFxcXHUyQTREJywnY2Nhcm9uJzonXFxcXHUwMTBEJywnQ2Nhcm9uJzonXFxcXHUwMTBDJywnY2NlZGlsJzonXFxcXHhFNycsJ0NjZWRpbCc6J1xcXFx4QzcnLCdjY2lyYyc6J1xcXFx1MDEwOScsJ0NjaXJjJzonXFxcXHUwMTA4JywnQ2NvbmludCc6J1xcXFx1MjIzMCcsJ2NjdXBzJzonXFxcXHUyQTRDJywnY2N1cHNzbSc6J1xcXFx1MkE1MCcsJ2Nkb3QnOidcXFxcdTAxMEInLCdDZG90JzonXFxcXHUwMTBBJywnY2VkaWwnOidcXFxceEI4JywnQ2VkaWxsYSc6J1xcXFx4QjgnLCdjZW1wdHl2JzonXFxcXHUyOUIyJywnY2VudCc6J1xcXFx4QTInLCdjZW50ZXJkb3QnOidcXFxceEI3JywnQ2VudGVyRG90JzonXFxcXHhCNycsJ2Nmcic6J1xcXFx1RDgzNVxcXFx1REQyMCcsJ0Nmcic6J1xcXFx1MjEyRCcsJ2NoY3knOidcXFxcdTA0NDcnLCdDSGN5JzonXFxcXHUwNDI3JywnY2hlY2snOidcXFxcdTI3MTMnLCdjaGVja21hcmsnOidcXFxcdTI3MTMnLCdjaGknOidcXFxcdTAzQzcnLCdDaGknOidcXFxcdTAzQTcnLCdjaXInOidcXFxcdTI1Q0InLCdjaXJjJzonXFxcXHUwMkM2JywnY2lyY2VxJzonXFxcXHUyMjU3JywnY2lyY2xlYXJyb3dsZWZ0JzonXFxcXHUyMUJBJywnY2lyY2xlYXJyb3dyaWdodCc6J1xcXFx1MjFCQicsJ2NpcmNsZWRhc3QnOidcXFxcdTIyOUInLCdjaXJjbGVkY2lyYyc6J1xcXFx1MjI5QScsJ2NpcmNsZWRkYXNoJzonXFxcXHUyMjlEJywnQ2lyY2xlRG90JzonXFxcXHUyMjk5JywnY2lyY2xlZFInOidcXFxceEFFJywnY2lyY2xlZFMnOidcXFxcdTI0QzgnLCdDaXJjbGVNaW51cyc6J1xcXFx1MjI5NicsJ0NpcmNsZVBsdXMnOidcXFxcdTIyOTUnLCdDaXJjbGVUaW1lcyc6J1xcXFx1MjI5NycsJ2NpcmUnOidcXFxcdTIyNTcnLCdjaXJFJzonXFxcXHUyOUMzJywnY2lyZm5pbnQnOidcXFxcdTJBMTAnLCdjaXJtaWQnOidcXFxcdTJBRUYnLCdjaXJzY2lyJzonXFxcXHUyOUMyJywnQ2xvY2t3aXNlQ29udG91ckludGVncmFsJzonXFxcXHUyMjMyJywnQ2xvc2VDdXJseURvdWJsZVF1b3RlJzonXFxcXHUyMDFEJywnQ2xvc2VDdXJseVF1b3RlJzonXFxcXHUyMDE5JywnY2x1YnMnOidcXFxcdTI2NjMnLCdjbHVic3VpdCc6J1xcXFx1MjY2MycsJ2NvbG9uJzonOicsJ0NvbG9uJzonXFxcXHUyMjM3JywnY29sb25lJzonXFxcXHUyMjU0JywnQ29sb25lJzonXFxcXHUyQTc0JywnY29sb25lcSc6J1xcXFx1MjI1NCcsJ2NvbW1hJzonLCcsJ2NvbW1hdCc6J0AnLCdjb21wJzonXFxcXHUyMjAxJywnY29tcGZuJzonXFxcXHUyMjE4JywnY29tcGxlbWVudCc6J1xcXFx1MjIwMScsJ2NvbXBsZXhlcyc6J1xcXFx1MjEwMicsJ2NvbmcnOidcXFxcdTIyNDUnLCdjb25nZG90JzonXFxcXHUyQTZEJywnQ29uZ3J1ZW50JzonXFxcXHUyMjYxJywnY29uaW50JzonXFxcXHUyMjJFJywnQ29uaW50JzonXFxcXHUyMjJGJywnQ29udG91ckludGVncmFsJzonXFxcXHUyMjJFJywnY29wZic6J1xcXFx1RDgzNVxcXFx1REQ1NCcsJ0NvcGYnOidcXFxcdTIxMDInLCdjb3Byb2QnOidcXFxcdTIyMTAnLCdDb3Byb2R1Y3QnOidcXFxcdTIyMTAnLCdjb3B5JzonXFxcXHhBOScsJ0NPUFknOidcXFxceEE5JywnY29weXNyJzonXFxcXHUyMTE3JywnQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCc6J1xcXFx1MjIzMycsJ2NyYXJyJzonXFxcXHUyMUI1JywnY3Jvc3MnOidcXFxcdTI3MTcnLCdDcm9zcyc6J1xcXFx1MkEyRicsJ2NzY3InOidcXFxcdUQ4MzVcXFxcdURDQjgnLCdDc2NyJzonXFxcXHVEODM1XFxcXHVEQzlFJywnY3N1Yic6J1xcXFx1MkFDRicsJ2NzdWJlJzonXFxcXHUyQUQxJywnY3N1cCc6J1xcXFx1MkFEMCcsJ2NzdXBlJzonXFxcXHUyQUQyJywnY3Rkb3QnOidcXFxcdTIyRUYnLCdjdWRhcnJsJzonXFxcXHUyOTM4JywnY3VkYXJycic6J1xcXFx1MjkzNScsJ2N1ZXByJzonXFxcXHUyMkRFJywnY3Vlc2MnOidcXFxcdTIyREYnLCdjdWxhcnInOidcXFxcdTIxQjYnLCdjdWxhcnJwJzonXFxcXHUyOTNEJywnY3VwJzonXFxcXHUyMjJBJywnQ3VwJzonXFxcXHUyMkQzJywnY3VwYnJjYXAnOidcXFxcdTJBNDgnLCdjdXBjYXAnOidcXFxcdTJBNDYnLCdDdXBDYXAnOidcXFxcdTIyNEQnLCdjdXBjdXAnOidcXFxcdTJBNEEnLCdjdXBkb3QnOidcXFxcdTIyOEQnLCdjdXBvcic6J1xcXFx1MkE0NScsJ2N1cHMnOidcXFxcdTIyMkFcXFxcdUZFMDAnLCdjdXJhcnInOidcXFxcdTIxQjcnLCdjdXJhcnJtJzonXFxcXHUyOTNDJywnY3VybHllcXByZWMnOidcXFxcdTIyREUnLCdjdXJseWVxc3VjYyc6J1xcXFx1MjJERicsJ2N1cmx5dmVlJzonXFxcXHUyMkNFJywnY3VybHl3ZWRnZSc6J1xcXFx1MjJDRicsJ2N1cnJlbic6J1xcXFx4QTQnLCdjdXJ2ZWFycm93bGVmdCc6J1xcXFx1MjFCNicsJ2N1cnZlYXJyb3dyaWdodCc6J1xcXFx1MjFCNycsJ2N1dmVlJzonXFxcXHUyMkNFJywnY3V3ZWQnOidcXFxcdTIyQ0YnLCdjd2NvbmludCc6J1xcXFx1MjIzMicsJ2N3aW50JzonXFxcXHUyMjMxJywnY3lsY3R5JzonXFxcXHUyMzJEJywnZGFnZ2VyJzonXFxcXHUyMDIwJywnRGFnZ2VyJzonXFxcXHUyMDIxJywnZGFsZXRoJzonXFxcXHUyMTM4JywnZGFycic6J1xcXFx1MjE5MycsJ2RBcnInOidcXFxcdTIxRDMnLCdEYXJyJzonXFxcXHUyMUExJywnZGFzaCc6J1xcXFx1MjAxMCcsJ2Rhc2h2JzonXFxcXHUyMkEzJywnRGFzaHYnOidcXFxcdTJBRTQnLCdkYmthcm93JzonXFxcXHUyOTBGJywnZGJsYWMnOidcXFxcdTAyREQnLCdkY2Fyb24nOidcXFxcdTAxMEYnLCdEY2Fyb24nOidcXFxcdTAxMEUnLCdkY3knOidcXFxcdTA0MzQnLCdEY3knOidcXFxcdTA0MTQnLCdkZCc6J1xcXFx1MjE0NicsJ0REJzonXFxcXHUyMTQ1JywnZGRhZ2dlcic6J1xcXFx1MjAyMScsJ2RkYXJyJzonXFxcXHUyMUNBJywnRERvdHJhaGQnOidcXFxcdTI5MTEnLCdkZG90c2VxJzonXFxcXHUyQTc3JywnZGVnJzonXFxcXHhCMCcsJ0RlbCc6J1xcXFx1MjIwNycsJ2RlbHRhJzonXFxcXHUwM0I0JywnRGVsdGEnOidcXFxcdTAzOTQnLCdkZW1wdHl2JzonXFxcXHUyOUIxJywnZGZpc2h0JzonXFxcXHUyOTdGJywnZGZyJzonXFxcXHVEODM1XFxcXHVERDIxJywnRGZyJzonXFxcXHVEODM1XFxcXHVERDA3JywnZEhhcic6J1xcXFx1Mjk2NScsJ2RoYXJsJzonXFxcXHUyMUMzJywnZGhhcnInOidcXFxcdTIxQzInLCdEaWFjcml0aWNhbEFjdXRlJzonXFxcXHhCNCcsJ0RpYWNyaXRpY2FsRG90JzonXFxcXHUwMkQ5JywnRGlhY3JpdGljYWxEb3VibGVBY3V0ZSc6J1xcXFx1MDJERCcsJ0RpYWNyaXRpY2FsR3JhdmUnOidgJywnRGlhY3JpdGljYWxUaWxkZSc6J1xcXFx1MDJEQycsJ2RpYW0nOidcXFxcdTIyQzQnLCdkaWFtb25kJzonXFxcXHUyMkM0JywnRGlhbW9uZCc6J1xcXFx1MjJDNCcsJ2RpYW1vbmRzdWl0JzonXFxcXHUyNjY2JywnZGlhbXMnOidcXFxcdTI2NjYnLCdkaWUnOidcXFxceEE4JywnRGlmZmVyZW50aWFsRCc6J1xcXFx1MjE0NicsJ2RpZ2FtbWEnOidcXFxcdTAzREQnLCdkaXNpbic6J1xcXFx1MjJGMicsJ2Rpdic6J1xcXFx4RjcnLCdkaXZpZGUnOidcXFxceEY3JywnZGl2aWRlb250aW1lcyc6J1xcXFx1MjJDNycsJ2Rpdm9ueCc6J1xcXFx1MjJDNycsJ2RqY3knOidcXFxcdTA0NTInLCdESmN5JzonXFxcXHUwNDAyJywnZGxjb3JuJzonXFxcXHUyMzFFJywnZGxjcm9wJzonXFxcXHUyMzBEJywnZG9sbGFyJzonJCcsJ2RvcGYnOidcXFxcdUQ4MzVcXFxcdURENTUnLCdEb3BmJzonXFxcXHVEODM1XFxcXHVERDNCJywnZG90JzonXFxcXHUwMkQ5JywnRG90JzonXFxcXHhBOCcsJ0RvdERvdCc6J1xcXFx1MjBEQycsJ2RvdGVxJzonXFxcXHUyMjUwJywnZG90ZXFkb3QnOidcXFxcdTIyNTEnLCdEb3RFcXVhbCc6J1xcXFx1MjI1MCcsJ2RvdG1pbnVzJzonXFxcXHUyMjM4JywnZG90cGx1cyc6J1xcXFx1MjIxNCcsJ2RvdHNxdWFyZSc6J1xcXFx1MjJBMScsJ2RvdWJsZWJhcndlZGdlJzonXFxcXHUyMzA2JywnRG91YmxlQ29udG91ckludGVncmFsJzonXFxcXHUyMjJGJywnRG91YmxlRG90JzonXFxcXHhBOCcsJ0RvdWJsZURvd25BcnJvdyc6J1xcXFx1MjFEMycsJ0RvdWJsZUxlZnRBcnJvdyc6J1xcXFx1MjFEMCcsJ0RvdWJsZUxlZnRSaWdodEFycm93JzonXFxcXHUyMUQ0JywnRG91YmxlTGVmdFRlZSc6J1xcXFx1MkFFNCcsJ0RvdWJsZUxvbmdMZWZ0QXJyb3cnOidcXFxcdTI3RjgnLCdEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3cnOidcXFxcdTI3RkEnLCdEb3VibGVMb25nUmlnaHRBcnJvdyc6J1xcXFx1MjdGOScsJ0RvdWJsZVJpZ2h0QXJyb3cnOidcXFxcdTIxRDInLCdEb3VibGVSaWdodFRlZSc6J1xcXFx1MjJBOCcsJ0RvdWJsZVVwQXJyb3cnOidcXFxcdTIxRDEnLCdEb3VibGVVcERvd25BcnJvdyc6J1xcXFx1MjFENScsJ0RvdWJsZVZlcnRpY2FsQmFyJzonXFxcXHUyMjI1JywnZG93bmFycm93JzonXFxcXHUyMTkzJywnRG93bmFycm93JzonXFxcXHUyMUQzJywnRG93bkFycm93JzonXFxcXHUyMTkzJywnRG93bkFycm93QmFyJzonXFxcXHUyOTEzJywnRG93bkFycm93VXBBcnJvdyc6J1xcXFx1MjFGNScsJ0Rvd25CcmV2ZSc6J1xcXFx1MDMxMScsJ2Rvd25kb3duYXJyb3dzJzonXFxcXHUyMUNBJywnZG93bmhhcnBvb25sZWZ0JzonXFxcXHUyMUMzJywnZG93bmhhcnBvb25yaWdodCc6J1xcXFx1MjFDMicsJ0Rvd25MZWZ0UmlnaHRWZWN0b3InOidcXFxcdTI5NTAnLCdEb3duTGVmdFRlZVZlY3Rvcic6J1xcXFx1Mjk1RScsJ0Rvd25MZWZ0VmVjdG9yJzonXFxcXHUyMUJEJywnRG93bkxlZnRWZWN0b3JCYXInOidcXFxcdTI5NTYnLCdEb3duUmlnaHRUZWVWZWN0b3InOidcXFxcdTI5NUYnLCdEb3duUmlnaHRWZWN0b3InOidcXFxcdTIxQzEnLCdEb3duUmlnaHRWZWN0b3JCYXInOidcXFxcdTI5NTcnLCdEb3duVGVlJzonXFxcXHUyMkE0JywnRG93blRlZUFycm93JzonXFxcXHUyMUE3JywnZHJia2Fyb3cnOidcXFxcdTI5MTAnLCdkcmNvcm4nOidcXFxcdTIzMUYnLCdkcmNyb3AnOidcXFxcdTIzMEMnLCdkc2NyJzonXFxcXHVEODM1XFxcXHVEQ0I5JywnRHNjcic6J1xcXFx1RDgzNVxcXFx1REM5RicsJ2RzY3knOidcXFxcdTA0NTUnLCdEU2N5JzonXFxcXHUwNDA1JywnZHNvbCc6J1xcXFx1MjlGNicsJ2RzdHJvayc6J1xcXFx1MDExMScsJ0RzdHJvayc6J1xcXFx1MDExMCcsJ2R0ZG90JzonXFxcXHUyMkYxJywnZHRyaSc6J1xcXFx1MjVCRicsJ2R0cmlmJzonXFxcXHUyNUJFJywnZHVhcnInOidcXFxcdTIxRjUnLCdkdWhhcic6J1xcXFx1Mjk2RicsJ2R3YW5nbGUnOidcXFxcdTI5QTYnLCdkemN5JzonXFxcXHUwNDVGJywnRFpjeSc6J1xcXFx1MDQwRicsJ2R6aWdyYXJyJzonXFxcXHUyN0ZGJywnZWFjdXRlJzonXFxcXHhFOScsJ0VhY3V0ZSc6J1xcXFx4QzknLCdlYXN0ZXInOidcXFxcdTJBNkUnLCdlY2Fyb24nOidcXFxcdTAxMUInLCdFY2Fyb24nOidcXFxcdTAxMUEnLCdlY2lyJzonXFxcXHUyMjU2JywnZWNpcmMnOidcXFxceEVBJywnRWNpcmMnOidcXFxceENBJywnZWNvbG9uJzonXFxcXHUyMjU1JywnZWN5JzonXFxcXHUwNDREJywnRWN5JzonXFxcXHUwNDJEJywnZUREb3QnOidcXFxcdTJBNzcnLCdlZG90JzonXFxcXHUwMTE3JywnZURvdCc6J1xcXFx1MjI1MScsJ0Vkb3QnOidcXFxcdTAxMTYnLCdlZSc6J1xcXFx1MjE0NycsJ2VmRG90JzonXFxcXHUyMjUyJywnZWZyJzonXFxcXHVEODM1XFxcXHVERDIyJywnRWZyJzonXFxcXHVEODM1XFxcXHVERDA4JywnZWcnOidcXFxcdTJBOUEnLCdlZ3JhdmUnOidcXFxceEU4JywnRWdyYXZlJzonXFxcXHhDOCcsJ2Vncyc6J1xcXFx1MkE5NicsJ2Vnc2RvdCc6J1xcXFx1MkE5OCcsJ2VsJzonXFxcXHUyQTk5JywnRWxlbWVudCc6J1xcXFx1MjIwOCcsJ2VsaW50ZXJzJzonXFxcXHUyM0U3JywnZWxsJzonXFxcXHUyMTEzJywnZWxzJzonXFxcXHUyQTk1JywnZWxzZG90JzonXFxcXHUyQTk3JywnZW1hY3InOidcXFxcdTAxMTMnLCdFbWFjcic6J1xcXFx1MDExMicsJ2VtcHR5JzonXFxcXHUyMjA1JywnZW1wdHlzZXQnOidcXFxcdTIyMDUnLCdFbXB0eVNtYWxsU3F1YXJlJzonXFxcXHUyNUZCJywnZW1wdHl2JzonXFxcXHUyMjA1JywnRW1wdHlWZXJ5U21hbGxTcXVhcmUnOidcXFxcdTI1QUInLCdlbXNwJzonXFxcXHUyMDAzJywnZW1zcDEzJzonXFxcXHUyMDA0JywnZW1zcDE0JzonXFxcXHUyMDA1JywnZW5nJzonXFxcXHUwMTRCJywnRU5HJzonXFxcXHUwMTRBJywnZW5zcCc6J1xcXFx1MjAwMicsJ2VvZ29uJzonXFxcXHUwMTE5JywnRW9nb24nOidcXFxcdTAxMTgnLCdlb3BmJzonXFxcXHVEODM1XFxcXHVERDU2JywnRW9wZic6J1xcXFx1RDgzNVxcXFx1REQzQycsJ2VwYXInOidcXFxcdTIyRDUnLCdlcGFyc2wnOidcXFxcdTI5RTMnLCdlcGx1cyc6J1xcXFx1MkE3MScsJ2Vwc2knOidcXFxcdTAzQjUnLCdlcHNpbG9uJzonXFxcXHUwM0I1JywnRXBzaWxvbic6J1xcXFx1MDM5NScsJ2Vwc2l2JzonXFxcXHUwM0Y1JywnZXFjaXJjJzonXFxcXHUyMjU2JywnZXFjb2xvbic6J1xcXFx1MjI1NScsJ2Vxc2ltJzonXFxcXHUyMjQyJywnZXFzbGFudGd0cic6J1xcXFx1MkE5NicsJ2Vxc2xhbnRsZXNzJzonXFxcXHUyQTk1JywnRXF1YWwnOidcXFxcdTJBNzUnLCdlcXVhbHMnOic9JywnRXF1YWxUaWxkZSc6J1xcXFx1MjI0MicsJ2VxdWVzdCc6J1xcXFx1MjI1RicsJ0VxdWlsaWJyaXVtJzonXFxcXHUyMUNDJywnZXF1aXYnOidcXFxcdTIyNjEnLCdlcXVpdkREJzonXFxcXHUyQTc4JywnZXF2cGFyc2wnOidcXFxcdTI5RTUnLCdlcmFycic6J1xcXFx1Mjk3MScsJ2VyRG90JzonXFxcXHUyMjUzJywnZXNjcic6J1xcXFx1MjEyRicsJ0VzY3InOidcXFxcdTIxMzAnLCdlc2RvdCc6J1xcXFx1MjI1MCcsJ2VzaW0nOidcXFxcdTIyNDInLCdFc2ltJzonXFxcXHUyQTczJywnZXRhJzonXFxcXHUwM0I3JywnRXRhJzonXFxcXHUwMzk3JywnZXRoJzonXFxcXHhGMCcsJ0VUSCc6J1xcXFx4RDAnLCdldW1sJzonXFxcXHhFQicsJ0V1bWwnOidcXFxceENCJywnZXVybyc6J1xcXFx1MjBBQycsJ2V4Y2wnOichJywnZXhpc3QnOidcXFxcdTIyMDMnLCdFeGlzdHMnOidcXFxcdTIyMDMnLCdleHBlY3RhdGlvbic6J1xcXFx1MjEzMCcsJ2V4cG9uZW50aWFsZSc6J1xcXFx1MjE0NycsJ0V4cG9uZW50aWFsRSc6J1xcXFx1MjE0NycsJ2ZhbGxpbmdkb3RzZXEnOidcXFxcdTIyNTInLCdmY3knOidcXFxcdTA0NDQnLCdGY3knOidcXFxcdTA0MjQnLCdmZW1hbGUnOidcXFxcdTI2NDAnLCdmZmlsaWcnOidcXFxcdUZCMDMnLCdmZmxpZyc6J1xcXFx1RkIwMCcsJ2ZmbGxpZyc6J1xcXFx1RkIwNCcsJ2Zmcic6J1xcXFx1RDgzNVxcXFx1REQyMycsJ0Zmcic6J1xcXFx1RDgzNVxcXFx1REQwOScsJ2ZpbGlnJzonXFxcXHVGQjAxJywnRmlsbGVkU21hbGxTcXVhcmUnOidcXFxcdTI1RkMnLCdGaWxsZWRWZXJ5U21hbGxTcXVhcmUnOidcXFxcdTI1QUEnLCdmamxpZyc6J2ZqJywnZmxhdCc6J1xcXFx1MjY2RCcsJ2ZsbGlnJzonXFxcXHVGQjAyJywnZmx0bnMnOidcXFxcdTI1QjEnLCdmbm9mJzonXFxcXHUwMTkyJywnZm9wZic6J1xcXFx1RDgzNVxcXFx1REQ1NycsJ0ZvcGYnOidcXFxcdUQ4MzVcXFxcdUREM0QnLCdmb3JhbGwnOidcXFxcdTIyMDAnLCdGb3JBbGwnOidcXFxcdTIyMDAnLCdmb3JrJzonXFxcXHUyMkQ0JywnZm9ya3YnOidcXFxcdTJBRDknLCdGb3VyaWVydHJmJzonXFxcXHUyMTMxJywnZnBhcnRpbnQnOidcXFxcdTJBMEQnLCdmcmFjMTInOidcXFxceEJEJywnZnJhYzEzJzonXFxcXHUyMTUzJywnZnJhYzE0JzonXFxcXHhCQycsJ2ZyYWMxNSc6J1xcXFx1MjE1NScsJ2ZyYWMxNic6J1xcXFx1MjE1OScsJ2ZyYWMxOCc6J1xcXFx1MjE1QicsJ2ZyYWMyMyc6J1xcXFx1MjE1NCcsJ2ZyYWMyNSc6J1xcXFx1MjE1NicsJ2ZyYWMzNCc6J1xcXFx4QkUnLCdmcmFjMzUnOidcXFxcdTIxNTcnLCdmcmFjMzgnOidcXFxcdTIxNUMnLCdmcmFjNDUnOidcXFxcdTIxNTgnLCdmcmFjNTYnOidcXFxcdTIxNUEnLCdmcmFjNTgnOidcXFxcdTIxNUQnLCdmcmFjNzgnOidcXFxcdTIxNUUnLCdmcmFzbCc6J1xcXFx1MjA0NCcsJ2Zyb3duJzonXFxcXHUyMzIyJywnZnNjcic6J1xcXFx1RDgzNVxcXFx1RENCQicsJ0ZzY3InOidcXFxcdTIxMzEnLCdnYWN1dGUnOidcXFxcdTAxRjUnLCdnYW1tYSc6J1xcXFx1MDNCMycsJ0dhbW1hJzonXFxcXHUwMzkzJywnZ2FtbWFkJzonXFxcXHUwM0REJywnR2FtbWFkJzonXFxcXHUwM0RDJywnZ2FwJzonXFxcXHUyQTg2JywnZ2JyZXZlJzonXFxcXHUwMTFGJywnR2JyZXZlJzonXFxcXHUwMTFFJywnR2NlZGlsJzonXFxcXHUwMTIyJywnZ2NpcmMnOidcXFxcdTAxMUQnLCdHY2lyYyc6J1xcXFx1MDExQycsJ2djeSc6J1xcXFx1MDQzMycsJ0djeSc6J1xcXFx1MDQxMycsJ2dkb3QnOidcXFxcdTAxMjEnLCdHZG90JzonXFxcXHUwMTIwJywnZ2UnOidcXFxcdTIyNjUnLCdnRSc6J1xcXFx1MjI2NycsJ2dlbCc6J1xcXFx1MjJEQicsJ2dFbCc6J1xcXFx1MkE4QycsJ2dlcSc6J1xcXFx1MjI2NScsJ2dlcXEnOidcXFxcdTIyNjcnLCdnZXFzbGFudCc6J1xcXFx1MkE3RScsJ2dlcyc6J1xcXFx1MkE3RScsJ2dlc2NjJzonXFxcXHUyQUE5JywnZ2VzZG90JzonXFxcXHUyQTgwJywnZ2VzZG90byc6J1xcXFx1MkE4MicsJ2dlc2RvdG9sJzonXFxcXHUyQTg0JywnZ2VzbCc6J1xcXFx1MjJEQlxcXFx1RkUwMCcsJ2dlc2xlcyc6J1xcXFx1MkE5NCcsJ2dmcic6J1xcXFx1RDgzNVxcXFx1REQyNCcsJ0dmcic6J1xcXFx1RDgzNVxcXFx1REQwQScsJ2dnJzonXFxcXHUyMjZCJywnR2cnOidcXFxcdTIyRDknLCdnZ2cnOidcXFxcdTIyRDknLCdnaW1lbCc6J1xcXFx1MjEzNycsJ2dqY3knOidcXFxcdTA0NTMnLCdHSmN5JzonXFxcXHUwNDAzJywnZ2wnOidcXFxcdTIyNzcnLCdnbGEnOidcXFxcdTJBQTUnLCdnbEUnOidcXFxcdTJBOTInLCdnbGonOidcXFxcdTJBQTQnLCdnbmFwJzonXFxcXHUyQThBJywnZ25hcHByb3gnOidcXFxcdTJBOEEnLCdnbmUnOidcXFxcdTJBODgnLCdnbkUnOidcXFxcdTIyNjknLCdnbmVxJzonXFxcXHUyQTg4JywnZ25lcXEnOidcXFxcdTIyNjknLCdnbnNpbSc6J1xcXFx1MjJFNycsJ2dvcGYnOidcXFxcdUQ4MzVcXFxcdURENTgnLCdHb3BmJzonXFxcXHVEODM1XFxcXHVERDNFJywnZ3JhdmUnOidgJywnR3JlYXRlckVxdWFsJzonXFxcXHUyMjY1JywnR3JlYXRlckVxdWFsTGVzcyc6J1xcXFx1MjJEQicsJ0dyZWF0ZXJGdWxsRXF1YWwnOidcXFxcdTIyNjcnLCdHcmVhdGVyR3JlYXRlcic6J1xcXFx1MkFBMicsJ0dyZWF0ZXJMZXNzJzonXFxcXHUyMjc3JywnR3JlYXRlclNsYW50RXF1YWwnOidcXFxcdTJBN0UnLCdHcmVhdGVyVGlsZGUnOidcXFxcdTIyNzMnLCdnc2NyJzonXFxcXHUyMTBBJywnR3Njcic6J1xcXFx1RDgzNVxcXFx1RENBMicsJ2dzaW0nOidcXFxcdTIyNzMnLCdnc2ltZSc6J1xcXFx1MkE4RScsJ2dzaW1sJzonXFxcXHUyQTkwJywnZ3QnOic+JywnR3QnOidcXFxcdTIyNkInLCdHVCc6Jz4nLCdndGNjJzonXFxcXHUyQUE3JywnZ3RjaXInOidcXFxcdTJBN0EnLCdndGRvdCc6J1xcXFx1MjJENycsJ2d0bFBhcic6J1xcXFx1Mjk5NScsJ2d0cXVlc3QnOidcXFxcdTJBN0MnLCdndHJhcHByb3gnOidcXFxcdTJBODYnLCdndHJhcnInOidcXFxcdTI5NzgnLCdndHJkb3QnOidcXFxcdTIyRDcnLCdndHJlcWxlc3MnOidcXFxcdTIyREInLCdndHJlcXFsZXNzJzonXFxcXHUyQThDJywnZ3RybGVzcyc6J1xcXFx1MjI3NycsJ2d0cnNpbSc6J1xcXFx1MjI3MycsJ2d2ZXJ0bmVxcSc6J1xcXFx1MjI2OVxcXFx1RkUwMCcsJ2d2bkUnOidcXFxcdTIyNjlcXFxcdUZFMDAnLCdIYWNlayc6J1xcXFx1MDJDNycsJ2hhaXJzcCc6J1xcXFx1MjAwQScsJ2hhbGYnOidcXFxceEJEJywnaGFtaWx0JzonXFxcXHUyMTBCJywnaGFyZGN5JzonXFxcXHUwNDRBJywnSEFSRGN5JzonXFxcXHUwNDJBJywnaGFycic6J1xcXFx1MjE5NCcsJ2hBcnInOidcXFxcdTIxRDQnLCdoYXJyY2lyJzonXFxcXHUyOTQ4JywnaGFycncnOidcXFxcdTIxQUQnLCdIYXQnOideJywnaGJhcic6J1xcXFx1MjEwRicsJ2hjaXJjJzonXFxcXHUwMTI1JywnSGNpcmMnOidcXFxcdTAxMjQnLCdoZWFydHMnOidcXFxcdTI2NjUnLCdoZWFydHN1aXQnOidcXFxcdTI2NjUnLCdoZWxsaXAnOidcXFxcdTIwMjYnLCdoZXJjb24nOidcXFxcdTIyQjknLCdoZnInOidcXFxcdUQ4MzVcXFxcdUREMjUnLCdIZnInOidcXFxcdTIxMEMnLCdIaWxiZXJ0U3BhY2UnOidcXFxcdTIxMEInLCdoa3NlYXJvdyc6J1xcXFx1MjkyNScsJ2hrc3dhcm93JzonXFxcXHUyOTI2JywnaG9hcnInOidcXFxcdTIxRkYnLCdob210aHQnOidcXFxcdTIyM0InLCdob29rbGVmdGFycm93JzonXFxcXHUyMUE5JywnaG9va3JpZ2h0YXJyb3cnOidcXFxcdTIxQUEnLCdob3BmJzonXFxcXHVEODM1XFxcXHVERDU5JywnSG9wZic6J1xcXFx1MjEwRCcsJ2hvcmJhcic6J1xcXFx1MjAxNScsJ0hvcml6b250YWxMaW5lJzonXFxcXHUyNTAwJywnaHNjcic6J1xcXFx1RDgzNVxcXFx1RENCRCcsJ0hzY3InOidcXFxcdTIxMEInLCdoc2xhc2gnOidcXFxcdTIxMEYnLCdoc3Ryb2snOidcXFxcdTAxMjcnLCdIc3Ryb2snOidcXFxcdTAxMjYnLCdIdW1wRG93bkh1bXAnOidcXFxcdTIyNEUnLCdIdW1wRXF1YWwnOidcXFxcdTIyNEYnLCdoeWJ1bGwnOidcXFxcdTIwNDMnLCdoeXBoZW4nOidcXFxcdTIwMTAnLCdpYWN1dGUnOidcXFxceEVEJywnSWFjdXRlJzonXFxcXHhDRCcsJ2ljJzonXFxcXHUyMDYzJywnaWNpcmMnOidcXFxceEVFJywnSWNpcmMnOidcXFxceENFJywnaWN5JzonXFxcXHUwNDM4JywnSWN5JzonXFxcXHUwNDE4JywnSWRvdCc6J1xcXFx1MDEzMCcsJ2llY3knOidcXFxcdTA0MzUnLCdJRWN5JzonXFxcXHUwNDE1JywnaWV4Y2wnOidcXFxceEExJywnaWZmJzonXFxcXHUyMUQ0JywnaWZyJzonXFxcXHVEODM1XFxcXHVERDI2JywnSWZyJzonXFxcXHUyMTExJywnaWdyYXZlJzonXFxcXHhFQycsJ0lncmF2ZSc6J1xcXFx4Q0MnLCdpaSc6J1xcXFx1MjE0OCcsJ2lpaWludCc6J1xcXFx1MkEwQycsJ2lpaW50JzonXFxcXHUyMjJEJywnaWluZmluJzonXFxcXHUyOURDJywnaWlvdGEnOidcXFxcdTIxMjknLCdpamxpZyc6J1xcXFx1MDEzMycsJ0lKbGlnJzonXFxcXHUwMTMyJywnSW0nOidcXFxcdTIxMTEnLCdpbWFjcic6J1xcXFx1MDEyQicsJ0ltYWNyJzonXFxcXHUwMTJBJywnaW1hZ2UnOidcXFxcdTIxMTEnLCdJbWFnaW5hcnlJJzonXFxcXHUyMTQ4JywnaW1hZ2xpbmUnOidcXFxcdTIxMTAnLCdpbWFncGFydCc6J1xcXFx1MjExMScsJ2ltYXRoJzonXFxcXHUwMTMxJywnaW1vZic6J1xcXFx1MjJCNycsJ2ltcGVkJzonXFxcXHUwMUI1JywnSW1wbGllcyc6J1xcXFx1MjFEMicsJ2luJzonXFxcXHUyMjA4JywnaW5jYXJlJzonXFxcXHUyMTA1JywnaW5maW4nOidcXFxcdTIyMUUnLCdpbmZpbnRpZSc6J1xcXFx1MjlERCcsJ2lub2RvdCc6J1xcXFx1MDEzMScsJ2ludCc6J1xcXFx1MjIyQicsJ0ludCc6J1xcXFx1MjIyQycsJ2ludGNhbCc6J1xcXFx1MjJCQScsJ2ludGVnZXJzJzonXFxcXHUyMTI0JywnSW50ZWdyYWwnOidcXFxcdTIyMkInLCdpbnRlcmNhbCc6J1xcXFx1MjJCQScsJ0ludGVyc2VjdGlvbic6J1xcXFx1MjJDMicsJ2ludGxhcmhrJzonXFxcXHUyQTE3JywnaW50cHJvZCc6J1xcXFx1MkEzQycsJ0ludmlzaWJsZUNvbW1hJzonXFxcXHUyMDYzJywnSW52aXNpYmxlVGltZXMnOidcXFxcdTIwNjInLCdpb2N5JzonXFxcXHUwNDUxJywnSU9jeSc6J1xcXFx1MDQwMScsJ2lvZ29uJzonXFxcXHUwMTJGJywnSW9nb24nOidcXFxcdTAxMkUnLCdpb3BmJzonXFxcXHVEODM1XFxcXHVERDVBJywnSW9wZic6J1xcXFx1RDgzNVxcXFx1REQ0MCcsJ2lvdGEnOidcXFxcdTAzQjknLCdJb3RhJzonXFxcXHUwMzk5JywnaXByb2QnOidcXFxcdTJBM0MnLCdpcXVlc3QnOidcXFxceEJGJywnaXNjcic6J1xcXFx1RDgzNVxcXFx1RENCRScsJ0lzY3InOidcXFxcdTIxMTAnLCdpc2luJzonXFxcXHUyMjA4JywnaXNpbmRvdCc6J1xcXFx1MjJGNScsJ2lzaW5FJzonXFxcXHUyMkY5JywnaXNpbnMnOidcXFxcdTIyRjQnLCdpc2luc3YnOidcXFxcdTIyRjMnLCdpc2ludic6J1xcXFx1MjIwOCcsJ2l0JzonXFxcXHUyMDYyJywnaXRpbGRlJzonXFxcXHUwMTI5JywnSXRpbGRlJzonXFxcXHUwMTI4JywnaXVrY3knOidcXFxcdTA0NTYnLCdJdWtjeSc6J1xcXFx1MDQwNicsJ2l1bWwnOidcXFxceEVGJywnSXVtbCc6J1xcXFx4Q0YnLCdqY2lyYyc6J1xcXFx1MDEzNScsJ0pjaXJjJzonXFxcXHUwMTM0JywnamN5JzonXFxcXHUwNDM5JywnSmN5JzonXFxcXHUwNDE5JywnamZyJzonXFxcXHVEODM1XFxcXHVERDI3JywnSmZyJzonXFxcXHVEODM1XFxcXHVERDBEJywnam1hdGgnOidcXFxcdTAyMzcnLCdqb3BmJzonXFxcXHVEODM1XFxcXHVERDVCJywnSm9wZic6J1xcXFx1RDgzNVxcXFx1REQ0MScsJ2pzY3InOidcXFxcdUQ4MzVcXFxcdURDQkYnLCdKc2NyJzonXFxcXHVEODM1XFxcXHVEQ0E1JywnanNlcmN5JzonXFxcXHUwNDU4JywnSnNlcmN5JzonXFxcXHUwNDA4JywnanVrY3knOidcXFxcdTA0NTQnLCdKdWtjeSc6J1xcXFx1MDQwNCcsJ2thcHBhJzonXFxcXHUwM0JBJywnS2FwcGEnOidcXFxcdTAzOUEnLCdrYXBwYXYnOidcXFxcdTAzRjAnLCdrY2VkaWwnOidcXFxcdTAxMzcnLCdLY2VkaWwnOidcXFxcdTAxMzYnLCdrY3knOidcXFxcdTA0M0EnLCdLY3knOidcXFxcdTA0MUEnLCdrZnInOidcXFxcdUQ4MzVcXFxcdUREMjgnLCdLZnInOidcXFxcdUQ4MzVcXFxcdUREMEUnLCdrZ3JlZW4nOidcXFxcdTAxMzgnLCdraGN5JzonXFxcXHUwNDQ1JywnS0hjeSc6J1xcXFx1MDQyNScsJ2tqY3knOidcXFxcdTA0NUMnLCdLSmN5JzonXFxcXHUwNDBDJywna29wZic6J1xcXFx1RDgzNVxcXFx1REQ1QycsJ0tvcGYnOidcXFxcdUQ4MzVcXFxcdURENDInLCdrc2NyJzonXFxcXHVEODM1XFxcXHVEQ0MwJywnS3Njcic6J1xcXFx1RDgzNVxcXFx1RENBNicsJ2xBYXJyJzonXFxcXHUyMURBJywnbGFjdXRlJzonXFxcXHUwMTNBJywnTGFjdXRlJzonXFxcXHUwMTM5JywnbGFlbXB0eXYnOidcXFxcdTI5QjQnLCdsYWdyYW4nOidcXFxcdTIxMTInLCdsYW1iZGEnOidcXFxcdTAzQkInLCdMYW1iZGEnOidcXFxcdTAzOUInLCdsYW5nJzonXFxcXHUyN0U4JywnTGFuZyc6J1xcXFx1MjdFQScsJ2xhbmdkJzonXFxcXHUyOTkxJywnbGFuZ2xlJzonXFxcXHUyN0U4JywnbGFwJzonXFxcXHUyQTg1JywnTGFwbGFjZXRyZic6J1xcXFx1MjExMicsJ2xhcXVvJzonXFxcXHhBQicsJ2xhcnInOidcXFxcdTIxOTAnLCdsQXJyJzonXFxcXHUyMUQwJywnTGFycic6J1xcXFx1MjE5RScsJ2xhcnJiJzonXFxcXHUyMUU0JywnbGFycmJmcyc6J1xcXFx1MjkxRicsJ2xhcnJmcyc6J1xcXFx1MjkxRCcsJ2xhcnJoayc6J1xcXFx1MjFBOScsJ2xhcnJscCc6J1xcXFx1MjFBQicsJ2xhcnJwbCc6J1xcXFx1MjkzOScsJ2xhcnJzaW0nOidcXFxcdTI5NzMnLCdsYXJydGwnOidcXFxcdTIxQTInLCdsYXQnOidcXFxcdTJBQUInLCdsYXRhaWwnOidcXFxcdTI5MTknLCdsQXRhaWwnOidcXFxcdTI5MUInLCdsYXRlJzonXFxcXHUyQUFEJywnbGF0ZXMnOidcXFxcdTJBQURcXFxcdUZFMDAnLCdsYmFycic6J1xcXFx1MjkwQycsJ2xCYXJyJzonXFxcXHUyOTBFJywnbGJicmsnOidcXFxcdTI3NzInLCdsYnJhY2UnOid7JywnbGJyYWNrJzonWycsJ2xicmtlJzonXFxcXHUyOThCJywnbGJya3NsZCc6J1xcXFx1Mjk4RicsJ2xicmtzbHUnOidcXFxcdTI5OEQnLCdsY2Fyb24nOidcXFxcdTAxM0UnLCdMY2Fyb24nOidcXFxcdTAxM0QnLCdsY2VkaWwnOidcXFxcdTAxM0MnLCdMY2VkaWwnOidcXFxcdTAxM0InLCdsY2VpbCc6J1xcXFx1MjMwOCcsJ2xjdWInOid7JywnbGN5JzonXFxcXHUwNDNCJywnTGN5JzonXFxcXHUwNDFCJywnbGRjYSc6J1xcXFx1MjkzNicsJ2xkcXVvJzonXFxcXHUyMDFDJywnbGRxdW9yJzonXFxcXHUyMDFFJywnbGRyZGhhcic6J1xcXFx1Mjk2NycsJ2xkcnVzaGFyJzonXFxcXHUyOTRCJywnbGRzaCc6J1xcXFx1MjFCMicsJ2xlJzonXFxcXHUyMjY0JywnbEUnOidcXFxcdTIyNjYnLCdMZWZ0QW5nbGVCcmFja2V0JzonXFxcXHUyN0U4JywnbGVmdGFycm93JzonXFxcXHUyMTkwJywnTGVmdGFycm93JzonXFxcXHUyMUQwJywnTGVmdEFycm93JzonXFxcXHUyMTkwJywnTGVmdEFycm93QmFyJzonXFxcXHUyMUU0JywnTGVmdEFycm93UmlnaHRBcnJvdyc6J1xcXFx1MjFDNicsJ2xlZnRhcnJvd3RhaWwnOidcXFxcdTIxQTInLCdMZWZ0Q2VpbGluZyc6J1xcXFx1MjMwOCcsJ0xlZnREb3VibGVCcmFja2V0JzonXFxcXHUyN0U2JywnTGVmdERvd25UZWVWZWN0b3InOidcXFxcdTI5NjEnLCdMZWZ0RG93blZlY3Rvcic6J1xcXFx1MjFDMycsJ0xlZnREb3duVmVjdG9yQmFyJzonXFxcXHUyOTU5JywnTGVmdEZsb29yJzonXFxcXHUyMzBBJywnbGVmdGhhcnBvb25kb3duJzonXFxcXHUyMUJEJywnbGVmdGhhcnBvb251cCc6J1xcXFx1MjFCQycsJ2xlZnRsZWZ0YXJyb3dzJzonXFxcXHUyMUM3JywnbGVmdHJpZ2h0YXJyb3cnOidcXFxcdTIxOTQnLCdMZWZ0cmlnaHRhcnJvdyc6J1xcXFx1MjFENCcsJ0xlZnRSaWdodEFycm93JzonXFxcXHUyMTk0JywnbGVmdHJpZ2h0YXJyb3dzJzonXFxcXHUyMUM2JywnbGVmdHJpZ2h0aGFycG9vbnMnOidcXFxcdTIxQ0InLCdsZWZ0cmlnaHRzcXVpZ2Fycm93JzonXFxcXHUyMUFEJywnTGVmdFJpZ2h0VmVjdG9yJzonXFxcXHUyOTRFJywnTGVmdFRlZSc6J1xcXFx1MjJBMycsJ0xlZnRUZWVBcnJvdyc6J1xcXFx1MjFBNCcsJ0xlZnRUZWVWZWN0b3InOidcXFxcdTI5NUEnLCdsZWZ0dGhyZWV0aW1lcyc6J1xcXFx1MjJDQicsJ0xlZnRUcmlhbmdsZSc6J1xcXFx1MjJCMicsJ0xlZnRUcmlhbmdsZUJhcic6J1xcXFx1MjlDRicsJ0xlZnRUcmlhbmdsZUVxdWFsJzonXFxcXHUyMkI0JywnTGVmdFVwRG93blZlY3Rvcic6J1xcXFx1Mjk1MScsJ0xlZnRVcFRlZVZlY3Rvcic6J1xcXFx1Mjk2MCcsJ0xlZnRVcFZlY3Rvcic6J1xcXFx1MjFCRicsJ0xlZnRVcFZlY3RvckJhcic6J1xcXFx1Mjk1OCcsJ0xlZnRWZWN0b3InOidcXFxcdTIxQkMnLCdMZWZ0VmVjdG9yQmFyJzonXFxcXHUyOTUyJywnbGVnJzonXFxcXHUyMkRBJywnbEVnJzonXFxcXHUyQThCJywnbGVxJzonXFxcXHUyMjY0JywnbGVxcSc6J1xcXFx1MjI2NicsJ2xlcXNsYW50JzonXFxcXHUyQTdEJywnbGVzJzonXFxcXHUyQTdEJywnbGVzY2MnOidcXFxcdTJBQTgnLCdsZXNkb3QnOidcXFxcdTJBN0YnLCdsZXNkb3RvJzonXFxcXHUyQTgxJywnbGVzZG90b3InOidcXFxcdTJBODMnLCdsZXNnJzonXFxcXHUyMkRBXFxcXHVGRTAwJywnbGVzZ2VzJzonXFxcXHUyQTkzJywnbGVzc2FwcHJveCc6J1xcXFx1MkE4NScsJ2xlc3Nkb3QnOidcXFxcdTIyRDYnLCdsZXNzZXFndHInOidcXFxcdTIyREEnLCdsZXNzZXFxZ3RyJzonXFxcXHUyQThCJywnTGVzc0VxdWFsR3JlYXRlcic6J1xcXFx1MjJEQScsJ0xlc3NGdWxsRXF1YWwnOidcXFxcdTIyNjYnLCdMZXNzR3JlYXRlcic6J1xcXFx1MjI3NicsJ2xlc3NndHInOidcXFxcdTIyNzYnLCdMZXNzTGVzcyc6J1xcXFx1MkFBMScsJ2xlc3NzaW0nOidcXFxcdTIyNzInLCdMZXNzU2xhbnRFcXVhbCc6J1xcXFx1MkE3RCcsJ0xlc3NUaWxkZSc6J1xcXFx1MjI3MicsJ2xmaXNodCc6J1xcXFx1Mjk3QycsJ2xmbG9vcic6J1xcXFx1MjMwQScsJ2xmcic6J1xcXFx1RDgzNVxcXFx1REQyOScsJ0xmcic6J1xcXFx1RDgzNVxcXFx1REQwRicsJ2xnJzonXFxcXHUyMjc2JywnbGdFJzonXFxcXHUyQTkxJywnbEhhcic6J1xcXFx1Mjk2MicsJ2xoYXJkJzonXFxcXHUyMUJEJywnbGhhcnUnOidcXFxcdTIxQkMnLCdsaGFydWwnOidcXFxcdTI5NkEnLCdsaGJsayc6J1xcXFx1MjU4NCcsJ2xqY3knOidcXFxcdTA0NTknLCdMSmN5JzonXFxcXHUwNDA5JywnbGwnOidcXFxcdTIyNkEnLCdMbCc6J1xcXFx1MjJEOCcsJ2xsYXJyJzonXFxcXHUyMUM3JywnbGxjb3JuZXInOidcXFxcdTIzMUUnLCdMbGVmdGFycm93JzonXFxcXHUyMURBJywnbGxoYXJkJzonXFxcXHUyOTZCJywnbGx0cmknOidcXFxcdTI1RkEnLCdsbWlkb3QnOidcXFxcdTAxNDAnLCdMbWlkb3QnOidcXFxcdTAxM0YnLCdsbW91c3QnOidcXFxcdTIzQjAnLCdsbW91c3RhY2hlJzonXFxcXHUyM0IwJywnbG5hcCc6J1xcXFx1MkE4OScsJ2xuYXBwcm94JzonXFxcXHUyQTg5JywnbG5lJzonXFxcXHUyQTg3JywnbG5FJzonXFxcXHUyMjY4JywnbG5lcSc6J1xcXFx1MkE4NycsJ2xuZXFxJzonXFxcXHUyMjY4JywnbG5zaW0nOidcXFxcdTIyRTYnLCdsb2FuZyc6J1xcXFx1MjdFQycsJ2xvYXJyJzonXFxcXHUyMUZEJywnbG9icmsnOidcXFxcdTI3RTYnLCdsb25nbGVmdGFycm93JzonXFxcXHUyN0Y1JywnTG9uZ2xlZnRhcnJvdyc6J1xcXFx1MjdGOCcsJ0xvbmdMZWZ0QXJyb3cnOidcXFxcdTI3RjUnLCdsb25nbGVmdHJpZ2h0YXJyb3cnOidcXFxcdTI3RjcnLCdMb25nbGVmdHJpZ2h0YXJyb3cnOidcXFxcdTI3RkEnLCdMb25nTGVmdFJpZ2h0QXJyb3cnOidcXFxcdTI3RjcnLCdsb25nbWFwc3RvJzonXFxcXHUyN0ZDJywnbG9uZ3JpZ2h0YXJyb3cnOidcXFxcdTI3RjYnLCdMb25ncmlnaHRhcnJvdyc6J1xcXFx1MjdGOScsJ0xvbmdSaWdodEFycm93JzonXFxcXHUyN0Y2JywnbG9vcGFycm93bGVmdCc6J1xcXFx1MjFBQicsJ2xvb3BhcnJvd3JpZ2h0JzonXFxcXHUyMUFDJywnbG9wYXInOidcXFxcdTI5ODUnLCdsb3BmJzonXFxcXHVEODM1XFxcXHVERDVEJywnTG9wZic6J1xcXFx1RDgzNVxcXFx1REQ0MycsJ2xvcGx1cyc6J1xcXFx1MkEyRCcsJ2xvdGltZXMnOidcXFxcdTJBMzQnLCdsb3dhc3QnOidcXFxcdTIyMTcnLCdsb3diYXInOidfJywnTG93ZXJMZWZ0QXJyb3cnOidcXFxcdTIxOTknLCdMb3dlclJpZ2h0QXJyb3cnOidcXFxcdTIxOTgnLCdsb3onOidcXFxcdTI1Q0EnLCdsb3plbmdlJzonXFxcXHUyNUNBJywnbG96Zic6J1xcXFx1MjlFQicsJ2xwYXInOicoJywnbHBhcmx0JzonXFxcXHUyOTkzJywnbHJhcnInOidcXFxcdTIxQzYnLCdscmNvcm5lcic6J1xcXFx1MjMxRicsJ2xyaGFyJzonXFxcXHUyMUNCJywnbHJoYXJkJzonXFxcXHUyOTZEJywnbHJtJzonXFxcXHUyMDBFJywnbHJ0cmknOidcXFxcdTIyQkYnLCdsc2FxdW8nOidcXFxcdTIwMzknLCdsc2NyJzonXFxcXHVEODM1XFxcXHVEQ0MxJywnTHNjcic6J1xcXFx1MjExMicsJ2xzaCc6J1xcXFx1MjFCMCcsJ0xzaCc6J1xcXFx1MjFCMCcsJ2xzaW0nOidcXFxcdTIyNzInLCdsc2ltZSc6J1xcXFx1MkE4RCcsJ2xzaW1nJzonXFxcXHUyQThGJywnbHNxYic6J1snLCdsc3F1byc6J1xcXFx1MjAxOCcsJ2xzcXVvcic6J1xcXFx1MjAxQScsJ2xzdHJvayc6J1xcXFx1MDE0MicsJ0xzdHJvayc6J1xcXFx1MDE0MScsJ2x0JzonPCcsJ0x0JzonXFxcXHUyMjZBJywnTFQnOic8JywnbHRjYyc6J1xcXFx1MkFBNicsJ2x0Y2lyJzonXFxcXHUyQTc5JywnbHRkb3QnOidcXFxcdTIyRDYnLCdsdGhyZWUnOidcXFxcdTIyQ0InLCdsdGltZXMnOidcXFxcdTIyQzknLCdsdGxhcnInOidcXFxcdTI5NzYnLCdsdHF1ZXN0JzonXFxcXHUyQTdCJywnbHRyaSc6J1xcXFx1MjVDMycsJ2x0cmllJzonXFxcXHUyMkI0JywnbHRyaWYnOidcXFxcdTI1QzInLCdsdHJQYXInOidcXFxcdTI5OTYnLCdsdXJkc2hhcic6J1xcXFx1Mjk0QScsJ2x1cnVoYXInOidcXFxcdTI5NjYnLCdsdmVydG5lcXEnOidcXFxcdTIyNjhcXFxcdUZFMDAnLCdsdm5FJzonXFxcXHUyMjY4XFxcXHVGRTAwJywnbWFjcic6J1xcXFx4QUYnLCdtYWxlJzonXFxcXHUyNjQyJywnbWFsdCc6J1xcXFx1MjcyMCcsJ21hbHRlc2UnOidcXFxcdTI3MjAnLCdtYXAnOidcXFxcdTIxQTYnLCdNYXAnOidcXFxcdTI5MDUnLCdtYXBzdG8nOidcXFxcdTIxQTYnLCdtYXBzdG9kb3duJzonXFxcXHUyMUE3JywnbWFwc3RvbGVmdCc6J1xcXFx1MjFBNCcsJ21hcHN0b3VwJzonXFxcXHUyMUE1JywnbWFya2VyJzonXFxcXHUyNUFFJywnbWNvbW1hJzonXFxcXHUyQTI5JywnbWN5JzonXFxcXHUwNDNDJywnTWN5JzonXFxcXHUwNDFDJywnbWRhc2gnOidcXFxcdTIwMTQnLCdtRERvdCc6J1xcXFx1MjIzQScsJ21lYXN1cmVkYW5nbGUnOidcXFxcdTIyMjEnLCdNZWRpdW1TcGFjZSc6J1xcXFx1MjA1RicsJ01lbGxpbnRyZic6J1xcXFx1MjEzMycsJ21mcic6J1xcXFx1RDgzNVxcXFx1REQyQScsJ01mcic6J1xcXFx1RDgzNVxcXFx1REQxMCcsJ21obyc6J1xcXFx1MjEyNycsJ21pY3JvJzonXFxcXHhCNScsJ21pZCc6J1xcXFx1MjIyMycsJ21pZGFzdCc6JyonLCdtaWRjaXInOidcXFxcdTJBRjAnLCdtaWRkb3QnOidcXFxceEI3JywnbWludXMnOidcXFxcdTIyMTInLCdtaW51c2InOidcXFxcdTIyOUYnLCdtaW51c2QnOidcXFxcdTIyMzgnLCdtaW51c2R1JzonXFxcXHUyQTJBJywnTWludXNQbHVzJzonXFxcXHUyMjEzJywnbWxjcCc6J1xcXFx1MkFEQicsJ21sZHInOidcXFxcdTIwMjYnLCdtbnBsdXMnOidcXFxcdTIyMTMnLCdtb2RlbHMnOidcXFxcdTIyQTcnLCdtb3BmJzonXFxcXHVEODM1XFxcXHVERDVFJywnTW9wZic6J1xcXFx1RDgzNVxcXFx1REQ0NCcsJ21wJzonXFxcXHUyMjEzJywnbXNjcic6J1xcXFx1RDgzNVxcXFx1RENDMicsJ01zY3InOidcXFxcdTIxMzMnLCdtc3Rwb3MnOidcXFxcdTIyM0UnLCdtdSc6J1xcXFx1MDNCQycsJ011JzonXFxcXHUwMzlDJywnbXVsdGltYXAnOidcXFxcdTIyQjgnLCdtdW1hcCc6J1xcXFx1MjJCOCcsJ25hYmxhJzonXFxcXHUyMjA3JywnbmFjdXRlJzonXFxcXHUwMTQ0JywnTmFjdXRlJzonXFxcXHUwMTQzJywnbmFuZyc6J1xcXFx1MjIyMFxcXFx1MjBEMicsJ25hcCc6J1xcXFx1MjI0OScsJ25hcEUnOidcXFxcdTJBNzBcXFxcdTAzMzgnLCduYXBpZCc6J1xcXFx1MjI0QlxcXFx1MDMzOCcsJ25hcG9zJzonXFxcXHUwMTQ5JywnbmFwcHJveCc6J1xcXFx1MjI0OScsJ25hdHVyJzonXFxcXHUyNjZFJywnbmF0dXJhbCc6J1xcXFx1MjY2RScsJ25hdHVyYWxzJzonXFxcXHUyMTE1JywnbmJzcCc6J1xcXFx4QTAnLCduYnVtcCc6J1xcXFx1MjI0RVxcXFx1MDMzOCcsJ25idW1wZSc6J1xcXFx1MjI0RlxcXFx1MDMzOCcsJ25jYXAnOidcXFxcdTJBNDMnLCduY2Fyb24nOidcXFxcdTAxNDgnLCdOY2Fyb24nOidcXFxcdTAxNDcnLCduY2VkaWwnOidcXFxcdTAxNDYnLCdOY2VkaWwnOidcXFxcdTAxNDUnLCduY29uZyc6J1xcXFx1MjI0NycsJ25jb25nZG90JzonXFxcXHUyQTZEXFxcXHUwMzM4JywnbmN1cCc6J1xcXFx1MkE0MicsJ25jeSc6J1xcXFx1MDQzRCcsJ05jeSc6J1xcXFx1MDQxRCcsJ25kYXNoJzonXFxcXHUyMDEzJywnbmUnOidcXFxcdTIyNjAnLCduZWFyaGsnOidcXFxcdTI5MjQnLCduZWFycic6J1xcXFx1MjE5NycsJ25lQXJyJzonXFxcXHUyMUQ3JywnbmVhcnJvdyc6J1xcXFx1MjE5NycsJ25lZG90JzonXFxcXHUyMjUwXFxcXHUwMzM4JywnTmVnYXRpdmVNZWRpdW1TcGFjZSc6J1xcXFx1MjAwQicsJ05lZ2F0aXZlVGhpY2tTcGFjZSc6J1xcXFx1MjAwQicsJ05lZ2F0aXZlVGhpblNwYWNlJzonXFxcXHUyMDBCJywnTmVnYXRpdmVWZXJ5VGhpblNwYWNlJzonXFxcXHUyMDBCJywnbmVxdWl2JzonXFxcXHUyMjYyJywnbmVzZWFyJzonXFxcXHUyOTI4JywnbmVzaW0nOidcXFxcdTIyNDJcXFxcdTAzMzgnLCdOZXN0ZWRHcmVhdGVyR3JlYXRlcic6J1xcXFx1MjI2QicsJ05lc3RlZExlc3NMZXNzJzonXFxcXHUyMjZBJywnTmV3TGluZSc6J1xcXFxuJywnbmV4aXN0JzonXFxcXHUyMjA0JywnbmV4aXN0cyc6J1xcXFx1MjIwNCcsJ25mcic6J1xcXFx1RDgzNVxcXFx1REQyQicsJ05mcic6J1xcXFx1RDgzNVxcXFx1REQxMScsJ25nZSc6J1xcXFx1MjI3MScsJ25nRSc6J1xcXFx1MjI2N1xcXFx1MDMzOCcsJ25nZXEnOidcXFxcdTIyNzEnLCduZ2VxcSc6J1xcXFx1MjI2N1xcXFx1MDMzOCcsJ25nZXFzbGFudCc6J1xcXFx1MkE3RVxcXFx1MDMzOCcsJ25nZXMnOidcXFxcdTJBN0VcXFxcdTAzMzgnLCduR2cnOidcXFxcdTIyRDlcXFxcdTAzMzgnLCduZ3NpbSc6J1xcXFx1MjI3NScsJ25ndCc6J1xcXFx1MjI2RicsJ25HdCc6J1xcXFx1MjI2QlxcXFx1MjBEMicsJ25ndHInOidcXFxcdTIyNkYnLCduR3R2JzonXFxcXHUyMjZCXFxcXHUwMzM4JywnbmhhcnInOidcXFxcdTIxQUUnLCduaEFycic6J1xcXFx1MjFDRScsJ25ocGFyJzonXFxcXHUyQUYyJywnbmknOidcXFxcdTIyMEInLCduaXMnOidcXFxcdTIyRkMnLCduaXNkJzonXFxcXHUyMkZBJywnbml2JzonXFxcXHUyMjBCJywnbmpjeSc6J1xcXFx1MDQ1QScsJ05KY3knOidcXFxcdTA0MEEnLCdubGFycic6J1xcXFx1MjE5QScsJ25sQXJyJzonXFxcXHUyMUNEJywnbmxkcic6J1xcXFx1MjAyNScsJ25sZSc6J1xcXFx1MjI3MCcsJ25sRSc6J1xcXFx1MjI2NlxcXFx1MDMzOCcsJ25sZWZ0YXJyb3cnOidcXFxcdTIxOUEnLCduTGVmdGFycm93JzonXFxcXHUyMUNEJywnbmxlZnRyaWdodGFycm93JzonXFxcXHUyMUFFJywnbkxlZnRyaWdodGFycm93JzonXFxcXHUyMUNFJywnbmxlcSc6J1xcXFx1MjI3MCcsJ25sZXFxJzonXFxcXHUyMjY2XFxcXHUwMzM4JywnbmxlcXNsYW50JzonXFxcXHUyQTdEXFxcXHUwMzM4Jywnbmxlcyc6J1xcXFx1MkE3RFxcXFx1MDMzOCcsJ25sZXNzJzonXFxcXHUyMjZFJywnbkxsJzonXFxcXHUyMkQ4XFxcXHUwMzM4JywnbmxzaW0nOidcXFxcdTIyNzQnLCdubHQnOidcXFxcdTIyNkUnLCduTHQnOidcXFxcdTIyNkFcXFxcdTIwRDInLCdubHRyaSc6J1xcXFx1MjJFQScsJ25sdHJpZSc6J1xcXFx1MjJFQycsJ25MdHYnOidcXFxcdTIyNkFcXFxcdTAzMzgnLCdubWlkJzonXFxcXHUyMjI0JywnTm9CcmVhayc6J1xcXFx1MjA2MCcsJ05vbkJyZWFraW5nU3BhY2UnOidcXFxceEEwJywnbm9wZic6J1xcXFx1RDgzNVxcXFx1REQ1RicsJ05vcGYnOidcXFxcdTIxMTUnLCdub3QnOidcXFxceEFDJywnTm90JzonXFxcXHUyQUVDJywnTm90Q29uZ3J1ZW50JzonXFxcXHUyMjYyJywnTm90Q3VwQ2FwJzonXFxcXHUyMjZEJywnTm90RG91YmxlVmVydGljYWxCYXInOidcXFxcdTIyMjYnLCdOb3RFbGVtZW50JzonXFxcXHUyMjA5JywnTm90RXF1YWwnOidcXFxcdTIyNjAnLCdOb3RFcXVhbFRpbGRlJzonXFxcXHUyMjQyXFxcXHUwMzM4JywnTm90RXhpc3RzJzonXFxcXHUyMjA0JywnTm90R3JlYXRlcic6J1xcXFx1MjI2RicsJ05vdEdyZWF0ZXJFcXVhbCc6J1xcXFx1MjI3MScsJ05vdEdyZWF0ZXJGdWxsRXF1YWwnOidcXFxcdTIyNjdcXFxcdTAzMzgnLCdOb3RHcmVhdGVyR3JlYXRlcic6J1xcXFx1MjI2QlxcXFx1MDMzOCcsJ05vdEdyZWF0ZXJMZXNzJzonXFxcXHUyMjc5JywnTm90R3JlYXRlclNsYW50RXF1YWwnOidcXFxcdTJBN0VcXFxcdTAzMzgnLCdOb3RHcmVhdGVyVGlsZGUnOidcXFxcdTIyNzUnLCdOb3RIdW1wRG93bkh1bXAnOidcXFxcdTIyNEVcXFxcdTAzMzgnLCdOb3RIdW1wRXF1YWwnOidcXFxcdTIyNEZcXFxcdTAzMzgnLCdub3Rpbic6J1xcXFx1MjIwOScsJ25vdGluZG90JzonXFxcXHUyMkY1XFxcXHUwMzM4Jywnbm90aW5FJzonXFxcXHUyMkY5XFxcXHUwMzM4Jywnbm90aW52YSc6J1xcXFx1MjIwOScsJ25vdGludmInOidcXFxcdTIyRjcnLCdub3RpbnZjJzonXFxcXHUyMkY2JywnTm90TGVmdFRyaWFuZ2xlJzonXFxcXHUyMkVBJywnTm90TGVmdFRyaWFuZ2xlQmFyJzonXFxcXHUyOUNGXFxcXHUwMzM4JywnTm90TGVmdFRyaWFuZ2xlRXF1YWwnOidcXFxcdTIyRUMnLCdOb3RMZXNzJzonXFxcXHUyMjZFJywnTm90TGVzc0VxdWFsJzonXFxcXHUyMjcwJywnTm90TGVzc0dyZWF0ZXInOidcXFxcdTIyNzgnLCdOb3RMZXNzTGVzcyc6J1xcXFx1MjI2QVxcXFx1MDMzOCcsJ05vdExlc3NTbGFudEVxdWFsJzonXFxcXHUyQTdEXFxcXHUwMzM4JywnTm90TGVzc1RpbGRlJzonXFxcXHUyMjc0JywnTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInOidcXFxcdTJBQTJcXFxcdTAzMzgnLCdOb3ROZXN0ZWRMZXNzTGVzcyc6J1xcXFx1MkFBMVxcXFx1MDMzOCcsJ25vdG5pJzonXFxcXHUyMjBDJywnbm90bml2YSc6J1xcXFx1MjIwQycsJ25vdG5pdmInOidcXFxcdTIyRkUnLCdub3RuaXZjJzonXFxcXHUyMkZEJywnTm90UHJlY2VkZXMnOidcXFxcdTIyODAnLCdOb3RQcmVjZWRlc0VxdWFsJzonXFxcXHUyQUFGXFxcXHUwMzM4JywnTm90UHJlY2VkZXNTbGFudEVxdWFsJzonXFxcXHUyMkUwJywnTm90UmV2ZXJzZUVsZW1lbnQnOidcXFxcdTIyMEMnLCdOb3RSaWdodFRyaWFuZ2xlJzonXFxcXHUyMkVCJywnTm90UmlnaHRUcmlhbmdsZUJhcic6J1xcXFx1MjlEMFxcXFx1MDMzOCcsJ05vdFJpZ2h0VHJpYW5nbGVFcXVhbCc6J1xcXFx1MjJFRCcsJ05vdFNxdWFyZVN1YnNldCc6J1xcXFx1MjI4RlxcXFx1MDMzOCcsJ05vdFNxdWFyZVN1YnNldEVxdWFsJzonXFxcXHUyMkUyJywnTm90U3F1YXJlU3VwZXJzZXQnOidcXFxcdTIyOTBcXFxcdTAzMzgnLCdOb3RTcXVhcmVTdXBlcnNldEVxdWFsJzonXFxcXHUyMkUzJywnTm90U3Vic2V0JzonXFxcXHUyMjgyXFxcXHUyMEQyJywnTm90U3Vic2V0RXF1YWwnOidcXFxcdTIyODgnLCdOb3RTdWNjZWVkcyc6J1xcXFx1MjI4MScsJ05vdFN1Y2NlZWRzRXF1YWwnOidcXFxcdTJBQjBcXFxcdTAzMzgnLCdOb3RTdWNjZWVkc1NsYW50RXF1YWwnOidcXFxcdTIyRTEnLCdOb3RTdWNjZWVkc1RpbGRlJzonXFxcXHUyMjdGXFxcXHUwMzM4JywnTm90U3VwZXJzZXQnOidcXFxcdTIyODNcXFxcdTIwRDInLCdOb3RTdXBlcnNldEVxdWFsJzonXFxcXHUyMjg5JywnTm90VGlsZGUnOidcXFxcdTIyNDEnLCdOb3RUaWxkZUVxdWFsJzonXFxcXHUyMjQ0JywnTm90VGlsZGVGdWxsRXF1YWwnOidcXFxcdTIyNDcnLCdOb3RUaWxkZVRpbGRlJzonXFxcXHUyMjQ5JywnTm90VmVydGljYWxCYXInOidcXFxcdTIyMjQnLCducGFyJzonXFxcXHUyMjI2JywnbnBhcmFsbGVsJzonXFxcXHUyMjI2JywnbnBhcnNsJzonXFxcXHUyQUZEXFxcXHUyMEU1JywnbnBhcnQnOidcXFxcdTIyMDJcXFxcdTAzMzgnLCducG9saW50JzonXFxcXHUyQTE0JywnbnByJzonXFxcXHUyMjgwJywnbnByY3VlJzonXFxcXHUyMkUwJywnbnByZSc6J1xcXFx1MkFBRlxcXFx1MDMzOCcsJ25wcmVjJzonXFxcXHUyMjgwJywnbnByZWNlcSc6J1xcXFx1MkFBRlxcXFx1MDMzOCcsJ25yYXJyJzonXFxcXHUyMTlCJywnbnJBcnInOidcXFxcdTIxQ0YnLCducmFycmMnOidcXFxcdTI5MzNcXFxcdTAzMzgnLCducmFycncnOidcXFxcdTIxOURcXFxcdTAzMzgnLCducmlnaHRhcnJvdyc6J1xcXFx1MjE5QicsJ25SaWdodGFycm93JzonXFxcXHUyMUNGJywnbnJ0cmknOidcXFxcdTIyRUInLCducnRyaWUnOidcXFxcdTIyRUQnLCduc2MnOidcXFxcdTIyODEnLCduc2NjdWUnOidcXFxcdTIyRTEnLCduc2NlJzonXFxcXHUyQUIwXFxcXHUwMzM4JywnbnNjcic6J1xcXFx1RDgzNVxcXFx1RENDMycsJ05zY3InOidcXFxcdUQ4MzVcXFxcdURDQTknLCduc2hvcnRtaWQnOidcXFxcdTIyMjQnLCduc2hvcnRwYXJhbGxlbCc6J1xcXFx1MjIyNicsJ25zaW0nOidcXFxcdTIyNDEnLCduc2ltZSc6J1xcXFx1MjI0NCcsJ25zaW1lcSc6J1xcXFx1MjI0NCcsJ25zbWlkJzonXFxcXHUyMjI0JywnbnNwYXInOidcXFxcdTIyMjYnLCduc3FzdWJlJzonXFxcXHUyMkUyJywnbnNxc3VwZSc6J1xcXFx1MjJFMycsJ25zdWInOidcXFxcdTIyODQnLCduc3ViZSc6J1xcXFx1MjI4OCcsJ25zdWJFJzonXFxcXHUyQUM1XFxcXHUwMzM4JywnbnN1YnNldCc6J1xcXFx1MjI4MlxcXFx1MjBEMicsJ25zdWJzZXRlcSc6J1xcXFx1MjI4OCcsJ25zdWJzZXRlcXEnOidcXFxcdTJBQzVcXFxcdTAzMzgnLCduc3VjYyc6J1xcXFx1MjI4MScsJ25zdWNjZXEnOidcXFxcdTJBQjBcXFxcdTAzMzgnLCduc3VwJzonXFxcXHUyMjg1JywnbnN1cGUnOidcXFxcdTIyODknLCduc3VwRSc6J1xcXFx1MkFDNlxcXFx1MDMzOCcsJ25zdXBzZXQnOidcXFxcdTIyODNcXFxcdTIwRDInLCduc3Vwc2V0ZXEnOidcXFxcdTIyODknLCduc3Vwc2V0ZXFxJzonXFxcXHUyQUM2XFxcXHUwMzM4JywnbnRnbCc6J1xcXFx1MjI3OScsJ250aWxkZSc6J1xcXFx4RjEnLCdOdGlsZGUnOidcXFxceEQxJywnbnRsZyc6J1xcXFx1MjI3OCcsJ250cmlhbmdsZWxlZnQnOidcXFxcdTIyRUEnLCdudHJpYW5nbGVsZWZ0ZXEnOidcXFxcdTIyRUMnLCdudHJpYW5nbGVyaWdodCc6J1xcXFx1MjJFQicsJ250cmlhbmdsZXJpZ2h0ZXEnOidcXFxcdTIyRUQnLCdudSc6J1xcXFx1MDNCRCcsJ051JzonXFxcXHUwMzlEJywnbnVtJzonIycsJ251bWVybyc6J1xcXFx1MjExNicsJ251bXNwJzonXFxcXHUyMDA3JywnbnZhcCc6J1xcXFx1MjI0RFxcXFx1MjBEMicsJ252ZGFzaCc6J1xcXFx1MjJBQycsJ252RGFzaCc6J1xcXFx1MjJBRCcsJ25WZGFzaCc6J1xcXFx1MjJBRScsJ25WRGFzaCc6J1xcXFx1MjJBRicsJ252Z2UnOidcXFxcdTIyNjVcXFxcdTIwRDInLCdudmd0JzonPlxcXFx1MjBEMicsJ252SGFycic6J1xcXFx1MjkwNCcsJ252aW5maW4nOidcXFxcdTI5REUnLCdudmxBcnInOidcXFxcdTI5MDInLCdudmxlJzonXFxcXHUyMjY0XFxcXHUyMEQyJywnbnZsdCc6JzxcXFxcdTIwRDInLCdudmx0cmllJzonXFxcXHUyMkI0XFxcXHUyMEQyJywnbnZyQXJyJzonXFxcXHUyOTAzJywnbnZydHJpZSc6J1xcXFx1MjJCNVxcXFx1MjBEMicsJ252c2ltJzonXFxcXHUyMjNDXFxcXHUyMEQyJywnbndhcmhrJzonXFxcXHUyOTIzJywnbndhcnInOidcXFxcdTIxOTYnLCdud0Fycic6J1xcXFx1MjFENicsJ253YXJyb3cnOidcXFxcdTIxOTYnLCdud25lYXInOidcXFxcdTI5MjcnLCdvYWN1dGUnOidcXFxceEYzJywnT2FjdXRlJzonXFxcXHhEMycsJ29hc3QnOidcXFxcdTIyOUInLCdvY2lyJzonXFxcXHUyMjlBJywnb2NpcmMnOidcXFxceEY0JywnT2NpcmMnOidcXFxceEQ0Jywnb2N5JzonXFxcXHUwNDNFJywnT2N5JzonXFxcXHUwNDFFJywnb2Rhc2gnOidcXFxcdTIyOUQnLCdvZGJsYWMnOidcXFxcdTAxNTEnLCdPZGJsYWMnOidcXFxcdTAxNTAnLCdvZGl2JzonXFxcXHUyQTM4Jywnb2RvdCc6J1xcXFx1MjI5OScsJ29kc29sZCc6J1xcXFx1MjlCQycsJ29lbGlnJzonXFxcXHUwMTUzJywnT0VsaWcnOidcXFxcdTAxNTInLCdvZmNpcic6J1xcXFx1MjlCRicsJ29mcic6J1xcXFx1RDgzNVxcXFx1REQyQycsJ09mcic6J1xcXFx1RDgzNVxcXFx1REQxMicsJ29nb24nOidcXFxcdTAyREInLCdvZ3JhdmUnOidcXFxceEYyJywnT2dyYXZlJzonXFxcXHhEMicsJ29ndCc6J1xcXFx1MjlDMScsJ29oYmFyJzonXFxcXHUyOUI1Jywnb2htJzonXFxcXHUwM0E5Jywnb2ludCc6J1xcXFx1MjIyRScsJ29sYXJyJzonXFxcXHUyMUJBJywnb2xjaXInOidcXFxcdTI5QkUnLCdvbGNyb3NzJzonXFxcXHUyOUJCJywnb2xpbmUnOidcXFxcdTIwM0UnLCdvbHQnOidcXFxcdTI5QzAnLCdvbWFjcic6J1xcXFx1MDE0RCcsJ09tYWNyJzonXFxcXHUwMTRDJywnb21lZ2EnOidcXFxcdTAzQzknLCdPbWVnYSc6J1xcXFx1MDNBOScsJ29taWNyb24nOidcXFxcdTAzQkYnLCdPbWljcm9uJzonXFxcXHUwMzlGJywnb21pZCc6J1xcXFx1MjlCNicsJ29taW51cyc6J1xcXFx1MjI5NicsJ29vcGYnOidcXFxcdUQ4MzVcXFxcdURENjAnLCdPb3BmJzonXFxcXHVEODM1XFxcXHVERDQ2Jywnb3Bhcic6J1xcXFx1MjlCNycsJ09wZW5DdXJseURvdWJsZVF1b3RlJzonXFxcXHUyMDFDJywnT3BlbkN1cmx5UXVvdGUnOidcXFxcdTIwMTgnLCdvcGVycCc6J1xcXFx1MjlCOScsJ29wbHVzJzonXFxcXHUyMjk1Jywnb3InOidcXFxcdTIyMjgnLCdPcic6J1xcXFx1MkE1NCcsJ29yYXJyJzonXFxcXHUyMUJCJywnb3JkJzonXFxcXHUyQTVEJywnb3JkZXInOidcXFxcdTIxMzQnLCdvcmRlcm9mJzonXFxcXHUyMTM0Jywnb3JkZic6J1xcXFx4QUEnLCdvcmRtJzonXFxcXHhCQScsJ29yaWdvZic6J1xcXFx1MjJCNicsJ29yb3InOidcXFxcdTJBNTYnLCdvcnNsb3BlJzonXFxcXHUyQTU3Jywnb3J2JzonXFxcXHUyQTVCJywnb1MnOidcXFxcdTI0QzgnLCdvc2NyJzonXFxcXHUyMTM0JywnT3Njcic6J1xcXFx1RDgzNVxcXFx1RENBQScsJ29zbGFzaCc6J1xcXFx4RjgnLCdPc2xhc2gnOidcXFxceEQ4Jywnb3NvbCc6J1xcXFx1MjI5OCcsJ290aWxkZSc6J1xcXFx4RjUnLCdPdGlsZGUnOidcXFxceEQ1Jywnb3RpbWVzJzonXFxcXHUyMjk3JywnT3RpbWVzJzonXFxcXHUyQTM3Jywnb3RpbWVzYXMnOidcXFxcdTJBMzYnLCdvdW1sJzonXFxcXHhGNicsJ091bWwnOidcXFxceEQ2Jywnb3ZiYXInOidcXFxcdTIzM0QnLCdPdmVyQmFyJzonXFxcXHUyMDNFJywnT3ZlckJyYWNlJzonXFxcXHUyM0RFJywnT3ZlckJyYWNrZXQnOidcXFxcdTIzQjQnLCdPdmVyUGFyZW50aGVzaXMnOidcXFxcdTIzREMnLCdwYXInOidcXFxcdTIyMjUnLCdwYXJhJzonXFxcXHhCNicsJ3BhcmFsbGVsJzonXFxcXHUyMjI1JywncGFyc2ltJzonXFxcXHUyQUYzJywncGFyc2wnOidcXFxcdTJBRkQnLCdwYXJ0JzonXFxcXHUyMjAyJywnUGFydGlhbEQnOidcXFxcdTIyMDInLCdwY3knOidcXFxcdTA0M0YnLCdQY3knOidcXFxcdTA0MUYnLCdwZXJjbnQnOiclJywncGVyaW9kJzonLicsJ3Blcm1pbCc6J1xcXFx1MjAzMCcsJ3BlcnAnOidcXFxcdTIyQTUnLCdwZXJ0ZW5rJzonXFxcXHUyMDMxJywncGZyJzonXFxcXHVEODM1XFxcXHVERDJEJywnUGZyJzonXFxcXHVEODM1XFxcXHVERDEzJywncGhpJzonXFxcXHUwM0M2JywnUGhpJzonXFxcXHUwM0E2JywncGhpdic6J1xcXFx1MDNENScsJ3BobW1hdCc6J1xcXFx1MjEzMycsJ3Bob25lJzonXFxcXHUyNjBFJywncGknOidcXFxcdTAzQzAnLCdQaSc6J1xcXFx1MDNBMCcsJ3BpdGNoZm9yayc6J1xcXFx1MjJENCcsJ3Bpdic6J1xcXFx1MDNENicsJ3BsYW5jayc6J1xcXFx1MjEwRicsJ3BsYW5ja2gnOidcXFxcdTIxMEUnLCdwbGFua3YnOidcXFxcdTIxMEYnLCdwbHVzJzonKycsJ3BsdXNhY2lyJzonXFxcXHUyQTIzJywncGx1c2InOidcXFxcdTIyOUUnLCdwbHVzY2lyJzonXFxcXHUyQTIyJywncGx1c2RvJzonXFxcXHUyMjE0JywncGx1c2R1JzonXFxcXHUyQTI1JywncGx1c2UnOidcXFxcdTJBNzInLCdQbHVzTWludXMnOidcXFxceEIxJywncGx1c21uJzonXFxcXHhCMScsJ3BsdXNzaW0nOidcXFxcdTJBMjYnLCdwbHVzdHdvJzonXFxcXHUyQTI3JywncG0nOidcXFxceEIxJywnUG9pbmNhcmVwbGFuZSc6J1xcXFx1MjEwQycsJ3BvaW50aW50JzonXFxcXHUyQTE1JywncG9wZic6J1xcXFx1RDgzNVxcXFx1REQ2MScsJ1BvcGYnOidcXFxcdTIxMTknLCdwb3VuZCc6J1xcXFx4QTMnLCdwcic6J1xcXFx1MjI3QScsJ1ByJzonXFxcXHUyQUJCJywncHJhcCc6J1xcXFx1MkFCNycsJ3ByY3VlJzonXFxcXHUyMjdDJywncHJlJzonXFxcXHUyQUFGJywncHJFJzonXFxcXHUyQUIzJywncHJlYyc6J1xcXFx1MjI3QScsJ3ByZWNhcHByb3gnOidcXFxcdTJBQjcnLCdwcmVjY3VybHllcSc6J1xcXFx1MjI3QycsJ1ByZWNlZGVzJzonXFxcXHUyMjdBJywnUHJlY2VkZXNFcXVhbCc6J1xcXFx1MkFBRicsJ1ByZWNlZGVzU2xhbnRFcXVhbCc6J1xcXFx1MjI3QycsJ1ByZWNlZGVzVGlsZGUnOidcXFxcdTIyN0UnLCdwcmVjZXEnOidcXFxcdTJBQUYnLCdwcmVjbmFwcHJveCc6J1xcXFx1MkFCOScsJ3ByZWNuZXFxJzonXFxcXHUyQUI1JywncHJlY25zaW0nOidcXFxcdTIyRTgnLCdwcmVjc2ltJzonXFxcXHUyMjdFJywncHJpbWUnOidcXFxcdTIwMzInLCdQcmltZSc6J1xcXFx1MjAzMycsJ3ByaW1lcyc6J1xcXFx1MjExOScsJ3BybmFwJzonXFxcXHUyQUI5JywncHJuRSc6J1xcXFx1MkFCNScsJ3BybnNpbSc6J1xcXFx1MjJFOCcsJ3Byb2QnOidcXFxcdTIyMEYnLCdQcm9kdWN0JzonXFxcXHUyMjBGJywncHJvZmFsYXInOidcXFxcdTIzMkUnLCdwcm9mbGluZSc6J1xcXFx1MjMxMicsJ3Byb2ZzdXJmJzonXFxcXHUyMzEzJywncHJvcCc6J1xcXFx1MjIxRCcsJ1Byb3BvcnRpb24nOidcXFxcdTIyMzcnLCdQcm9wb3J0aW9uYWwnOidcXFxcdTIyMUQnLCdwcm9wdG8nOidcXFxcdTIyMUQnLCdwcnNpbSc6J1xcXFx1MjI3RScsJ3BydXJlbCc6J1xcXFx1MjJCMCcsJ3BzY3InOidcXFxcdUQ4MzVcXFxcdURDQzUnLCdQc2NyJzonXFxcXHVEODM1XFxcXHVEQ0FCJywncHNpJzonXFxcXHUwM0M4JywnUHNpJzonXFxcXHUwM0E4JywncHVuY3NwJzonXFxcXHUyMDA4JywncWZyJzonXFxcXHVEODM1XFxcXHVERDJFJywnUWZyJzonXFxcXHVEODM1XFxcXHVERDE0JywncWludCc6J1xcXFx1MkEwQycsJ3FvcGYnOidcXFxcdUQ4MzVcXFxcdURENjInLCdRb3BmJzonXFxcXHUyMTFBJywncXByaW1lJzonXFxcXHUyMDU3JywncXNjcic6J1xcXFx1RDgzNVxcXFx1RENDNicsJ1FzY3InOidcXFxcdUQ4MzVcXFxcdURDQUMnLCdxdWF0ZXJuaW9ucyc6J1xcXFx1MjEwRCcsJ3F1YXRpbnQnOidcXFxcdTJBMTYnLCdxdWVzdCc6Jz8nLCdxdWVzdGVxJzonXFxcXHUyMjVGJywncXVvdCc6J1xcXCInLCdRVU9UJzonXFxcIicsJ3JBYXJyJzonXFxcXHUyMURCJywncmFjZSc6J1xcXFx1MjIzRFxcXFx1MDMzMScsJ3JhY3V0ZSc6J1xcXFx1MDE1NScsJ1JhY3V0ZSc6J1xcXFx1MDE1NCcsJ3JhZGljJzonXFxcXHUyMjFBJywncmFlbXB0eXYnOidcXFxcdTI5QjMnLCdyYW5nJzonXFxcXHUyN0U5JywnUmFuZyc6J1xcXFx1MjdFQicsJ3JhbmdkJzonXFxcXHUyOTkyJywncmFuZ2UnOidcXFxcdTI5QTUnLCdyYW5nbGUnOidcXFxcdTI3RTknLCdyYXF1byc6J1xcXFx4QkInLCdyYXJyJzonXFxcXHUyMTkyJywnckFycic6J1xcXFx1MjFEMicsJ1JhcnInOidcXFxcdTIxQTAnLCdyYXJyYXAnOidcXFxcdTI5NzUnLCdyYXJyYic6J1xcXFx1MjFFNScsJ3JhcnJiZnMnOidcXFxcdTI5MjAnLCdyYXJyYyc6J1xcXFx1MjkzMycsJ3JhcnJmcyc6J1xcXFx1MjkxRScsJ3JhcnJoayc6J1xcXFx1MjFBQScsJ3JhcnJscCc6J1xcXFx1MjFBQycsJ3JhcnJwbCc6J1xcXFx1Mjk0NScsJ3JhcnJzaW0nOidcXFxcdTI5NzQnLCdyYXJydGwnOidcXFxcdTIxQTMnLCdSYXJydGwnOidcXFxcdTI5MTYnLCdyYXJydyc6J1xcXFx1MjE5RCcsJ3JhdGFpbCc6J1xcXFx1MjkxQScsJ3JBdGFpbCc6J1xcXFx1MjkxQycsJ3JhdGlvJzonXFxcXHUyMjM2JywncmF0aW9uYWxzJzonXFxcXHUyMTFBJywncmJhcnInOidcXFxcdTI5MEQnLCdyQmFycic6J1xcXFx1MjkwRicsJ1JCYXJyJzonXFxcXHUyOTEwJywncmJicmsnOidcXFxcdTI3NzMnLCdyYnJhY2UnOid9JywncmJyYWNrJzonXScsJ3JicmtlJzonXFxcXHUyOThDJywncmJya3NsZCc6J1xcXFx1Mjk4RScsJ3JicmtzbHUnOidcXFxcdTI5OTAnLCdyY2Fyb24nOidcXFxcdTAxNTknLCdSY2Fyb24nOidcXFxcdTAxNTgnLCdyY2VkaWwnOidcXFxcdTAxNTcnLCdSY2VkaWwnOidcXFxcdTAxNTYnLCdyY2VpbCc6J1xcXFx1MjMwOScsJ3JjdWInOid9JywncmN5JzonXFxcXHUwNDQwJywnUmN5JzonXFxcXHUwNDIwJywncmRjYSc6J1xcXFx1MjkzNycsJ3JkbGRoYXInOidcXFxcdTI5NjknLCdyZHF1byc6J1xcXFx1MjAxRCcsJ3JkcXVvcic6J1xcXFx1MjAxRCcsJ3Jkc2gnOidcXFxcdTIxQjMnLCdSZSc6J1xcXFx1MjExQycsJ3JlYWwnOidcXFxcdTIxMUMnLCdyZWFsaW5lJzonXFxcXHUyMTFCJywncmVhbHBhcnQnOidcXFxcdTIxMUMnLCdyZWFscyc6J1xcXFx1MjExRCcsJ3JlY3QnOidcXFxcdTI1QUQnLCdyZWcnOidcXFxceEFFJywnUkVHJzonXFxcXHhBRScsJ1JldmVyc2VFbGVtZW50JzonXFxcXHUyMjBCJywnUmV2ZXJzZUVxdWlsaWJyaXVtJzonXFxcXHUyMUNCJywnUmV2ZXJzZVVwRXF1aWxpYnJpdW0nOidcXFxcdTI5NkYnLCdyZmlzaHQnOidcXFxcdTI5N0QnLCdyZmxvb3InOidcXFxcdTIzMEInLCdyZnInOidcXFxcdUQ4MzVcXFxcdUREMkYnLCdSZnInOidcXFxcdTIxMUMnLCdySGFyJzonXFxcXHUyOTY0JywncmhhcmQnOidcXFxcdTIxQzEnLCdyaGFydSc6J1xcXFx1MjFDMCcsJ3JoYXJ1bCc6J1xcXFx1Mjk2QycsJ3Jobyc6J1xcXFx1MDNDMScsJ1Jobyc6J1xcXFx1MDNBMScsJ3Job3YnOidcXFxcdTAzRjEnLCdSaWdodEFuZ2xlQnJhY2tldCc6J1xcXFx1MjdFOScsJ3JpZ2h0YXJyb3cnOidcXFxcdTIxOTInLCdSaWdodGFycm93JzonXFxcXHUyMUQyJywnUmlnaHRBcnJvdyc6J1xcXFx1MjE5MicsJ1JpZ2h0QXJyb3dCYXInOidcXFxcdTIxRTUnLCdSaWdodEFycm93TGVmdEFycm93JzonXFxcXHUyMUM0JywncmlnaHRhcnJvd3RhaWwnOidcXFxcdTIxQTMnLCdSaWdodENlaWxpbmcnOidcXFxcdTIzMDknLCdSaWdodERvdWJsZUJyYWNrZXQnOidcXFxcdTI3RTcnLCdSaWdodERvd25UZWVWZWN0b3InOidcXFxcdTI5NUQnLCdSaWdodERvd25WZWN0b3InOidcXFxcdTIxQzInLCdSaWdodERvd25WZWN0b3JCYXInOidcXFxcdTI5NTUnLCdSaWdodEZsb29yJzonXFxcXHUyMzBCJywncmlnaHRoYXJwb29uZG93bic6J1xcXFx1MjFDMScsJ3JpZ2h0aGFycG9vbnVwJzonXFxcXHUyMUMwJywncmlnaHRsZWZ0YXJyb3dzJzonXFxcXHUyMUM0JywncmlnaHRsZWZ0aGFycG9vbnMnOidcXFxcdTIxQ0MnLCdyaWdodHJpZ2h0YXJyb3dzJzonXFxcXHUyMUM5JywncmlnaHRzcXVpZ2Fycm93JzonXFxcXHUyMTlEJywnUmlnaHRUZWUnOidcXFxcdTIyQTInLCdSaWdodFRlZUFycm93JzonXFxcXHUyMUE2JywnUmlnaHRUZWVWZWN0b3InOidcXFxcdTI5NUInLCdyaWdodHRocmVldGltZXMnOidcXFxcdTIyQ0MnLCdSaWdodFRyaWFuZ2xlJzonXFxcXHUyMkIzJywnUmlnaHRUcmlhbmdsZUJhcic6J1xcXFx1MjlEMCcsJ1JpZ2h0VHJpYW5nbGVFcXVhbCc6J1xcXFx1MjJCNScsJ1JpZ2h0VXBEb3duVmVjdG9yJzonXFxcXHUyOTRGJywnUmlnaHRVcFRlZVZlY3Rvcic6J1xcXFx1Mjk1QycsJ1JpZ2h0VXBWZWN0b3InOidcXFxcdTIxQkUnLCdSaWdodFVwVmVjdG9yQmFyJzonXFxcXHUyOTU0JywnUmlnaHRWZWN0b3InOidcXFxcdTIxQzAnLCdSaWdodFZlY3RvckJhcic6J1xcXFx1Mjk1MycsJ3JpbmcnOidcXFxcdTAyREEnLCdyaXNpbmdkb3RzZXEnOidcXFxcdTIyNTMnLCdybGFycic6J1xcXFx1MjFDNCcsJ3JsaGFyJzonXFxcXHUyMUNDJywncmxtJzonXFxcXHUyMDBGJywncm1vdXN0JzonXFxcXHUyM0IxJywncm1vdXN0YWNoZSc6J1xcXFx1MjNCMScsJ3JubWlkJzonXFxcXHUyQUVFJywncm9hbmcnOidcXFxcdTI3RUQnLCdyb2Fycic6J1xcXFx1MjFGRScsJ3JvYnJrJzonXFxcXHUyN0U3Jywncm9wYXInOidcXFxcdTI5ODYnLCdyb3BmJzonXFxcXHVEODM1XFxcXHVERDYzJywnUm9wZic6J1xcXFx1MjExRCcsJ3JvcGx1cyc6J1xcXFx1MkEyRScsJ3JvdGltZXMnOidcXFxcdTJBMzUnLCdSb3VuZEltcGxpZXMnOidcXFxcdTI5NzAnLCdycGFyJzonKScsJ3JwYXJndCc6J1xcXFx1Mjk5NCcsJ3JwcG9saW50JzonXFxcXHUyQTEyJywncnJhcnInOidcXFxcdTIxQzknLCdScmlnaHRhcnJvdyc6J1xcXFx1MjFEQicsJ3JzYXF1byc6J1xcXFx1MjAzQScsJ3JzY3InOidcXFxcdUQ4MzVcXFxcdURDQzcnLCdSc2NyJzonXFxcXHUyMTFCJywncnNoJzonXFxcXHUyMUIxJywnUnNoJzonXFxcXHUyMUIxJywncnNxYic6J10nLCdyc3F1byc6J1xcXFx1MjAxOScsJ3JzcXVvcic6J1xcXFx1MjAxOScsJ3J0aHJlZSc6J1xcXFx1MjJDQycsJ3J0aW1lcyc6J1xcXFx1MjJDQScsJ3J0cmknOidcXFxcdTI1QjknLCdydHJpZSc6J1xcXFx1MjJCNScsJ3J0cmlmJzonXFxcXHUyNUI4JywncnRyaWx0cmknOidcXFxcdTI5Q0UnLCdSdWxlRGVsYXllZCc6J1xcXFx1MjlGNCcsJ3J1bHVoYXInOidcXFxcdTI5NjgnLCdyeCc6J1xcXFx1MjExRScsJ3NhY3V0ZSc6J1xcXFx1MDE1QicsJ1NhY3V0ZSc6J1xcXFx1MDE1QScsJ3NicXVvJzonXFxcXHUyMDFBJywnc2MnOidcXFxcdTIyN0InLCdTYyc6J1xcXFx1MkFCQycsJ3NjYXAnOidcXFxcdTJBQjgnLCdzY2Fyb24nOidcXFxcdTAxNjEnLCdTY2Fyb24nOidcXFxcdTAxNjAnLCdzY2N1ZSc6J1xcXFx1MjI3RCcsJ3NjZSc6J1xcXFx1MkFCMCcsJ3NjRSc6J1xcXFx1MkFCNCcsJ3NjZWRpbCc6J1xcXFx1MDE1RicsJ1NjZWRpbCc6J1xcXFx1MDE1RScsJ3NjaXJjJzonXFxcXHUwMTVEJywnU2NpcmMnOidcXFxcdTAxNUMnLCdzY25hcCc6J1xcXFx1MkFCQScsJ3NjbkUnOidcXFxcdTJBQjYnLCdzY25zaW0nOidcXFxcdTIyRTknLCdzY3BvbGludCc6J1xcXFx1MkExMycsJ3Njc2ltJzonXFxcXHUyMjdGJywnc2N5JzonXFxcXHUwNDQxJywnU2N5JzonXFxcXHUwNDIxJywnc2RvdCc6J1xcXFx1MjJDNScsJ3Nkb3RiJzonXFxcXHUyMkExJywnc2RvdGUnOidcXFxcdTJBNjYnLCdzZWFyaGsnOidcXFxcdTI5MjUnLCdzZWFycic6J1xcXFx1MjE5OCcsJ3NlQXJyJzonXFxcXHUyMUQ4Jywnc2VhcnJvdyc6J1xcXFx1MjE5OCcsJ3NlY3QnOidcXFxceEE3Jywnc2VtaSc6JzsnLCdzZXN3YXInOidcXFxcdTI5MjknLCdzZXRtaW51cyc6J1xcXFx1MjIxNicsJ3NldG1uJzonXFxcXHUyMjE2Jywnc2V4dCc6J1xcXFx1MjczNicsJ3Nmcic6J1xcXFx1RDgzNVxcXFx1REQzMCcsJ1Nmcic6J1xcXFx1RDgzNVxcXFx1REQxNicsJ3Nmcm93bic6J1xcXFx1MjMyMicsJ3NoYXJwJzonXFxcXHUyNjZGJywnc2hjaGN5JzonXFxcXHUwNDQ5JywnU0hDSGN5JzonXFxcXHUwNDI5Jywnc2hjeSc6J1xcXFx1MDQ0OCcsJ1NIY3knOidcXFxcdTA0MjgnLCdTaG9ydERvd25BcnJvdyc6J1xcXFx1MjE5MycsJ1Nob3J0TGVmdEFycm93JzonXFxcXHUyMTkwJywnc2hvcnRtaWQnOidcXFxcdTIyMjMnLCdzaG9ydHBhcmFsbGVsJzonXFxcXHUyMjI1JywnU2hvcnRSaWdodEFycm93JzonXFxcXHUyMTkyJywnU2hvcnRVcEFycm93JzonXFxcXHUyMTkxJywnc2h5JzonXFxcXHhBRCcsJ3NpZ21hJzonXFxcXHUwM0MzJywnU2lnbWEnOidcXFxcdTAzQTMnLCdzaWdtYWYnOidcXFxcdTAzQzInLCdzaWdtYXYnOidcXFxcdTAzQzInLCdzaW0nOidcXFxcdTIyM0MnLCdzaW1kb3QnOidcXFxcdTJBNkEnLCdzaW1lJzonXFxcXHUyMjQzJywnc2ltZXEnOidcXFxcdTIyNDMnLCdzaW1nJzonXFxcXHUyQTlFJywnc2ltZ0UnOidcXFxcdTJBQTAnLCdzaW1sJzonXFxcXHUyQTlEJywnc2ltbEUnOidcXFxcdTJBOUYnLCdzaW1uZSc6J1xcXFx1MjI0NicsJ3NpbXBsdXMnOidcXFxcdTJBMjQnLCdzaW1yYXJyJzonXFxcXHUyOTcyJywnc2xhcnInOidcXFxcdTIxOTAnLCdTbWFsbENpcmNsZSc6J1xcXFx1MjIxOCcsJ3NtYWxsc2V0bWludXMnOidcXFxcdTIyMTYnLCdzbWFzaHAnOidcXFxcdTJBMzMnLCdzbWVwYXJzbCc6J1xcXFx1MjlFNCcsJ3NtaWQnOidcXFxcdTIyMjMnLCdzbWlsZSc6J1xcXFx1MjMyMycsJ3NtdCc6J1xcXFx1MkFBQScsJ3NtdGUnOidcXFxcdTJBQUMnLCdzbXRlcyc6J1xcXFx1MkFBQ1xcXFx1RkUwMCcsJ3NvZnRjeSc6J1xcXFx1MDQ0QycsJ1NPRlRjeSc6J1xcXFx1MDQyQycsJ3NvbCc6Jy8nLCdzb2xiJzonXFxcXHUyOUM0Jywnc29sYmFyJzonXFxcXHUyMzNGJywnc29wZic6J1xcXFx1RDgzNVxcXFx1REQ2NCcsJ1NvcGYnOidcXFxcdUQ4MzVcXFxcdURENEEnLCdzcGFkZXMnOidcXFxcdTI2NjAnLCdzcGFkZXN1aXQnOidcXFxcdTI2NjAnLCdzcGFyJzonXFxcXHUyMjI1Jywnc3FjYXAnOidcXFxcdTIyOTMnLCdzcWNhcHMnOidcXFxcdTIyOTNcXFxcdUZFMDAnLCdzcWN1cCc6J1xcXFx1MjI5NCcsJ3NxY3Vwcyc6J1xcXFx1MjI5NFxcXFx1RkUwMCcsJ1NxcnQnOidcXFxcdTIyMUEnLCdzcXN1Yic6J1xcXFx1MjI4RicsJ3Nxc3ViZSc6J1xcXFx1MjI5MScsJ3Nxc3Vic2V0JzonXFxcXHUyMjhGJywnc3FzdWJzZXRlcSc6J1xcXFx1MjI5MScsJ3Nxc3VwJzonXFxcXHUyMjkwJywnc3FzdXBlJzonXFxcXHUyMjkyJywnc3FzdXBzZXQnOidcXFxcdTIyOTAnLCdzcXN1cHNldGVxJzonXFxcXHUyMjkyJywnc3F1JzonXFxcXHUyNUExJywnc3F1YXJlJzonXFxcXHUyNUExJywnU3F1YXJlJzonXFxcXHUyNUExJywnU3F1YXJlSW50ZXJzZWN0aW9uJzonXFxcXHUyMjkzJywnU3F1YXJlU3Vic2V0JzonXFxcXHUyMjhGJywnU3F1YXJlU3Vic2V0RXF1YWwnOidcXFxcdTIyOTEnLCdTcXVhcmVTdXBlcnNldCc6J1xcXFx1MjI5MCcsJ1NxdWFyZVN1cGVyc2V0RXF1YWwnOidcXFxcdTIyOTInLCdTcXVhcmVVbmlvbic6J1xcXFx1MjI5NCcsJ3NxdWFyZic6J1xcXFx1MjVBQScsJ3NxdWYnOidcXFxcdTI1QUEnLCdzcmFycic6J1xcXFx1MjE5MicsJ3NzY3InOidcXFxcdUQ4MzVcXFxcdURDQzgnLCdTc2NyJzonXFxcXHVEODM1XFxcXHVEQ0FFJywnc3NldG1uJzonXFxcXHUyMjE2Jywnc3NtaWxlJzonXFxcXHUyMzIzJywnc3N0YXJmJzonXFxcXHUyMkM2Jywnc3Rhcic6J1xcXFx1MjYwNicsJ1N0YXInOidcXFxcdTIyQzYnLCdzdGFyZic6J1xcXFx1MjYwNScsJ3N0cmFpZ2h0ZXBzaWxvbic6J1xcXFx1MDNGNScsJ3N0cmFpZ2h0cGhpJzonXFxcXHUwM0Q1Jywnc3RybnMnOidcXFxceEFGJywnc3ViJzonXFxcXHUyMjgyJywnU3ViJzonXFxcXHUyMkQwJywnc3ViZG90JzonXFxcXHUyQUJEJywnc3ViZSc6J1xcXFx1MjI4NicsJ3N1YkUnOidcXFxcdTJBQzUnLCdzdWJlZG90JzonXFxcXHUyQUMzJywnc3VibXVsdCc6J1xcXFx1MkFDMScsJ3N1Ym5lJzonXFxcXHUyMjhBJywnc3VibkUnOidcXFxcdTJBQ0InLCdzdWJwbHVzJzonXFxcXHUyQUJGJywnc3VicmFycic6J1xcXFx1Mjk3OScsJ3N1YnNldCc6J1xcXFx1MjI4MicsJ1N1YnNldCc6J1xcXFx1MjJEMCcsJ3N1YnNldGVxJzonXFxcXHUyMjg2Jywnc3Vic2V0ZXFxJzonXFxcXHUyQUM1JywnU3Vic2V0RXF1YWwnOidcXFxcdTIyODYnLCdzdWJzZXRuZXEnOidcXFxcdTIyOEEnLCdzdWJzZXRuZXFxJzonXFxcXHUyQUNCJywnc3Vic2ltJzonXFxcXHUyQUM3Jywnc3Vic3ViJzonXFxcXHUyQUQ1Jywnc3Vic3VwJzonXFxcXHUyQUQzJywnc3VjYyc6J1xcXFx1MjI3QicsJ3N1Y2NhcHByb3gnOidcXFxcdTJBQjgnLCdzdWNjY3VybHllcSc6J1xcXFx1MjI3RCcsJ1N1Y2NlZWRzJzonXFxcXHUyMjdCJywnU3VjY2VlZHNFcXVhbCc6J1xcXFx1MkFCMCcsJ1N1Y2NlZWRzU2xhbnRFcXVhbCc6J1xcXFx1MjI3RCcsJ1N1Y2NlZWRzVGlsZGUnOidcXFxcdTIyN0YnLCdzdWNjZXEnOidcXFxcdTJBQjAnLCdzdWNjbmFwcHJveCc6J1xcXFx1MkFCQScsJ3N1Y2NuZXFxJzonXFxcXHUyQUI2Jywnc3VjY25zaW0nOidcXFxcdTIyRTknLCdzdWNjc2ltJzonXFxcXHUyMjdGJywnU3VjaFRoYXQnOidcXFxcdTIyMEInLCdzdW0nOidcXFxcdTIyMTEnLCdTdW0nOidcXFxcdTIyMTEnLCdzdW5nJzonXFxcXHUyNjZBJywnc3VwJzonXFxcXHUyMjgzJywnU3VwJzonXFxcXHUyMkQxJywnc3VwMSc6J1xcXFx4QjknLCdzdXAyJzonXFxcXHhCMicsJ3N1cDMnOidcXFxceEIzJywnc3VwZG90JzonXFxcXHUyQUJFJywnc3VwZHN1Yic6J1xcXFx1MkFEOCcsJ3N1cGUnOidcXFxcdTIyODcnLCdzdXBFJzonXFxcXHUyQUM2Jywnc3VwZWRvdCc6J1xcXFx1MkFDNCcsJ1N1cGVyc2V0JzonXFxcXHUyMjgzJywnU3VwZXJzZXRFcXVhbCc6J1xcXFx1MjI4NycsJ3N1cGhzb2wnOidcXFxcdTI3QzknLCdzdXBoc3ViJzonXFxcXHUyQUQ3Jywnc3VwbGFycic6J1xcXFx1Mjk3QicsJ3N1cG11bHQnOidcXFxcdTJBQzInLCdzdXBuZSc6J1xcXFx1MjI4QicsJ3N1cG5FJzonXFxcXHUyQUNDJywnc3VwcGx1cyc6J1xcXFx1MkFDMCcsJ3N1cHNldCc6J1xcXFx1MjI4MycsJ1N1cHNldCc6J1xcXFx1MjJEMScsJ3N1cHNldGVxJzonXFxcXHUyMjg3Jywnc3Vwc2V0ZXFxJzonXFxcXHUyQUM2Jywnc3Vwc2V0bmVxJzonXFxcXHUyMjhCJywnc3Vwc2V0bmVxcSc6J1xcXFx1MkFDQycsJ3N1cHNpbSc6J1xcXFx1MkFDOCcsJ3N1cHN1Yic6J1xcXFx1MkFENCcsJ3N1cHN1cCc6J1xcXFx1MkFENicsJ3N3YXJoayc6J1xcXFx1MjkyNicsJ3N3YXJyJzonXFxcXHUyMTk5Jywnc3dBcnInOidcXFxcdTIxRDknLCdzd2Fycm93JzonXFxcXHUyMTk5Jywnc3dud2FyJzonXFxcXHUyOTJBJywnc3psaWcnOidcXFxceERGJywnVGFiJzonXFxcXHQnLCd0YXJnZXQnOidcXFxcdTIzMTYnLCd0YXUnOidcXFxcdTAzQzQnLCdUYXUnOidcXFxcdTAzQTQnLCd0YnJrJzonXFxcXHUyM0I0JywndGNhcm9uJzonXFxcXHUwMTY1JywnVGNhcm9uJzonXFxcXHUwMTY0JywndGNlZGlsJzonXFxcXHUwMTYzJywnVGNlZGlsJzonXFxcXHUwMTYyJywndGN5JzonXFxcXHUwNDQyJywnVGN5JzonXFxcXHUwNDIyJywndGRvdCc6J1xcXFx1MjBEQicsJ3RlbHJlYyc6J1xcXFx1MjMxNScsJ3Rmcic6J1xcXFx1RDgzNVxcXFx1REQzMScsJ1Rmcic6J1xcXFx1RDgzNVxcXFx1REQxNycsJ3RoZXJlNCc6J1xcXFx1MjIzNCcsJ3RoZXJlZm9yZSc6J1xcXFx1MjIzNCcsJ1RoZXJlZm9yZSc6J1xcXFx1MjIzNCcsJ3RoZXRhJzonXFxcXHUwM0I4JywnVGhldGEnOidcXFxcdTAzOTgnLCd0aGV0YXN5bSc6J1xcXFx1MDNEMScsJ3RoZXRhdic6J1xcXFx1MDNEMScsJ3RoaWNrYXBwcm94JzonXFxcXHUyMjQ4JywndGhpY2tzaW0nOidcXFxcdTIyM0MnLCdUaGlja1NwYWNlJzonXFxcXHUyMDVGXFxcXHUyMDBBJywndGhpbnNwJzonXFxcXHUyMDA5JywnVGhpblNwYWNlJzonXFxcXHUyMDA5JywndGhrYXAnOidcXFxcdTIyNDgnLCd0aGtzaW0nOidcXFxcdTIyM0MnLCd0aG9ybic6J1xcXFx4RkUnLCdUSE9STic6J1xcXFx4REUnLCd0aWxkZSc6J1xcXFx1MDJEQycsJ1RpbGRlJzonXFxcXHUyMjNDJywnVGlsZGVFcXVhbCc6J1xcXFx1MjI0MycsJ1RpbGRlRnVsbEVxdWFsJzonXFxcXHUyMjQ1JywnVGlsZGVUaWxkZSc6J1xcXFx1MjI0OCcsJ3RpbWVzJzonXFxcXHhENycsJ3RpbWVzYic6J1xcXFx1MjJBMCcsJ3RpbWVzYmFyJzonXFxcXHUyQTMxJywndGltZXNkJzonXFxcXHUyQTMwJywndGludCc6J1xcXFx1MjIyRCcsJ3RvZWEnOidcXFxcdTI5MjgnLCd0b3AnOidcXFxcdTIyQTQnLCd0b3Bib3QnOidcXFxcdTIzMzYnLCd0b3BjaXInOidcXFxcdTJBRjEnLCd0b3BmJzonXFxcXHVEODM1XFxcXHVERDY1JywnVG9wZic6J1xcXFx1RDgzNVxcXFx1REQ0QicsJ3RvcGZvcmsnOidcXFxcdTJBREEnLCd0b3NhJzonXFxcXHUyOTI5JywndHByaW1lJzonXFxcXHUyMDM0JywndHJhZGUnOidcXFxcdTIxMjInLCdUUkFERSc6J1xcXFx1MjEyMicsJ3RyaWFuZ2xlJzonXFxcXHUyNUI1JywndHJpYW5nbGVkb3duJzonXFxcXHUyNUJGJywndHJpYW5nbGVsZWZ0JzonXFxcXHUyNUMzJywndHJpYW5nbGVsZWZ0ZXEnOidcXFxcdTIyQjQnLCd0cmlhbmdsZXEnOidcXFxcdTIyNUMnLCd0cmlhbmdsZXJpZ2h0JzonXFxcXHUyNUI5JywndHJpYW5nbGVyaWdodGVxJzonXFxcXHUyMkI1JywndHJpZG90JzonXFxcXHUyNUVDJywndHJpZSc6J1xcXFx1MjI1QycsJ3RyaW1pbnVzJzonXFxcXHUyQTNBJywnVHJpcGxlRG90JzonXFxcXHUyMERCJywndHJpcGx1cyc6J1xcXFx1MkEzOScsJ3RyaXNiJzonXFxcXHUyOUNEJywndHJpdGltZSc6J1xcXFx1MkEzQicsJ3RycGV6aXVtJzonXFxcXHUyM0UyJywndHNjcic6J1xcXFx1RDgzNVxcXFx1RENDOScsJ1RzY3InOidcXFxcdUQ4MzVcXFxcdURDQUYnLCd0c2N5JzonXFxcXHUwNDQ2JywnVFNjeSc6J1xcXFx1MDQyNicsJ3RzaGN5JzonXFxcXHUwNDVCJywnVFNIY3knOidcXFxcdTA0MEInLCd0c3Ryb2snOidcXFxcdTAxNjcnLCdUc3Ryb2snOidcXFxcdTAxNjYnLCd0d2l4dCc6J1xcXFx1MjI2QycsJ3R3b2hlYWRsZWZ0YXJyb3cnOidcXFxcdTIxOUUnLCd0d29oZWFkcmlnaHRhcnJvdyc6J1xcXFx1MjFBMCcsJ3VhY3V0ZSc6J1xcXFx4RkEnLCdVYWN1dGUnOidcXFxceERBJywndWFycic6J1xcXFx1MjE5MScsJ3VBcnInOidcXFxcdTIxRDEnLCdVYXJyJzonXFxcXHUyMTlGJywnVWFycm9jaXInOidcXFxcdTI5NDknLCd1YnJjeSc6J1xcXFx1MDQ1RScsJ1VicmN5JzonXFxcXHUwNDBFJywndWJyZXZlJzonXFxcXHUwMTZEJywnVWJyZXZlJzonXFxcXHUwMTZDJywndWNpcmMnOidcXFxceEZCJywnVWNpcmMnOidcXFxceERCJywndWN5JzonXFxcXHUwNDQzJywnVWN5JzonXFxcXHUwNDIzJywndWRhcnInOidcXFxcdTIxQzUnLCd1ZGJsYWMnOidcXFxcdTAxNzEnLCdVZGJsYWMnOidcXFxcdTAxNzAnLCd1ZGhhcic6J1xcXFx1Mjk2RScsJ3VmaXNodCc6J1xcXFx1Mjk3RScsJ3Vmcic6J1xcXFx1RDgzNVxcXFx1REQzMicsJ1Vmcic6J1xcXFx1RDgzNVxcXFx1REQxOCcsJ3VncmF2ZSc6J1xcXFx4RjknLCdVZ3JhdmUnOidcXFxceEQ5JywndUhhcic6J1xcXFx1Mjk2MycsJ3VoYXJsJzonXFxcXHUyMUJGJywndWhhcnInOidcXFxcdTIxQkUnLCd1aGJsayc6J1xcXFx1MjU4MCcsJ3VsY29ybic6J1xcXFx1MjMxQycsJ3VsY29ybmVyJzonXFxcXHUyMzFDJywndWxjcm9wJzonXFxcXHUyMzBGJywndWx0cmknOidcXFxcdTI1RjgnLCd1bWFjcic6J1xcXFx1MDE2QicsJ1VtYWNyJzonXFxcXHUwMTZBJywndW1sJzonXFxcXHhBOCcsJ1VuZGVyQmFyJzonXycsJ1VuZGVyQnJhY2UnOidcXFxcdTIzREYnLCdVbmRlckJyYWNrZXQnOidcXFxcdTIzQjUnLCdVbmRlclBhcmVudGhlc2lzJzonXFxcXHUyM0REJywnVW5pb24nOidcXFxcdTIyQzMnLCdVbmlvblBsdXMnOidcXFxcdTIyOEUnLCd1b2dvbic6J1xcXFx1MDE3MycsJ1VvZ29uJzonXFxcXHUwMTcyJywndW9wZic6J1xcXFx1RDgzNVxcXFx1REQ2NicsJ1VvcGYnOidcXFxcdUQ4MzVcXFxcdURENEMnLCd1cGFycm93JzonXFxcXHUyMTkxJywnVXBhcnJvdyc6J1xcXFx1MjFEMScsJ1VwQXJyb3cnOidcXFxcdTIxOTEnLCdVcEFycm93QmFyJzonXFxcXHUyOTEyJywnVXBBcnJvd0Rvd25BcnJvdyc6J1xcXFx1MjFDNScsJ3VwZG93bmFycm93JzonXFxcXHUyMTk1JywnVXBkb3duYXJyb3cnOidcXFxcdTIxRDUnLCdVcERvd25BcnJvdyc6J1xcXFx1MjE5NScsJ1VwRXF1aWxpYnJpdW0nOidcXFxcdTI5NkUnLCd1cGhhcnBvb25sZWZ0JzonXFxcXHUyMUJGJywndXBoYXJwb29ucmlnaHQnOidcXFxcdTIxQkUnLCd1cGx1cyc6J1xcXFx1MjI4RScsJ1VwcGVyTGVmdEFycm93JzonXFxcXHUyMTk2JywnVXBwZXJSaWdodEFycm93JzonXFxcXHUyMTk3JywndXBzaSc6J1xcXFx1MDNDNScsJ1Vwc2knOidcXFxcdTAzRDInLCd1cHNpaCc6J1xcXFx1MDNEMicsJ3Vwc2lsb24nOidcXFxcdTAzQzUnLCdVcHNpbG9uJzonXFxcXHUwM0E1JywnVXBUZWUnOidcXFxcdTIyQTUnLCdVcFRlZUFycm93JzonXFxcXHUyMUE1JywndXB1cGFycm93cyc6J1xcXFx1MjFDOCcsJ3VyY29ybic6J1xcXFx1MjMxRCcsJ3VyY29ybmVyJzonXFxcXHUyMzFEJywndXJjcm9wJzonXFxcXHUyMzBFJywndXJpbmcnOidcXFxcdTAxNkYnLCdVcmluZyc6J1xcXFx1MDE2RScsJ3VydHJpJzonXFxcXHUyNUY5JywndXNjcic6J1xcXFx1RDgzNVxcXFx1RENDQScsJ1VzY3InOidcXFxcdUQ4MzVcXFxcdURDQjAnLCd1dGRvdCc6J1xcXFx1MjJGMCcsJ3V0aWxkZSc6J1xcXFx1MDE2OScsJ1V0aWxkZSc6J1xcXFx1MDE2OCcsJ3V0cmknOidcXFxcdTI1QjUnLCd1dHJpZic6J1xcXFx1MjVCNCcsJ3V1YXJyJzonXFxcXHUyMUM4JywndXVtbCc6J1xcXFx4RkMnLCdVdW1sJzonXFxcXHhEQycsJ3V3YW5nbGUnOidcXFxcdTI5QTcnLCd2YW5ncnQnOidcXFxcdTI5OUMnLCd2YXJlcHNpbG9uJzonXFxcXHUwM0Y1JywndmFya2FwcGEnOidcXFxcdTAzRjAnLCd2YXJub3RoaW5nJzonXFxcXHUyMjA1JywndmFycGhpJzonXFxcXHUwM0Q1JywndmFycGknOidcXFxcdTAzRDYnLCd2YXJwcm9wdG8nOidcXFxcdTIyMUQnLCd2YXJyJzonXFxcXHUyMTk1JywndkFycic6J1xcXFx1MjFENScsJ3ZhcnJobyc6J1xcXFx1MDNGMScsJ3ZhcnNpZ21hJzonXFxcXHUwM0MyJywndmFyc3Vic2V0bmVxJzonXFxcXHUyMjhBXFxcXHVGRTAwJywndmFyc3Vic2V0bmVxcSc6J1xcXFx1MkFDQlxcXFx1RkUwMCcsJ3ZhcnN1cHNldG5lcSc6J1xcXFx1MjI4QlxcXFx1RkUwMCcsJ3ZhcnN1cHNldG5lcXEnOidcXFxcdTJBQ0NcXFxcdUZFMDAnLCd2YXJ0aGV0YSc6J1xcXFx1MDNEMScsJ3ZhcnRyaWFuZ2xlbGVmdCc6J1xcXFx1MjJCMicsJ3ZhcnRyaWFuZ2xlcmlnaHQnOidcXFxcdTIyQjMnLCd2QmFyJzonXFxcXHUyQUU4JywnVmJhcic6J1xcXFx1MkFFQicsJ3ZCYXJ2JzonXFxcXHUyQUU5JywndmN5JzonXFxcXHUwNDMyJywnVmN5JzonXFxcXHUwNDEyJywndmRhc2gnOidcXFxcdTIyQTInLCd2RGFzaCc6J1xcXFx1MjJBOCcsJ1ZkYXNoJzonXFxcXHUyMkE5JywnVkRhc2gnOidcXFxcdTIyQUInLCdWZGFzaGwnOidcXFxcdTJBRTYnLCd2ZWUnOidcXFxcdTIyMjgnLCdWZWUnOidcXFxcdTIyQzEnLCd2ZWViYXInOidcXFxcdTIyQkInLCd2ZWVlcSc6J1xcXFx1MjI1QScsJ3ZlbGxpcCc6J1xcXFx1MjJFRScsJ3ZlcmJhcic6J3wnLCdWZXJiYXInOidcXFxcdTIwMTYnLCd2ZXJ0JzonfCcsJ1ZlcnQnOidcXFxcdTIwMTYnLCdWZXJ0aWNhbEJhcic6J1xcXFx1MjIyMycsJ1ZlcnRpY2FsTGluZSc6J3wnLCdWZXJ0aWNhbFNlcGFyYXRvcic6J1xcXFx1Mjc1OCcsJ1ZlcnRpY2FsVGlsZGUnOidcXFxcdTIyNDAnLCdWZXJ5VGhpblNwYWNlJzonXFxcXHUyMDBBJywndmZyJzonXFxcXHVEODM1XFxcXHVERDMzJywnVmZyJzonXFxcXHVEODM1XFxcXHVERDE5Jywndmx0cmknOidcXFxcdTIyQjInLCd2bnN1Yic6J1xcXFx1MjI4MlxcXFx1MjBEMicsJ3Zuc3VwJzonXFxcXHUyMjgzXFxcXHUyMEQyJywndm9wZic6J1xcXFx1RDgzNVxcXFx1REQ2NycsJ1ZvcGYnOidcXFxcdUQ4MzVcXFxcdURENEQnLCd2cHJvcCc6J1xcXFx1MjIxRCcsJ3ZydHJpJzonXFxcXHUyMkIzJywndnNjcic6J1xcXFx1RDgzNVxcXFx1RENDQicsJ1ZzY3InOidcXFxcdUQ4MzVcXFxcdURDQjEnLCd2c3VibmUnOidcXFxcdTIyOEFcXFxcdUZFMDAnLCd2c3VibkUnOidcXFxcdTJBQ0JcXFxcdUZFMDAnLCd2c3VwbmUnOidcXFxcdTIyOEJcXFxcdUZFMDAnLCd2c3VwbkUnOidcXFxcdTJBQ0NcXFxcdUZFMDAnLCdWdmRhc2gnOidcXFxcdTIyQUEnLCd2emlnemFnJzonXFxcXHUyOTlBJywnd2NpcmMnOidcXFxcdTAxNzUnLCdXY2lyYyc6J1xcXFx1MDE3NCcsJ3dlZGJhcic6J1xcXFx1MkE1RicsJ3dlZGdlJzonXFxcXHUyMjI3JywnV2VkZ2UnOidcXFxcdTIyQzAnLCd3ZWRnZXEnOidcXFxcdTIyNTknLCd3ZWllcnAnOidcXFxcdTIxMTgnLCd3ZnInOidcXFxcdUQ4MzVcXFxcdUREMzQnLCdXZnInOidcXFxcdUQ4MzVcXFxcdUREMUEnLCd3b3BmJzonXFxcXHVEODM1XFxcXHVERDY4JywnV29wZic6J1xcXFx1RDgzNVxcXFx1REQ0RScsJ3dwJzonXFxcXHUyMTE4Jywnd3InOidcXFxcdTIyNDAnLCd3cmVhdGgnOidcXFxcdTIyNDAnLCd3c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NDJywnV3Njcic6J1xcXFx1RDgzNVxcXFx1RENCMicsJ3hjYXAnOidcXFxcdTIyQzInLCd4Y2lyYyc6J1xcXFx1MjVFRicsJ3hjdXAnOidcXFxcdTIyQzMnLCd4ZHRyaSc6J1xcXFx1MjVCRCcsJ3hmcic6J1xcXFx1RDgzNVxcXFx1REQzNScsJ1hmcic6J1xcXFx1RDgzNVxcXFx1REQxQicsJ3hoYXJyJzonXFxcXHUyN0Y3JywneGhBcnInOidcXFxcdTI3RkEnLCd4aSc6J1xcXFx1MDNCRScsJ1hpJzonXFxcXHUwMzlFJywneGxhcnInOidcXFxcdTI3RjUnLCd4bEFycic6J1xcXFx1MjdGOCcsJ3htYXAnOidcXFxcdTI3RkMnLCd4bmlzJzonXFxcXHUyMkZCJywneG9kb3QnOidcXFxcdTJBMDAnLCd4b3BmJzonXFxcXHVEODM1XFxcXHVERDY5JywnWG9wZic6J1xcXFx1RDgzNVxcXFx1REQ0RicsJ3hvcGx1cyc6J1xcXFx1MkEwMScsJ3hvdGltZSc6J1xcXFx1MkEwMicsJ3hyYXJyJzonXFxcXHUyN0Y2JywneHJBcnInOidcXFxcdTI3RjknLCd4c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NEJywnWHNjcic6J1xcXFx1RDgzNVxcXFx1RENCMycsJ3hzcWN1cCc6J1xcXFx1MkEwNicsJ3h1cGx1cyc6J1xcXFx1MkEwNCcsJ3h1dHJpJzonXFxcXHUyNUIzJywneHZlZSc6J1xcXFx1MjJDMScsJ3h3ZWRnZSc6J1xcXFx1MjJDMCcsJ3lhY3V0ZSc6J1xcXFx4RkQnLCdZYWN1dGUnOidcXFxceEREJywneWFjeSc6J1xcXFx1MDQ0RicsJ1lBY3knOidcXFxcdTA0MkYnLCd5Y2lyYyc6J1xcXFx1MDE3NycsJ1ljaXJjJzonXFxcXHUwMTc2JywneWN5JzonXFxcXHUwNDRCJywnWWN5JzonXFxcXHUwNDJCJywneWVuJzonXFxcXHhBNScsJ3lmcic6J1xcXFx1RDgzNVxcXFx1REQzNicsJ1lmcic6J1xcXFx1RDgzNVxcXFx1REQxQycsJ3lpY3knOidcXFxcdTA0NTcnLCdZSWN5JzonXFxcXHUwNDA3JywneW9wZic6J1xcXFx1RDgzNVxcXFx1REQ2QScsJ1lvcGYnOidcXFxcdUQ4MzVcXFxcdURENTAnLCd5c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NFJywnWXNjcic6J1xcXFx1RDgzNVxcXFx1RENCNCcsJ3l1Y3knOidcXFxcdTA0NEUnLCdZVWN5JzonXFxcXHUwNDJFJywneXVtbCc6J1xcXFx4RkYnLCdZdW1sJzonXFxcXHUwMTc4JywnemFjdXRlJzonXFxcXHUwMTdBJywnWmFjdXRlJzonXFxcXHUwMTc5JywnemNhcm9uJzonXFxcXHUwMTdFJywnWmNhcm9uJzonXFxcXHUwMTdEJywnemN5JzonXFxcXHUwNDM3JywnWmN5JzonXFxcXHUwNDE3JywnemRvdCc6J1xcXFx1MDE3QycsJ1pkb3QnOidcXFxcdTAxN0InLCd6ZWV0cmYnOidcXFxcdTIxMjgnLCdaZXJvV2lkdGhTcGFjZSc6J1xcXFx1MjAwQicsJ3pldGEnOidcXFxcdTAzQjYnLCdaZXRhJzonXFxcXHUwMzk2JywnemZyJzonXFxcXHVEODM1XFxcXHVERDM3JywnWmZyJzonXFxcXHUyMTI4JywnemhjeSc6J1xcXFx1MDQzNicsJ1pIY3knOidcXFxcdTA0MTYnLCd6aWdyYXJyJzonXFxcXHUyMUREJywnem9wZic6J1xcXFx1RDgzNVxcXFx1REQ2QicsJ1pvcGYnOidcXFxcdTIxMjQnLCd6c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NGJywnWnNjcic6J1xcXFx1RDgzNVxcXFx1RENCNScsJ3p3aic6J1xcXFx1MjAwRCcsJ3p3bmonOidcXFxcdTIwMEMnfTtcXG5cXHR2YXIgZGVjb2RlTWFwTGVnYWN5ID0geydhYWN1dGUnOidcXFxceEUxJywnQWFjdXRlJzonXFxcXHhDMScsJ2FjaXJjJzonXFxcXHhFMicsJ0FjaXJjJzonXFxcXHhDMicsJ2FjdXRlJzonXFxcXHhCNCcsJ2FlbGlnJzonXFxcXHhFNicsJ0FFbGlnJzonXFxcXHhDNicsJ2FncmF2ZSc6J1xcXFx4RTAnLCdBZ3JhdmUnOidcXFxceEMwJywnYW1wJzonJicsJ0FNUCc6JyYnLCdhcmluZyc6J1xcXFx4RTUnLCdBcmluZyc6J1xcXFx4QzUnLCdhdGlsZGUnOidcXFxceEUzJywnQXRpbGRlJzonXFxcXHhDMycsJ2F1bWwnOidcXFxceEU0JywnQXVtbCc6J1xcXFx4QzQnLCdicnZiYXInOidcXFxceEE2JywnY2NlZGlsJzonXFxcXHhFNycsJ0NjZWRpbCc6J1xcXFx4QzcnLCdjZWRpbCc6J1xcXFx4QjgnLCdjZW50JzonXFxcXHhBMicsJ2NvcHknOidcXFxceEE5JywnQ09QWSc6J1xcXFx4QTknLCdjdXJyZW4nOidcXFxceEE0JywnZGVnJzonXFxcXHhCMCcsJ2RpdmlkZSc6J1xcXFx4RjcnLCdlYWN1dGUnOidcXFxceEU5JywnRWFjdXRlJzonXFxcXHhDOScsJ2VjaXJjJzonXFxcXHhFQScsJ0VjaXJjJzonXFxcXHhDQScsJ2VncmF2ZSc6J1xcXFx4RTgnLCdFZ3JhdmUnOidcXFxceEM4JywnZXRoJzonXFxcXHhGMCcsJ0VUSCc6J1xcXFx4RDAnLCdldW1sJzonXFxcXHhFQicsJ0V1bWwnOidcXFxceENCJywnZnJhYzEyJzonXFxcXHhCRCcsJ2ZyYWMxNCc6J1xcXFx4QkMnLCdmcmFjMzQnOidcXFxceEJFJywnZ3QnOic+JywnR1QnOic+JywnaWFjdXRlJzonXFxcXHhFRCcsJ0lhY3V0ZSc6J1xcXFx4Q0QnLCdpY2lyYyc6J1xcXFx4RUUnLCdJY2lyYyc6J1xcXFx4Q0UnLCdpZXhjbCc6J1xcXFx4QTEnLCdpZ3JhdmUnOidcXFxceEVDJywnSWdyYXZlJzonXFxcXHhDQycsJ2lxdWVzdCc6J1xcXFx4QkYnLCdpdW1sJzonXFxcXHhFRicsJ0l1bWwnOidcXFxceENGJywnbGFxdW8nOidcXFxceEFCJywnbHQnOic8JywnTFQnOic8JywnbWFjcic6J1xcXFx4QUYnLCdtaWNybyc6J1xcXFx4QjUnLCdtaWRkb3QnOidcXFxceEI3JywnbmJzcCc6J1xcXFx4QTAnLCdub3QnOidcXFxceEFDJywnbnRpbGRlJzonXFxcXHhGMScsJ050aWxkZSc6J1xcXFx4RDEnLCdvYWN1dGUnOidcXFxceEYzJywnT2FjdXRlJzonXFxcXHhEMycsJ29jaXJjJzonXFxcXHhGNCcsJ09jaXJjJzonXFxcXHhENCcsJ29ncmF2ZSc6J1xcXFx4RjInLCdPZ3JhdmUnOidcXFxceEQyJywnb3JkZic6J1xcXFx4QUEnLCdvcmRtJzonXFxcXHhCQScsJ29zbGFzaCc6J1xcXFx4RjgnLCdPc2xhc2gnOidcXFxceEQ4Jywnb3RpbGRlJzonXFxcXHhGNScsJ090aWxkZSc6J1xcXFx4RDUnLCdvdW1sJzonXFxcXHhGNicsJ091bWwnOidcXFxceEQ2JywncGFyYSc6J1xcXFx4QjYnLCdwbHVzbW4nOidcXFxceEIxJywncG91bmQnOidcXFxceEEzJywncXVvdCc6J1xcXCInLCdRVU9UJzonXFxcIicsJ3JhcXVvJzonXFxcXHhCQicsJ3JlZyc6J1xcXFx4QUUnLCdSRUcnOidcXFxceEFFJywnc2VjdCc6J1xcXFx4QTcnLCdzaHknOidcXFxceEFEJywnc3VwMSc6J1xcXFx4QjknLCdzdXAyJzonXFxcXHhCMicsJ3N1cDMnOidcXFxceEIzJywnc3psaWcnOidcXFxceERGJywndGhvcm4nOidcXFxceEZFJywnVEhPUk4nOidcXFxceERFJywndGltZXMnOidcXFxceEQ3JywndWFjdXRlJzonXFxcXHhGQScsJ1VhY3V0ZSc6J1xcXFx4REEnLCd1Y2lyYyc6J1xcXFx4RkInLCdVY2lyYyc6J1xcXFx4REInLCd1Z3JhdmUnOidcXFxceEY5JywnVWdyYXZlJzonXFxcXHhEOScsJ3VtbCc6J1xcXFx4QTgnLCd1dW1sJzonXFxcXHhGQycsJ1V1bWwnOidcXFxceERDJywneWFjdXRlJzonXFxcXHhGRCcsJ1lhY3V0ZSc6J1xcXFx4REQnLCd5ZW4nOidcXFxceEE1JywneXVtbCc6J1xcXFx4RkYnfTtcXG5cXHR2YXIgZGVjb2RlTWFwTnVtZXJpYyA9IHsnMCc6J1xcXFx1RkZGRCcsJzEyOCc6J1xcXFx1MjBBQycsJzEzMCc6J1xcXFx1MjAxQScsJzEzMSc6J1xcXFx1MDE5MicsJzEzMic6J1xcXFx1MjAxRScsJzEzMyc6J1xcXFx1MjAyNicsJzEzNCc6J1xcXFx1MjAyMCcsJzEzNSc6J1xcXFx1MjAyMScsJzEzNic6J1xcXFx1MDJDNicsJzEzNyc6J1xcXFx1MjAzMCcsJzEzOCc6J1xcXFx1MDE2MCcsJzEzOSc6J1xcXFx1MjAzOScsJzE0MCc6J1xcXFx1MDE1MicsJzE0Mic6J1xcXFx1MDE3RCcsJzE0NSc6J1xcXFx1MjAxOCcsJzE0Nic6J1xcXFx1MjAxOScsJzE0Nyc6J1xcXFx1MjAxQycsJzE0OCc6J1xcXFx1MjAxRCcsJzE0OSc6J1xcXFx1MjAyMicsJzE1MCc6J1xcXFx1MjAxMycsJzE1MSc6J1xcXFx1MjAxNCcsJzE1Mic6J1xcXFx1MDJEQycsJzE1Myc6J1xcXFx1MjEyMicsJzE1NCc6J1xcXFx1MDE2MScsJzE1NSc6J1xcXFx1MjAzQScsJzE1Nic6J1xcXFx1MDE1MycsJzE1OCc6J1xcXFx1MDE3RScsJzE1OSc6J1xcXFx1MDE3OCd9O1xcblxcdHZhciBpbnZhbGlkUmVmZXJlbmNlQ29kZVBvaW50cyA9IFsxLDIsMyw0LDUsNiw3LDgsMTEsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMTI3LDEyOCwxMjksMTMwLDEzMSwxMzIsMTMzLDEzNCwxMzUsMTM2LDEzNywxMzgsMTM5LDE0MCwxNDEsMTQyLDE0MywxNDQsMTQ1LDE0NiwxNDcsMTQ4LDE0OSwxNTAsMTUxLDE1MiwxNTMsMTU0LDE1NSwxNTYsMTU3LDE1OCwxNTksNjQ5NzYsNjQ5NzcsNjQ5NzgsNjQ5NzksNjQ5ODAsNjQ5ODEsNjQ5ODIsNjQ5ODMsNjQ5ODQsNjQ5ODUsNjQ5ODYsNjQ5ODcsNjQ5ODgsNjQ5ODksNjQ5OTAsNjQ5OTEsNjQ5OTIsNjQ5OTMsNjQ5OTQsNjQ5OTUsNjQ5OTYsNjQ5OTcsNjQ5OTgsNjQ5OTksNjUwMDAsNjUwMDEsNjUwMDIsNjUwMDMsNjUwMDQsNjUwMDUsNjUwMDYsNjUwMDcsNjU1MzQsNjU1MzUsMTMxMDcwLDEzMTA3MSwxOTY2MDYsMTk2NjA3LDI2MjE0MiwyNjIxNDMsMzI3Njc4LDMyNzY3OSwzOTMyMTQsMzkzMjE1LDQ1ODc1MCw0NTg3NTEsNTI0Mjg2LDUyNDI4Nyw1ODk4MjIsNTg5ODIzLDY1NTM1OCw2NTUzNTksNzIwODk0LDcyMDg5NSw3ODY0MzAsNzg2NDMxLDg1MTk2Niw4NTE5NjcsOTE3NTAyLDkxNzUwMyw5ODMwMzgsOTgzMDM5LDEwNDg1NzQsMTA0ODU3NSwxMTE0MTEwLDExMTQxMTFdO1xcblxcblxcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcblxcdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xcblxcblxcdHZhciBvYmplY3QgPSB7fTtcXG5cXHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XFxuXFx0dmFyIGhhcyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHlOYW1lKSB7XFxuXFx0XFx0cmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eU5hbWUpO1xcblxcdH07XFxuXFxuXFx0dmFyIGNvbnRhaW5zID0gZnVuY3Rpb24oYXJyYXksIHZhbHVlKSB7XFxuXFx0XFx0dmFyIGluZGV4ID0gLTE7XFxuXFx0XFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcXG5cXHRcXHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcblxcdFxcdFxcdGlmIChhcnJheVtpbmRleF0gPT0gdmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9O1xcblxcblxcdHZhciBtZXJnZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKSB7XFxuXFx0XFx0aWYgKCFvcHRpb25zKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGRlZmF1bHRzO1xcblxcdFxcdH1cXG5cXHRcXHR2YXIgcmVzdWx0ID0ge307XFxuXFx0XFx0dmFyIGtleTtcXG5cXHRcXHRmb3IgKGtleSBpbiBkZWZhdWx0cykge1xcblxcdFxcdFxcdC8vIEEgYGhhc093blByb3BlcnR5YCBjaGVjayBpcyBub3QgbmVlZGVkIGhlcmUsIHNpbmNlIG9ubHkgcmVjb2duaXplZFxcblxcdFxcdFxcdC8vIG9wdGlvbiBuYW1lcyBhcmUgdXNlZCBhbnl3YXkuIEFueSBvdGhlcnMgYXJlIGlnbm9yZWQuXFxuXFx0XFx0XFx0cmVzdWx0W2tleV0gPSBoYXMob3B0aW9ucywga2V5KSA/IG9wdGlvbnNba2V5XSA6IGRlZmF1bHRzW2tleV07XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFx0fTtcXG5cXG5cXHQvLyBNb2RpZmllZCB2ZXJzaW9uIG9mIGB1Y3MyZW5jb2RlYDsgc2VlIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZS5cXG5cXHR2YXIgY29kZVBvaW50VG9TeW1ib2wgPSBmdW5jdGlvbihjb2RlUG9pbnQsIHN0cmljdCkge1xcblxcdFxcdHZhciBvdXRwdXQgPSAnJztcXG5cXHRcXHRpZiAoKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikgfHwgY29kZVBvaW50ID4gMHgxMEZGRkYpIHtcXG5cXHRcXHRcXHQvLyBTZWUgaXNzdWUgIzQ6XFxuXFx0XFx0XFx0Ly8g4oCcT3RoZXJ3aXNlLCBpZiB0aGUgbnVtYmVyIGlzIGluIHRoZSByYW5nZSAweEQ4MDAgdG8gMHhERkZGIG9yIGlzXFxuXFx0XFx0XFx0Ly8gZ3JlYXRlciB0aGFuIDB4MTBGRkZGLCB0aGVuIHRoaXMgaXMgYSBwYXJzZSBlcnJvci4gUmV0dXJuIGEgVStGRkZEXFxuXFx0XFx0XFx0Ly8gUkVQTEFDRU1FTlQgQ0hBUkFDVEVSLuKAnVxcblxcdFxcdFxcdGlmIChzdHJpY3QpIHtcXG5cXHRcXHRcXHRcXHRwYXJzZUVycm9yKCdjaGFyYWN0ZXIgcmVmZXJlbmNlIG91dHNpZGUgdGhlIHBlcm1pc3NpYmxlIFVuaWNvZGUgcmFuZ2UnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuICdcXFxcdUZGRkQnO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoaGFzKGRlY29kZU1hcE51bWVyaWMsIGNvZGVQb2ludCkpIHtcXG5cXHRcXHRcXHRpZiAoc3RyaWN0KSB7XFxuXFx0XFx0XFx0XFx0cGFyc2VFcnJvcignZGlzYWxsb3dlZCBjaGFyYWN0ZXIgcmVmZXJlbmNlJyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBkZWNvZGVNYXBOdW1lcmljW2NvZGVQb2ludF07XFxuXFx0XFx0fVxcblxcdFxcdGlmIChzdHJpY3QgJiYgY29udGFpbnMoaW52YWxpZFJlZmVyZW5jZUNvZGVQb2ludHMsIGNvZGVQb2ludCkpIHtcXG5cXHRcXHRcXHRwYXJzZUVycm9yKCdkaXNhbGxvd2VkIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xcblxcdFxcdFxcdGNvZGVQb2ludCAtPSAweDEwMDAwO1xcblxcdFxcdFxcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcXG5cXHRcXHRcXHRjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRjtcXG5cXHRcXHR9XFxuXFx0XFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xcblxcdFxcdHJldHVybiBvdXRwdXQ7XFxuXFx0fTtcXG5cXG5cXHR2YXIgaGV4RXNjYXBlID0gZnVuY3Rpb24oY29kZVBvaW50KSB7XFxuXFx0XFx0cmV0dXJuICcmI3gnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgJzsnO1xcblxcdH07XFxuXFxuXFx0dmFyIGRlY0VzY2FwZSA9IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xcblxcdFxcdHJldHVybiAnJiMnICsgY29kZVBvaW50ICsgJzsnO1xcblxcdH07XFxuXFxuXFx0dmFyIHBhcnNlRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XFxuXFx0XFx0dGhyb3cgRXJyb3IoJ1BhcnNlIGVycm9yOiAnICsgbWVzc2FnZSk7XFxuXFx0fTtcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG5cXHR2YXIgZW5jb2RlID0gZnVuY3Rpb24oc3RyaW5nLCBvcHRpb25zKSB7XFxuXFx0XFx0b3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIGVuY29kZS5vcHRpb25zKTtcXG5cXHRcXHR2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XFxuXFx0XFx0aWYgKHN0cmljdCAmJiByZWdleEludmFsaWRSYXdDb2RlUG9pbnQudGVzdChzdHJpbmcpKSB7XFxuXFx0XFx0XFx0cGFyc2VFcnJvcignZm9yYmlkZGVuIGNvZGUgcG9pbnQnKTtcXG5cXHRcXHR9XFxuXFx0XFx0dmFyIGVuY29kZUV2ZXJ5dGhpbmcgPSBvcHRpb25zLmVuY29kZUV2ZXJ5dGhpbmc7XFxuXFx0XFx0dmFyIHVzZU5hbWVkUmVmZXJlbmNlcyA9IG9wdGlvbnMudXNlTmFtZWRSZWZlcmVuY2VzO1xcblxcdFxcdHZhciBhbGxvd1Vuc2FmZVN5bWJvbHMgPSBvcHRpb25zLmFsbG93VW5zYWZlU3ltYm9scztcXG5cXHRcXHR2YXIgZXNjYXBlQ29kZVBvaW50ID0gb3B0aW9ucy5kZWNpbWFsID8gZGVjRXNjYXBlIDogaGV4RXNjYXBlO1xcblxcblxcdFxcdHZhciBlc2NhcGVCbXBTeW1ib2wgPSBmdW5jdGlvbihzeW1ib2wpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZXNjYXBlQ29kZVBvaW50KHN5bWJvbC5jaGFyQ29kZUF0KDApKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdGlmIChlbmNvZGVFdmVyeXRoaW5nKSB7XFxuXFx0XFx0XFx0Ly8gRW5jb2RlIEFTQ0lJIHN5bWJvbHMuXFxuXFx0XFx0XFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhBc2NpaVdoaXRlbGlzdCwgZnVuY3Rpb24oc3ltYm9sKSB7XFxuXFx0XFx0XFx0XFx0Ly8gVXNlIG5hbWVkIHJlZmVyZW5jZXMgaWYgcmVxdWVzdGVkICYgcG9zc2libGUuXFxuXFx0XFx0XFx0XFx0aWYgKHVzZU5hbWVkUmVmZXJlbmNlcyAmJiBoYXMoZW5jb2RlTWFwLCBzeW1ib2wpKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICcmJyArIGVuY29kZU1hcFtzeW1ib2xdICsgJzsnO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gZXNjYXBlQm1wU3ltYm9sKHN5bWJvbCk7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0Ly8gU2hvcnRlbiBhIGZldyBlc2NhcGVzIHRoYXQgcmVwcmVzZW50IHR3byBzeW1ib2xzLCBvZiB3aGljaCBhdCBsZWFzdCBvbmVcXG5cXHRcXHRcXHQvLyBpcyB3aXRoaW4gdGhlIEFTQ0lJIHJhbmdlLlxcblxcdFxcdFxcdGlmICh1c2VOYW1lZFJlZmVyZW5jZXMpIHtcXG5cXHRcXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmdcXG5cXHRcXHRcXHRcXHRcXHQucmVwbGFjZSgvJmd0O1xcXFx1MjBEMi9nLCAnJm52Z3Q7JylcXG5cXHRcXHRcXHRcXHRcXHQucmVwbGFjZSgvJmx0O1xcXFx1MjBEMi9nLCAnJm52bHQ7JylcXG5cXHRcXHRcXHRcXHRcXHQucmVwbGFjZSgvJiN4NjY7JiN4NkE7L2csICcmZmpsaWc7Jyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIEVuY29kZSBub24tQVNDSUkgc3ltYm9scy5cXG5cXHRcXHRcXHRpZiAodXNlTmFtZWRSZWZlcmVuY2VzKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRW5jb2RlIG5vbi1BU0NJSSBzeW1ib2xzIHRoYXQgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBuYW1lZCByZWZlcmVuY2UuXFxuXFx0XFx0XFx0XFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhFbmNvZGVOb25Bc2NpaSwgZnVuY3Rpb24oc3RyaW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gTm90ZTogdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBgaGFzKGVuY29kZU1hcCwgc3RyaW5nKWAgaGVyZS5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gJyYnICsgZW5jb2RlTWFwW3N0cmluZ10gKyAnOyc7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIE5vdGU6IGFueSByZW1haW5pbmcgbm9uLUFTQ0lJIHN5bWJvbHMgYXJlIGhhbmRsZWQgb3V0c2lkZSBvZiB0aGUgYGlmYC5cXG5cXHRcXHR9IGVsc2UgaWYgKHVzZU5hbWVkUmVmZXJlbmNlcykge1xcblxcdFxcdFxcdC8vIEFwcGx5IG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzLlxcblxcdFxcdFxcdC8vIEVuY29kZSBgPD5cXFwiJyZgIHVzaW5nIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzLlxcblxcdFxcdFxcdGlmICghYWxsb3dVbnNhZmVTeW1ib2xzKSB7XFxuXFx0XFx0XFx0XFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhFc2NhcGUsIGZ1bmN0aW9uKHN0cmluZykge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAnJicgKyBlbmNvZGVNYXBbc3RyaW5nXSArICc7JzsgLy8gbm8gbmVlZCB0byBjaGVjayBgaGFzKClgIGhlcmVcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gU2hvcnRlbiBlc2NhcGVzIHRoYXQgcmVwcmVzZW50IHR3byBzeW1ib2xzLCBvZiB3aGljaCBhdCBsZWFzdCBvbmUgaXNcXG5cXHRcXHRcXHQvLyBgPD5cXFwiJyZgLlxcblxcdFxcdFxcdHN0cmluZyA9IHN0cmluZ1xcblxcdFxcdFxcdFxcdC5yZXBsYWNlKC8mZ3Q7XFxcXHUyMEQyL2csICcmbnZndDsnKVxcblxcdFxcdFxcdFxcdC5yZXBsYWNlKC8mbHQ7XFxcXHUyMEQyL2csICcmbnZsdDsnKTtcXG5cXHRcXHRcXHQvLyBFbmNvZGUgbm9uLUFTQ0lJIHN5bWJvbHMgdGhhdCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIG5hbWVkIHJlZmVyZW5jZS5cXG5cXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEVuY29kZU5vbkFzY2lpLCBmdW5jdGlvbihzdHJpbmcpIHtcXG5cXHRcXHRcXHRcXHQvLyBOb3RlOiB0aGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoZW5jb2RlTWFwLCBzdHJpbmcpYCBoZXJlLlxcblxcdFxcdFxcdFxcdHJldHVybiAnJicgKyBlbmNvZGVNYXBbc3RyaW5nXSArICc7JztcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9IGVsc2UgaWYgKCFhbGxvd1Vuc2FmZVN5bWJvbHMpIHtcXG5cXHRcXHRcXHQvLyBFbmNvZGUgYDw+XFxcIicmYCB1c2luZyBoZXhhZGVjaW1hbCBlc2NhcGVzLCBub3cgdGhhdCB0aGV54oCZcmUgbm90IGhhbmRsZWRcXG5cXHRcXHRcXHQvLyB1c2luZyBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcy5cXG5cXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEVzY2FwZSwgZXNjYXBlQm1wU3ltYm9sKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHN0cmluZ1xcblxcdFxcdFxcdC8vIEVuY29kZSBhc3RyYWwgc3ltYm9scy5cXG5cXHRcXHRcXHQucmVwbGFjZShyZWdleEFzdHJhbFN5bWJvbHMsIGZ1bmN0aW9uKCQwKSB7XFxuXFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXFxuXFx0XFx0XFx0XFx0dmFyIGhpZ2ggPSAkMC5jaGFyQ29kZUF0KDApO1xcblxcdFxcdFxcdFxcdHZhciBsb3cgPSAkMC5jaGFyQ29kZUF0KDEpO1xcblxcdFxcdFxcdFxcdHZhciBjb2RlUG9pbnQgPSAoaGlnaCAtIDB4RDgwMCkgKiAweDQwMCArIGxvdyAtIDB4REMwMCArIDB4MTAwMDA7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVzY2FwZUNvZGVQb2ludChjb2RlUG9pbnQpO1xcblxcdFxcdFxcdH0pXFxuXFx0XFx0XFx0Ly8gRW5jb2RlIGFueSByZW1haW5pbmcgQk1QIHN5bWJvbHMgdGhhdCBhcmUgbm90IHByaW50YWJsZSBBU0NJSSBzeW1ib2xzXFxuXFx0XFx0XFx0Ly8gdXNpbmcgYSBoZXhhZGVjaW1hbCBlc2NhcGUuXFxuXFx0XFx0XFx0LnJlcGxhY2UocmVnZXhCbXBXaGl0ZWxpc3QsIGVzY2FwZUJtcFN5bWJvbCk7XFxuXFx0fTtcXG5cXHQvLyBFeHBvc2UgZGVmYXVsdCBvcHRpb25zIChzbyB0aGV5IGNhbiBiZSBvdmVycmlkZGVuIGdsb2JhbGx5KS5cXG5cXHRlbmNvZGUub3B0aW9ucyA9IHtcXG5cXHRcXHQnYWxsb3dVbnNhZmVTeW1ib2xzJzogZmFsc2UsXFxuXFx0XFx0J2VuY29kZUV2ZXJ5dGhpbmcnOiBmYWxzZSxcXG5cXHRcXHQnc3RyaWN0JzogZmFsc2UsXFxuXFx0XFx0J3VzZU5hbWVkUmVmZXJlbmNlcyc6IGZhbHNlLFxcblxcdFxcdCdkZWNpbWFsJyA6IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHR2YXIgZGVjb2RlID0gZnVuY3Rpb24oaHRtbCwgb3B0aW9ucykge1xcblxcdFxcdG9wdGlvbnMgPSBtZXJnZShvcHRpb25zLCBkZWNvZGUub3B0aW9ucyk7XFxuXFx0XFx0dmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xcblxcdFxcdGlmIChzdHJpY3QgJiYgcmVnZXhJbnZhbGlkRW50aXR5LnRlc3QoaHRtbCkpIHtcXG5cXHRcXHRcXHRwYXJzZUVycm9yKCdtYWxmb3JtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZScpO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gaHRtbC5yZXBsYWNlKHJlZ2V4RGVjb2RlLCBmdW5jdGlvbigkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcpIHtcXG5cXHRcXHRcXHR2YXIgY29kZVBvaW50O1xcblxcdFxcdFxcdHZhciBzZW1pY29sb247XFxuXFx0XFx0XFx0dmFyIGRlY0RpZ2l0cztcXG5cXHRcXHRcXHR2YXIgaGV4RGlnaXRzO1xcblxcdFxcdFxcdHZhciByZWZlcmVuY2U7XFxuXFx0XFx0XFx0dmFyIG5leHQ7XFxuXFx0XFx0XFx0aWYgKCQxKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRGVjb2RlIGRlY2ltYWwgZXNjYXBlcywgZS5nLiBgJiMxMTk1NTg7YC5cXG5cXHRcXHRcXHRcXHRkZWNEaWdpdHMgPSAkMTtcXG5cXHRcXHRcXHRcXHRzZW1pY29sb24gPSAkMjtcXG5cXHRcXHRcXHRcXHRpZiAoc3RyaWN0ICYmICFzZW1pY29sb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJzZUVycm9yKCdjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBub3QgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbicpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRjb2RlUG9pbnQgPSBwYXJzZUludChkZWNEaWdpdHMsIDEwKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY29kZVBvaW50VG9TeW1ib2woY29kZVBvaW50LCBzdHJpY3QpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoJDMpIHtcXG5cXHRcXHRcXHRcXHQvLyBEZWNvZGUgaGV4YWRlY2ltYWwgZXNjYXBlcywgZS5nLiBgJiN4MUQzMDY7YC5cXG5cXHRcXHRcXHRcXHRoZXhEaWdpdHMgPSAkMztcXG5cXHRcXHRcXHRcXHRzZW1pY29sb24gPSAkNDtcXG5cXHRcXHRcXHRcXHRpZiAoc3RyaWN0ICYmICFzZW1pY29sb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJzZUVycm9yKCdjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBub3QgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbicpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRjb2RlUG9pbnQgPSBwYXJzZUludChoZXhEaWdpdHMsIDE2KTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY29kZVBvaW50VG9TeW1ib2woY29kZVBvaW50LCBzdHJpY3QpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoJDUpIHtcXG5cXHRcXHRcXHRcXHQvLyBEZWNvZGUgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMgd2l0aCB0cmFpbGluZyBgO2AsIGUuZy4gYCZjb3B5O2AuXFxuXFx0XFx0XFx0XFx0cmVmZXJlbmNlID0gJDU7XFxuXFx0XFx0XFx0XFx0aWYgKGhhcyhkZWNvZGVNYXAsIHJlZmVyZW5jZSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZGVjb2RlTWFwW3JlZmVyZW5jZV07XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBBbWJpZ3VvdXMgYW1wZXJzYW5kLiBodHRwczovL210aHMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHNcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3RyaWN0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFyc2VFcnJvcihcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQnbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSB3YXMgbm90IHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24nXFxuXFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICQwO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gSWYgd2XigJlyZSBzdGlsbCBoZXJlLCBpdOKAmXMgYSBsZWdhY3kgcmVmZXJlbmNlIGZvciBzdXJlLiBObyBuZWVkIGZvciBhblxcblxcdFxcdFxcdC8vIGV4dHJhIGBpZmAgY2hlY2suXFxuXFx0XFx0XFx0Ly8gRGVjb2RlIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzIHdpdGhvdXQgdHJhaWxpbmcgYDtgLCBlLmcuIGAmYW1wYFxcblxcdFxcdFxcdC8vIFRoaXMgaXMgb25seSBhIHBhcnNlIGVycm9yIGlmIGl0IGdldHMgY29udmVydGVkIHRvIGAmYCwgb3IgaWYgaXQgaXNcXG5cXHRcXHRcXHQvLyBmb2xsb3dlZCBieSBgPWAgaW4gYW4gYXR0cmlidXRlIGNvbnRleHQuXFxuXFx0XFx0XFx0cmVmZXJlbmNlID0gJDY7XFxuXFx0XFx0XFx0bmV4dCA9ICQ3O1xcblxcdFxcdFxcdGlmIChuZXh0ICYmIG9wdGlvbnMuaXNBdHRyaWJ1dGVWYWx1ZSkge1xcblxcdFxcdFxcdFxcdGlmIChzdHJpY3QgJiYgbmV4dCA9PSAnPScpIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJzZUVycm9yKCdgJmAgZGlkIG5vdCBzdGFydCBhIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuICQwO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0aWYgKHN0cmljdCkge1xcblxcdFxcdFxcdFxcdFxcdHBhcnNlRXJyb3IoXFxuXFx0XFx0XFx0XFx0XFx0XFx0J25hbWVkIGNoYXJhY3RlciByZWZlcmVuY2Ugd2FzIG5vdCB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uJ1xcblxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8vIE5vdGU6IHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgYGhhcyhkZWNvZGVNYXBMZWdhY3ksIHJlZmVyZW5jZSlgLlxcblxcdFxcdFxcdFxcdHJldHVybiBkZWNvZGVNYXBMZWdhY3lbcmVmZXJlbmNlXSArIChuZXh0IHx8ICcnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0fTtcXG5cXHQvLyBFeHBvc2UgZGVmYXVsdCBvcHRpb25zIChzbyB0aGV5IGNhbiBiZSBvdmVycmlkZGVuIGdsb2JhbGx5KS5cXG5cXHRkZWNvZGUub3B0aW9ucyA9IHtcXG5cXHRcXHQnaXNBdHRyaWJ1dGVWYWx1ZSc6IGZhbHNlLFxcblxcdFxcdCdzdHJpY3QnOiBmYWxzZVxcblxcdH07XFxuXFxuXFx0dmFyIGVzY2FwZSA9IGZ1bmN0aW9uKHN0cmluZykge1xcblxcdFxcdHJldHVybiBzdHJpbmcucmVwbGFjZShyZWdleEVzY2FwZSwgZnVuY3Rpb24oJDApIHtcXG5cXHRcXHRcXHQvLyBOb3RlOiB0aGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoZXNjYXBlTWFwLCAkMClgIGhlcmUuXFxuXFx0XFx0XFx0cmV0dXJuIGVzY2FwZU1hcFskMF07XFxuXFx0XFx0fSk7XFxuXFx0fTtcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG5cXHR2YXIgaGUgPSB7XFxuXFx0XFx0J3ZlcnNpb24nOiAnMS4xLjEnLFxcblxcdFxcdCdlbmNvZGUnOiBlbmNvZGUsXFxuXFx0XFx0J2RlY29kZSc6IGRlY29kZSxcXG5cXHRcXHQnZXNjYXBlJzogZXNjYXBlLFxcblxcdFxcdCd1bmVzY2FwZSc6IGRlY29kZVxcblxcdH07XFxuXFxuXFx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXFxuXFx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxcblxcdGlmIChcXG5cXHRcXHRmYWxzZVxcblxcdCkge1xcblxcdFxcdGRlZmluZShmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXR1cm4gaGU7XFxuXFx0XFx0fSk7XFxuXFx0fVxcdGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xcblxcdFxcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcXG5cXHRcXHRcXHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBoZTtcXG5cXHRcXHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxcblxcdFxcdFxcdGZvciAodmFyIGtleSBpbiBoZSkge1xcblxcdFxcdFxcdFxcdGhhcyhoZSwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IGhlW2tleV0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxcblxcdFxcdHJvb3QuaGUgPSBoZTtcXG5cXHR9XFxuXFxufSh0aGlzKSk7XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XFxuICB2YXIgZSwgbVxcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxcbiAgdmFyIG5CaXRzID0gLTdcXG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cXG5cXG4gIGkgKz0gZFxcblxcbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcXG4gIHMgPj49ICgtbkJpdHMpXFxuICBuQml0cyArPSBlTGVuXFxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XFxuXFxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxcbiAgZSA+Pj0gKC1uQml0cylcXG4gIG5CaXRzICs9IG1MZW5cXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cXG5cXG4gIGlmIChlID09PSAwKSB7XFxuICAgIGUgPSAxIC0gZUJpYXNcXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcXG4gIH0gZWxzZSB7XFxuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcXG4gICAgZSA9IGUgLSBlQmlhc1xcbiAgfVxcbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcXG59XFxuXFxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xcbiAgdmFyIGUsIG0sIGNcXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXFxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcXG5cXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXFxuXFxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcXG4gICAgZSA9IGVNYXhcXG4gIH0gZWxzZSB7XFxuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XFxuICAgICAgZS0tXFxuICAgICAgYyAqPSAyXFxuICAgIH1cXG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XFxuICAgICAgdmFsdWUgKz0gcnQgLyBjXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXFxuICAgIH1cXG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XFxuICAgICAgZSsrXFxuICAgICAgYyAvPSAyXFxuICAgIH1cXG5cXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XFxuICAgICAgbSA9IDBcXG4gICAgICBlID0gZU1heFxcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XFxuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcXG4gICAgICBlID0gZSArIGVCaWFzXFxuICAgIH0gZWxzZSB7XFxuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXFxuICAgICAgZSA9IDBcXG4gICAgfVxcbiAgfVxcblxcbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cXG5cXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cXG4gIGVMZW4gKz0gbUxlblxcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxcblxcbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XFxufVxcblxcbn0se31dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcXG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXFxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xcbiAgICAgIGNvbnN0cnVjdG9yOiB7XFxuICAgICAgICB2YWx1ZTogY3RvcixcXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfTtcXG59IGVsc2Uge1xcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XFxuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXFxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XFxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcXG4gIH1cXG59XFxuXFxufSx7fV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qIVxcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcXG4gKlxcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XFxuICogQGxpY2Vuc2UgIE1JVFxcbiAqL1xcblxcbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3NpbmdcXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XFxuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxcbn1cXG5cXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XFxuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxcbn1cXG5cXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxcbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XFxuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcXG59XFxuXFxufSx7fV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xcblxcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XFxuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XFxufTtcXG5cXG59LHt9XSw1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xcbnZhciBfMDc3NyA9IHBhcnNlSW50KCcwNzc3JywgOCk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBta2RpclAubWtkaXJwID0gbWtkaXJQLm1rZGlyUCA9IG1rZGlyUDtcXG5cXG5mdW5jdGlvbiBta2RpclAgKHAsIG9wdHMsIGYsIG1hZGUpIHtcXG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICBmID0gb3B0cztcXG4gICAgICAgIG9wdHMgPSB7fTtcXG4gICAgfVxcbiAgICBlbHNlIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfTtcXG4gICAgfVxcbiAgICBcXG4gICAgdmFyIG1vZGUgPSBvcHRzLm1vZGU7XFxuICAgIHZhciB4ZnMgPSBvcHRzLmZzIHx8IGZzO1xcbiAgICBcXG4gICAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgbW9kZSA9IF8wNzc3ICYgKH5wcm9jZXNzLnVtYXNrKCkpO1xcbiAgICB9XFxuICAgIGlmICghbWFkZSkgbWFkZSA9IG51bGw7XFxuICAgIFxcbiAgICB2YXIgY2IgPSBmIHx8IGZ1bmN0aW9uICgpIHt9O1xcbiAgICBwID0gcGF0aC5yZXNvbHZlKHApO1xcbiAgICBcXG4gICAgeGZzLm1rZGlyKHAsIG1vZGUsIGZ1bmN0aW9uIChlcikge1xcbiAgICAgICAgaWYgKCFlcikge1xcbiAgICAgICAgICAgIG1hZGUgPSBtYWRlIHx8IHA7XFxuICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIG1hZGUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3dpdGNoIChlci5jb2RlKSB7XFxuICAgICAgICAgICAgY2FzZSAnRU5PRU5UJzpcXG4gICAgICAgICAgICAgICAgbWtkaXJQKHBhdGguZGlybmFtZShwKSwgb3B0cywgZnVuY3Rpb24gKGVyLCBtYWRlKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXIpIGNiKGVyLCBtYWRlKTtcXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgbWtkaXJQKHAsIG9wdHMsIGNiLCBtYWRlKTtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpclxcbiAgICAgICAgICAgIC8vIHRoZXJlIGFscmVhZHkuICBJZiBzbywgdGhlbiBob29yYXkhICBJZiBub3QsIHRoZW4gc29tZXRoaW5nXFxuICAgICAgICAgICAgLy8gaXMgYm9ya2VkLlxcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIHhmcy5zdGF0KHAsIGZ1bmN0aW9uIChlcjIsIHN0YXQpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzdGF0IGZhaWxzLCB0aGVuIHRoYXQncyBzdXBlciB3ZWlyZC5cXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCB0aGUgb3JpZ2luYWwgZXJyb3IgYmUgdGhlIGZhaWx1cmUgcmVhc29uLlxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyMiB8fCAhc3RhdC5pc0RpcmVjdG9yeSgpKSBjYihlciwgbWFkZSlcXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgY2IobnVsbCwgbWFkZSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgfSk7XFxufVxcblxcbm1rZGlyUC5zeW5jID0gZnVuY3Rpb24gc3luYyAocCwgb3B0cywgbWFkZSkge1xcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XFxuICAgICAgICBvcHRzID0geyBtb2RlOiBvcHRzIH07XFxuICAgIH1cXG4gICAgXFxuICAgIHZhciBtb2RlID0gb3B0cy5tb2RlO1xcbiAgICB2YXIgeGZzID0gb3B0cy5mcyB8fCBmcztcXG4gICAgXFxuICAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIG1vZGUgPSBfMDc3NyAmICh+cHJvY2Vzcy51bWFzaygpKTtcXG4gICAgfVxcbiAgICBpZiAoIW1hZGUpIG1hZGUgPSBudWxsO1xcblxcbiAgICBwID0gcGF0aC5yZXNvbHZlKHApO1xcblxcbiAgICB0cnkge1xcbiAgICAgICAgeGZzLm1rZGlyU3luYyhwLCBtb2RlKTtcXG4gICAgICAgIG1hZGUgPSBtYWRlIHx8IHA7XFxuICAgIH1cXG4gICAgY2F0Y2ggKGVycjApIHtcXG4gICAgICAgIHN3aXRjaCAoZXJyMC5jb2RlKSB7XFxuICAgICAgICAgICAgY2FzZSAnRU5PRU5UJyA6XFxuICAgICAgICAgICAgICAgIG1hZGUgPSBzeW5jKHBhdGguZGlybmFtZShwKSwgb3B0cywgbWFkZSk7XFxuICAgICAgICAgICAgICAgIHN5bmMocCwgb3B0cywgbWFkZSk7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpclxcbiAgICAgICAgICAgIC8vIHRoZXJlIGFscmVhZHkuICBJZiBzbywgdGhlbiBob29yYXkhICBJZiBub3QsIHRoZW4gc29tZXRoaW5nXFxuICAgICAgICAgICAgLy8gaXMgYm9ya2VkLlxcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIHZhciBzdGF0O1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHhmcy5zdGF0U3luYyhwKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyMSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXQuaXNEaXJlY3RvcnkoKSkgdGhyb3cgZXJyMDtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG1hZGU7XFxufTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJmc1xcXCI6NDAsXFxcInBhdGhcXFwiOjQwfV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIEhlbHBlcnMuXFxuICovXFxuXFxudmFyIHMgPSAxMDAwO1xcbnZhciBtID0gcyAqIDYwO1xcbnZhciBoID0gbSAqIDYwO1xcbnZhciBkID0gaCAqIDI0O1xcbnZhciB5ID0gZCAqIDM2NS4yNTtcXG5cXG4vKipcXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxcbiAqXFxuICogT3B0aW9uczpcXG4gKlxcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXFxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXFxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcXG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcXG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XFxuICB9XFxuICB0aHJvdyBuZXcgRXJyb3IoXFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXFxuICogQHJldHVybiB7TnVtYmVyfVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xcbiAgc3RyID0gU3RyaW5nKHN0cik7XFxuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXFxcZCspP1xcXFwuP1xcXFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxcbiAgICBzdHJcXG4gICk7XFxuICBpZiAoIW1hdGNoKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XFxuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xcbiAgc3dpdGNoICh0eXBlKSB7XFxuICAgIGNhc2UgJ3llYXJzJzpcXG4gICAgY2FzZSAneWVhcic6XFxuICAgIGNhc2UgJ3lycyc6XFxuICAgIGNhc2UgJ3lyJzpcXG4gICAgY2FzZSAneSc6XFxuICAgICAgcmV0dXJuIG4gKiB5O1xcbiAgICBjYXNlICdkYXlzJzpcXG4gICAgY2FzZSAnZGF5JzpcXG4gICAgY2FzZSAnZCc6XFxuICAgICAgcmV0dXJuIG4gKiBkO1xcbiAgICBjYXNlICdob3Vycyc6XFxuICAgIGNhc2UgJ2hvdXInOlxcbiAgICBjYXNlICdocnMnOlxcbiAgICBjYXNlICdocic6XFxuICAgIGNhc2UgJ2gnOlxcbiAgICAgIHJldHVybiBuICogaDtcXG4gICAgY2FzZSAnbWludXRlcyc6XFxuICAgIGNhc2UgJ21pbnV0ZSc6XFxuICAgIGNhc2UgJ21pbnMnOlxcbiAgICBjYXNlICdtaW4nOlxcbiAgICBjYXNlICdtJzpcXG4gICAgICByZXR1cm4gbiAqIG07XFxuICAgIGNhc2UgJ3NlY29uZHMnOlxcbiAgICBjYXNlICdzZWNvbmQnOlxcbiAgICBjYXNlICdzZWNzJzpcXG4gICAgY2FzZSAnc2VjJzpcXG4gICAgY2FzZSAncyc6XFxuICAgICAgcmV0dXJuIG4gKiBzO1xcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XFxuICAgIGNhc2UgJ21zZWNzJzpcXG4gICAgY2FzZSAnbXNlYyc6XFxuICAgIGNhc2UgJ21zJzpcXG4gICAgICByZXR1cm4gbjtcXG4gICAgZGVmYXVsdDpcXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXFxuICpcXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcXG4gKiBAcmV0dXJuIHtTdHJpbmd9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcXG4gIGlmIChtcyA+PSBkKSB7XFxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XFxuICB9XFxuICBpZiAobXMgPj0gaCkge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xcbiAgfVxcbiAgaWYgKG1zID49IG0pIHtcXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcXG4gIH1cXG4gIGlmIChtcyA+PSBzKSB7XFxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XFxuICB9XFxuICByZXR1cm4gbXMgKyAnbXMnO1xcbn1cXG5cXG4vKipcXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cXG4gKlxcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xcbiAqIEByZXR1cm4ge1N0cmluZ31cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XFxuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcXG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XFxuICAgIG1zICsgJyBtcyc7XFxufVxcblxcbi8qKlxcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxcbiAqL1xcblxcbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xcbiAgaWYgKG1zIDwgbikge1xcbiAgICByZXR1cm47XFxuICB9XFxuICBpZiAobXMgPCBuICogMS41KSB7XFxuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xcbiAgfVxcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcXG59XFxuXFxufSx7fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcXG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcXG59IGVsc2Uge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXFxufVxcblxcbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XFxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJjYWxsYmFja1xcXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XFxuICB9XFxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gIHZhciBhcmdzLCBpO1xcbiAgc3dpdGNoIChsZW4pIHtcXG4gIGNhc2UgMDpcXG4gIGNhc2UgMTpcXG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xcbiAgY2FzZSAyOlxcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XFxuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcXG4gICAgfSk7XFxuICBjYXNlIDM6XFxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcXG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xcbiAgICB9KTtcXG4gIGNhc2UgNDpcXG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XFxuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcXG4gICAgfSk7XFxuICBkZWZhdWx0OlxcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xcbiAgICBpID0gMDtcXG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcXG4gICAgfVxcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XFxuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XFxuICAgIH0pO1xcbiAgfVxcbn1cXG5cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiX3Byb2Nlc3NcXFwiOjU2fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcXG5cXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcXG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXFxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cXG5cXG52YXIgY2FjaGVkU2V0VGltZW91dDtcXG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xcblxcbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xcbn1cXG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcXG59XFxuKGZ1bmN0aW9uICgpIHtcXG4gICAgdHJ5IHtcXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcXG4gICAgICAgIH1cXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xcbiAgICB9XFxufSAoKSlcXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXFxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9XFxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XFxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXFxuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9IGNhdGNoKGUpe1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XFxuICAgICAgICB9IGNhdGNoKGUpe1xcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuXFxufVxcbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcXG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XFxuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcXG4gICAgfVxcbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXFxuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XFxuICAgIH0gY2F0Y2ggKGUpe1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XFxuICAgICAgICB9IGNhdGNoIChlKXtcXG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG5cXG5cXG59XFxudmFyIHF1ZXVlID0gW107XFxudmFyIGRyYWluaW5nID0gZmFsc2U7XFxudmFyIGN1cnJlbnRRdWV1ZTtcXG52YXIgcXVldWVJbmRleCA9IC0xO1xcblxcbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcXG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcXG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcXG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XFxuICAgIH1cXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xcbiAgICB9XFxufVxcblxcbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XFxuICAgIGlmIChkcmFpbmluZykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xcbiAgICBkcmFpbmluZyA9IHRydWU7XFxuXFxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XFxuICAgIHdoaWxlKGxlbikge1xcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XFxuICAgICAgICBxdWV1ZSA9IFtdO1xcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcXG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcXG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcXG4gICAgfVxcbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XFxufVxcblxcbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XFxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XFxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XFxuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xcbiAgICB9XFxufTtcXG5cXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXFxuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XFxuICAgIHRoaXMuZnVuID0gZnVuO1xcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XFxufVxcbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XFxufTtcXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XFxucHJvY2Vzcy5lbnYgPSB7fTtcXG5wcm9jZXNzLmFyZ3YgPSBbXTtcXG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcXG5wcm9jZXNzLnZlcnNpb25zID0ge307XFxuXFxuZnVuY3Rpb24gbm9vcCgpIHt9XFxuXFxucHJvY2Vzcy5vbiA9IG5vb3A7XFxucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5vbmNlID0gbm9vcDtcXG5wcm9jZXNzLm9mZiA9IG5vb3A7XFxucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XFxucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XFxuXFxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxcblxcbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcXG59O1xcblxcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XFxucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcXG59O1xcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XFxuXFxufSx7fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcXG5cXG59LHtcXFwiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcXFwiOjU4fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXFxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3NcXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXFxuLy8gV3JpdGFibGUuXFxuXFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxuXFxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcXG4gIHZhciBrZXlzID0gW107XFxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XFxuICAgIGtleXMucHVzaChrZXkpO1xcbiAgfXJldHVybiBrZXlzO1xcbn07XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xcblxcbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XFxuXFxue1xcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XFxuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcXG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XFxuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcXG5cXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XFxuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xcblxcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcXG5cXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XFxuXFxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XFxuXFxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcXG59XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XFxuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXFxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcXG4gIGVudW1lcmFibGU6IGZhbHNlLFxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XFxuICB9XFxufSk7XFxuXFxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxcbmZ1bmN0aW9uIG9uZW5kKCkge1xcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcXG4gIC8vIHRoZW4gd2UncmUgb2suXFxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcXG5cXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxcbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xcbn1cXG5cXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcXG4gIHNlbGYuZW5kKCk7XFxufVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcXG4gIH0sXFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XFxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xcbiAgfVxcbn0pO1xcblxcbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xcbiAgdGhpcy5wdXNoKG51bGwpO1xcbiAgdGhpcy5lbmQoKTtcXG5cXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcXG59O1xcbn0se1xcXCIuL19zdHJlYW1fcmVhZGFibGVcXFwiOjYwLFxcXCIuL19zdHJlYW1fd3JpdGFibGVcXFwiOjYyLFxcXCJjb3JlLXV0aWwtaXNcXFwiOjQyLFxcXCJpbmhlcml0c1xcXCI6NTAsXFxcInByb2Nlc3MtbmV4dGljay1hcmdzXFxcIjo1NX1dLDU5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxcblxcbid1c2Ugc3RyaWN0JztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xcblxcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XFxuXFxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcXG5cXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xcbn1cXG5cXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICBjYihudWxsLCBjaHVuayk7XFxufTtcXG59LHtcXFwiLi9fc3RyZWFtX3RyYW5zZm9ybVxcXCI6NjEsXFxcImNvcmUtdXRpbC1pc1xcXCI6NDIsXFxcImluaGVyaXRzXFxcIjo1MH1dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG4ndXNlIHN0cmljdCc7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgRHVwbGV4O1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcblxcbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcXG59O1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcblxcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcXG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XFxufVxcbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XFxuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcXG59XFxuXFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcXG52YXIgZGVidWcgPSB2b2lkIDA7XFxuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcXG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcXG59IGVsc2Uge1xcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcXG59XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XFxudmFyIFN0cmluZ0RlY29kZXI7XFxuXFxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcXG5cXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xcblxcbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcXG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXFxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xcblxcbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXFxuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXFxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXFxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcXG59XFxuXFxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcXG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XFxuXFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXFxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxcbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXFxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XFxuXFxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xcbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xcblxcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcXG5cXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXFxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFxcXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXFxcIlxcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcXG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcXG5cXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xcblxcbiAgLy8gY2FzdCB0byBpbnRzLlxcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xcblxcbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXFxuICAvLyBhcnJheS5zaGlmdCgpXFxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XFxuICB0aGlzLmxlbmd0aCA9IDA7XFxuICB0aGlzLnBpcGVzID0gbnVsbDtcXG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XFxuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XFxuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcXG5cXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXFxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXFxcImxhdGVyXFxcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXFxuICB0aGlzLnN5bmMgPSB0cnVlO1xcblxcbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcXG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxcbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcXG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XFxuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XFxuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xcblxcbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xcblxcbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxcbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxcbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XFxuXFxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcXG5cXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcXG5cXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XFxuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcXG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XFxuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XFxuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcXG5cXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XFxuXFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XFxuXFxuICAvLyBsZWdhY3lcXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xcblxcbiAgaWYgKG9wdGlvbnMpIHtcXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XFxuXFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xcbiAgfVxcblxcbiAgU3RyZWFtLmNhbGwodGhpcyk7XFxufVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XFxuICB9LFxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXFxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcXG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcXG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XFxuICB9XFxufSk7XFxuXFxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XFxuICB0aGlzLnB1c2gobnVsbCk7XFxuICBjYihlcnIpO1xcbn07XFxuXFxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXFxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxcblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gIHZhciBza2lwQ2h1bmtDaGVjaztcXG5cXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcXG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcXG4gICAgICAgIGVuY29kaW5nID0gJyc7XFxuICAgICAgfVxcbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xcbn07XFxuXFxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcXG59O1xcblxcbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XFxuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XFxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcXG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xcbiAgfSBlbHNlIHtcXG4gICAgdmFyIGVyO1xcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xcbiAgICBpZiAoZXIpIHtcXG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XFxuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcXG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcXG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcXG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcXG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xcbn1cXG5cXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XFxuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xcbiAgICBzdHJlYW0ucmVhZCgwKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXFxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcXG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcXG5cXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XFxuICB9XFxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xcbn1cXG5cXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XFxuICB2YXIgZXI7XFxuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcXG4gIH1cXG4gIHJldHVybiBlcjtcXG59XFxuXFxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXFxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxcbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcXG59XFxuXFxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XFxufTtcXG5cXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XFxuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcXG4gIGlmIChuID49IE1BWF9IV00pIHtcXG4gICAgbiA9IE1BWF9IV007XFxuICB9IGVsc2Uge1xcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cXG4gICAgLy8gdGlueSBhbW91bnRzXFxuICAgIG4tLTtcXG4gICAgbiB8PSBuID4+PiAxO1xcbiAgICBuIHw9IG4gPj4+IDI7XFxuICAgIG4gfD0gbiA+Pj4gNDtcXG4gICAgbiB8PSBuID4+PiA4O1xcbiAgICBuIHw9IG4gPj4+IDE2O1xcbiAgICBuKys7XFxuICB9XFxuICByZXR1cm4gbjtcXG59XFxuXFxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxcbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcXG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcXG4gIGlmIChuICE9PSBuKSB7XFxuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XFxuICB9XFxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcXG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XFxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XFxuICAgIHJldHVybiAwO1xcbiAgfVxcbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcXG59XFxuXFxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XFxuICBkZWJ1ZygncmVhZCcsIG4pO1xcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICB2YXIgbk9yaWcgPSBuO1xcblxcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xcblxcbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXFxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XFxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xcbiAgICByZXR1cm4gbnVsbDtcXG4gIH1cXG5cXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcXG5cXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XFxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xcbiAgICByZXR1cm4gbnVsbDtcXG4gIH1cXG5cXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxcbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxcbiAgLy9cXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xcbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cXG4gIC8vXFxuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxcbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXFxuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXFxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcXG4gIC8vICdyZWFkYWJsZScgZXRjLlxcbiAgLy9cXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cXG5cXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XFxuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XFxuXFxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcXG4gICAgZG9SZWFkID0gdHJ1ZTtcXG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcXG4gIH1cXG5cXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XFxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXFxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xcbiAgICBkb1JlYWQgPSBmYWxzZTtcXG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcXG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcXG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XFxuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XFxuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcXG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxcbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XFxuICB9XFxuXFxuICB2YXIgcmV0O1xcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xcblxcbiAgaWYgKHJldCA9PT0gbnVsbCkge1xcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xcbiAgICBuID0gMDtcXG4gIH0gZWxzZSB7XFxuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xcbiAgfVxcblxcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcXG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xcblxcbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXFxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XFxuICB9XFxuXFxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xcblxcbiAgcmV0dXJuIHJldDtcXG59O1xcblxcbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XFxuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XFxuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcXG4gICAgfVxcbiAgfVxcbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xcblxcbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXFxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcXG59XFxuXFxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXFxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXFxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxcbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcXG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcXG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XFxuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XFxuICBmbG93KHN0cmVhbSk7XFxufVxcblxcbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXFxuLy8gaXQncyBpbiBwcm9ncmVzcy5cXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXFxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XFxuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcXG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcXG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcXG4gICAgc3RyZWFtLnJlYWQoMCk7XFxuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxcbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xcbiAgfVxcbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcXG59XFxuXFxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxcbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXFxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFxcXCJsZW5ndGhcXFwiIGlzIHNvbWV3aGF0XFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxcblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XFxuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcXG59O1xcblxcblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XFxuICB2YXIgc3JjID0gdGhpcztcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuXFxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcXG4gICAgY2FzZSAwOlxcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAxOlxcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcXG4gICAgICBicmVhaztcXG4gICAgZGVmYXVsdDpcXG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xcbiAgICAgIGJyZWFrO1xcbiAgfVxcbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcXG5cXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XFxuXFxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xcblxcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcXG4gICAgZGVidWcoJ29udW5waXBlJyk7XFxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XFxuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcXG4gICAgICAgIGNsZWFudXAoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xcbiAgICBkZWJ1Zygnb25lbmQnKTtcXG4gICAgZGVzdC5lbmQoKTtcXG4gIH1cXG5cXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcXG4gIC8vIHRvbyBzbG93LlxcbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcXG5cXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XFxuICAgIGRlYnVnKCdjbGVhbnVwJyk7XFxuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XFxuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XFxuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XFxuXFxuICAgIGNsZWFuZWRVcCA9IHRydWU7XFxuXFxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXFxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XFxuICB9XFxuXFxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXFxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXFxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xcbiAgICBkZWJ1Zygnb25kYXRhJyk7XFxuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcXG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXFxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XFxuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcXG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgICBzcmMucGF1c2UoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXFxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXFxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XFxuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xcbiAgICB1bnBpcGUoKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcXG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcXG4gIH1cXG5cXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcXG5cXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXFxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XFxuICAgIHVucGlwZSgpO1xcbiAgfVxcbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XFxuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xcbiAgICB1bnBpcGUoKTtcXG4gIH1cXG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xcblxcbiAgZnVuY3Rpb24gdW5waXBlKCkge1xcbiAgICBkZWJ1ZygndW5waXBlJyk7XFxuICAgIHNyYy51bnBpcGUoZGVzdCk7XFxuICB9XFxuXFxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xcbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcXG5cXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcXG4gICAgc3JjLnJlc3VtZSgpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGRlc3Q7XFxufTtcXG5cXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcXG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XFxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XFxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcXG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcXG4gICAgICBmbG93KHNyYyk7XFxuICAgIH1cXG4gIH07XFxufVxcblxcblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xcblxcbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xcblxcbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcXG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXFxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcXG5cXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XFxuXFxuICAgIC8vIGdvdCBhIG1hdGNoLlxcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XFxuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XFxuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG5cXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXFxuXFxuICBpZiAoIWRlc3QpIHtcXG4gICAgLy8gcmVtb3ZlIGFsbC5cXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XFxuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XFxuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcXG4gICAgfXJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XFxuXFxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XFxuXFxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXFxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XFxuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XFxuXFxuICBpZiAoZXYgPT09ICdkYXRhJykge1xcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XFxuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XFxuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcXG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XFxuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XFxuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XFxuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XFxuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcXG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiByZXM7XFxufTtcXG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XFxuXFxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XFxuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XFxuICBzZWxmLnJlYWQoMCk7XFxufVxcblxcbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXFxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcXG4gICAgZGVidWcoJ3Jlc3VtZScpO1xcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcXG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XFxuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XFxuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcXG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcXG4gICAgc3RyZWFtLnJlYWQoMCk7XFxuICB9XFxuXFxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcXG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xcbiAgZmxvdyhzdHJlYW0pO1xcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xcbn1cXG5cXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XFxuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XFxuICAgIGRlYnVnKCdwYXVzZScpO1xcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcXG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcXG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XFxufVxcblxcbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXFxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxcbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxcblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xcbiAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICB2YXIgcGF1c2VkID0gZmFsc2U7XFxuXFxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XFxuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XFxuICAgIH1cXG5cXG4gICAgX3RoaXMucHVzaChudWxsKTtcXG4gIH0pO1xcblxcbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XFxuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcXG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XFxuXFxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XFxuXFxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcXG4gICAgaWYgKCFyZXQpIHtcXG4gICAgICBwYXVzZWQgPSB0cnVlO1xcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxcbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcXG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XFxuICAgICAgICB9O1xcbiAgICAgIH0oaSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XFxuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xcbiAgfVxcblxcbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXFxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcXG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcXG4gICAgaWYgKHBhdXNlZCkge1xcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcXG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXFxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxcbiAgZW51bWVyYWJsZTogZmFsc2UsXFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcXG4gIH1cXG59KTtcXG5cXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXFxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XFxuXFxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxcbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXFxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxcbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XFxuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcXG5cXG4gIHZhciByZXQ7XFxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcXG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcXG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XFxuICB9IGVsc2Uge1xcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcXG4gIH1cXG5cXG4gIHJldHVybiByZXQ7XFxufVxcblxcbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXFxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcXG4gIHZhciByZXQ7XFxuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcXG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcXG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XFxuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XFxuICB9IGVsc2Uge1xcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XFxuICB9XFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXFxuLy8gY2h1bmtzLlxcbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXFxuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XFxuICB2YXIgcCA9IGxpc3QuaGVhZDtcXG4gIHZhciBjID0gMTtcXG4gIHZhciByZXQgPSBwLmRhdGE7XFxuICBuIC09IHJldC5sZW5ndGg7XFxuICB3aGlsZSAocCA9IHAubmV4dCkge1xcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xcbiAgICBuIC09IG5iO1xcbiAgICBpZiAobiA9PT0gMCkge1xcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xcbiAgICAgICAgKytjO1xcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcXG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XFxuICAgICAgfVxcbiAgICAgIGJyZWFrO1xcbiAgICB9XFxuICAgICsrYztcXG4gIH1cXG4gIGxpc3QubGVuZ3RoIC09IGM7XFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXFxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxcbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcXG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XFxuICB2YXIgcCA9IGxpc3QuaGVhZDtcXG4gIHZhciBjID0gMTtcXG4gIHAuZGF0YS5jb3B5KHJldCk7XFxuICBuIC09IHAuZGF0YS5sZW5ndGg7XFxuICB3aGlsZSAocCA9IHAubmV4dCkge1xcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XFxuICAgIG4gLT0gbmI7XFxuICAgIGlmIChuID09PSAwKSB7XFxuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XFxuICAgICAgICArK2M7XFxuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBsaXN0LmhlYWQgPSBwO1xcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcXG4gICAgICB9XFxuICAgICAgYnJlYWs7XFxuICAgIH1cXG4gICAgKytjO1xcbiAgfVxcbiAgbGlzdC5sZW5ndGggLT0gYztcXG4gIHJldHVybiByZXQ7XFxufVxcblxcbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xcblxcbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxcbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXFxcImVuZFJlYWRhYmxlKClcXFwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XFxuXFxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcXG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXFxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XFxuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcXG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xcbiAgfVxcbiAgcmV0dXJuIC0xO1xcbn1cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuL19zdHJlYW1fZHVwbGV4XFxcIjo1OCxcXFwiLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3RcXFwiOjYzLFxcXCIuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveVxcXCI6NjQsXFxcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW1cXFwiOjY1LFxcXCJfcHJvY2Vzc1xcXCI6NTYsXFxcImNvcmUtdXRpbC1pc1xcXCI6NDIsXFxcImV2ZW50c1xcXCI6NDcsXFxcImluaGVyaXRzXFxcIjo1MCxcXFwiaXNhcnJheVxcXCI6NTIsXFxcInByb2Nlc3MtbmV4dGljay1hcmdzXFxcIjo1NSxcXFwic2FmZS1idWZmZXJcXFwiOjcwLFxcXCJzdHJpbmdfZGVjb2Rlci9cXFwiOjcyLFxcXCJ1dGlsXFxcIjozOH1dLDYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXFxuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcXFwiZmlsdGVyXFxcIixcXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXFxuLy9cXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXFxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXFxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxcbi8vXFxuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxcbi8vXFxuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXFxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxcbi8vXFxuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXFxuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5Llxcbi8vXFxuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXFxuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXFxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5Llxcbi8vXFxuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cXG5cXG4ndXNlIHN0cmljdCc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XFxuXFxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XFxudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XFxuXFxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcXG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XFxuXFxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xcblxcbiAgaWYgKCFjYikge1xcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xcbiAgfVxcblxcbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XFxuICB0cy53cml0ZWNiID0gbnVsbDtcXG5cXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxcbiAgICB0aGlzLnB1c2goZGF0YSk7XFxuXFxuICBjYihlcik7XFxuXFxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XFxuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XFxuXFxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcXG5cXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXFxuICAgIHdyaXRlY2I6IG51bGwsXFxuICAgIHdyaXRlY2h1bms6IG51bGwsXFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcXG4gIH07XFxuXFxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG5cXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XFxuXFxuICBpZiAob3B0aW9ucykge1xcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcXG5cXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XFxuICB9XFxuXFxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXFxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xcbn1cXG5cXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XFxuICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcXG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XFxuICAgIH0pO1xcbiAgfSBlbHNlIHtcXG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcXG4gIH1cXG59XFxuXFxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XFxufTtcXG5cXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXFxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cXG4vL1xcbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXFxuLy9cXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xcbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3VcXG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxcblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcXG59O1xcblxcblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xcbiAgdHMud3JpdGVjYiA9IGNiO1xcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcXG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XFxuICB9XFxufTtcXG5cXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxcbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXFxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcXG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xcblxcbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XFxuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XFxuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XFxuICB9IGVsc2Uge1xcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXFxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxcbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcXG4gIH1cXG59O1xcblxcblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xcbiAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xcbiAgICBjYihlcnIyKTtcXG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XFxuICB9KTtcXG59O1xcblxcbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xcblxcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xcblxcbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcXG5cXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XFxuXFxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XFxufVxcbn0se1xcXCIuL19zdHJlYW1fZHVwbGV4XFxcIjo1OCxcXFwiY29yZS11dGlsLWlzXFxcIjo0MixcXFwiaW5oZXJpdHNcXFwiOjUwfV0sNjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxcbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxcblxcbid1c2Ugc3RyaWN0JztcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcblxcbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XFxuXFxuLyogPHJlcGxhY2VtZW50PiAqL1xcbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcXG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcXG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcXG4gIHRoaXMubmV4dCA9IG51bGw7XFxufVxcblxcbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxcbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcXG4gIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICB0aGlzLm5leHQgPSBudWxsO1xcbiAgdGhpcy5lbnRyeSA9IG51bGw7XFxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcXG4gIH07XFxufVxcbi8qIDwvcmVwbGFjZW1lbnQ+ICovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIER1cGxleDtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XFxudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgaW50ZXJuYWxVdGlsID0ge1xcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXFxufTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XFxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XFxuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xcbn1cXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XFxufVxcblxcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XFxuXFxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcXG5cXG5mdW5jdGlvbiBub3AoKSB7fVxcblxcbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XFxuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xcblxcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXFxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxcbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xcblxcbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXFxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXFxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcXG5cXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XFxuXFxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXFxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcXG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcXG5cXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xcblxcbiAgLy8gY2FzdCB0byBpbnRzLlxcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xcblxcbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xcblxcbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XFxuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcXG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcXG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xcblxcbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xcblxcbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XFxuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXFxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xcblxcbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxcbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxcbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XFxuXFxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xcbiAgLy8gc29ja2V0IG9yIGZpbGUuXFxuICB0aGlzLmxlbmd0aCA9IDA7XFxuXFxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxcbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XFxuXFxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXFxuICB0aGlzLmNvcmtlZCA9IDA7XFxuXFxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XFxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcXFwibGF0ZXJcXFwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xcbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXFxuICB0aGlzLnN5bmMgPSB0cnVlO1xcblxcbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcXG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxcbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XFxuXFxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXFxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcXG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcXG4gIH07XFxuXFxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XFxuXFxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXFxuICB0aGlzLndyaXRlbGVuID0gMDtcXG5cXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcXG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XFxuXFxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XFxuXFxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXFxuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xcblxcbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XFxuXFxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XFxuXFxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXFxuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXFxuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xcbn1cXG5cXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XFxuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xcbiAgdmFyIG91dCA9IFtdO1xcbiAgd2hpbGUgKGN1cnJlbnQpIHtcXG4gICAgb3V0LnB1c2goY3VycmVudCk7XFxuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XFxuICB9XFxuICByZXR1cm4gb3V0O1xcbn07XFxuXFxuKGZ1bmN0aW9uICgpIHtcXG4gIHRyeSB7XFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcXG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XFxuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXFxuICAgIH0pO1xcbiAgfSBjYXRjaCAoXykge31cXG59KSgpO1xcblxcbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cXG52YXIgcmVhbEhhc0luc3RhbmNlO1xcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcXG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcXG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XFxuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XFxuXFxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xcbiAgICB9XFxuICB9KTtcXG59IGVsc2Uge1xcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcXG4gIH07XFxufVxcblxcbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcXG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XFxuXFxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxcblxcbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXFxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcXG4gIH1cXG5cXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcXG5cXG4gIC8vIGxlZ2FjeS5cXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xcblxcbiAgaWYgKG9wdGlvbnMpIHtcXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XFxuXFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xcblxcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcXG5cXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XFxuICB9XFxuXFxuICBTdHJlYW0uY2FsbCh0aGlzKTtcXG59XFxuXFxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxcbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcXG59O1xcblxcbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcXG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXFxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcXG59XFxuXFxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXFxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcXG4gIHZhciB2YWxpZCA9IHRydWU7XFxuICB2YXIgZXIgPSBmYWxzZTtcXG5cXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcXG4gIH1cXG4gIGlmIChlcikge1xcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xcbiAgICB2YWxpZCA9IGZhbHNlO1xcbiAgfVxcbiAgcmV0dXJuIHZhbGlkO1xcbn1cXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcXG4gIHZhciByZXQgPSBmYWxzZTtcXG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xcblxcbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XFxuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XFxuICB9XFxuXFxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGNiID0gZW5jb2Rpbmc7XFxuICAgIGVuY29kaW5nID0gbnVsbDtcXG4gIH1cXG5cXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xcblxcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XFxuXFxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XFxuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcXG4gIH1cXG5cXG4gIHJldHVybiByZXQ7XFxufTtcXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XFxuXFxuICBzdGF0ZS5jb3JrZWQrKztcXG59O1xcblxcbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xcblxcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xcbiAgICBzdGF0ZS5jb3JrZWQtLTtcXG5cXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xcbiAgfVxcbn07XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXFxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XFxuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcXG4gIH1cXG4gIHJldHVybiBjaHVuaztcXG59XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcXG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXFxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxcbiAgZW51bWVyYWJsZTogZmFsc2UsXFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcXG4gIH1cXG59KTtcXG5cXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXFxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgaWYgKCFpc0J1Zikge1xcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcXG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xcbiAgICAgIGlzQnVmID0gdHJ1ZTtcXG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XFxuICAgIH1cXG4gIH1cXG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcXG5cXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XFxuXFxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcXG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxcbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XFxuXFxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcXG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xcbiAgICAgIGNodW5rOiBjaHVuayxcXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXFxuICAgICAgaXNCdWY6IGlzQnVmLFxcbiAgICAgIGNhbGxiYWNrOiBjYixcXG4gICAgICBuZXh0OiBudWxsXFxuICAgIH07XFxuICAgIGlmIChsYXN0KSB7XFxuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xcbiAgICB9XFxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XFxuICB9IGVsc2Uge1xcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XFxuICBzdGF0ZS53cml0ZWNiID0gY2I7XFxuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcXG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xcbn1cXG5cXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XFxuICAtLXN0YXRlLnBlbmRpbmdjYjtcXG5cXG4gIGlmIChzeW5jKSB7XFxuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcXG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XFxuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXFxuICAgIC8vIGFmdGVyIGVycm9yXFxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XFxuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxuICB9IGVsc2Uge1xcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcXG4gICAgLy8gaXQgaXMgYXN5bmNcXG4gICAgY2IoZXIpO1xcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcXG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XFxuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XFxuICBzdGF0ZS53cml0ZWxlbiA9IDA7XFxufVxcblxcbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcXG5cXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XFxuXFxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcXG5cXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xcbiAgICB9XFxuXFxuICAgIGlmIChzeW5jKSB7XFxuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XFxuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXFxuICAgIH0gZWxzZSB7XFxuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XFxuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XFxuICBzdGF0ZS5wZW5kaW5nY2ItLTtcXG4gIGNiKCk7XFxuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcXG59XFxuXFxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcXG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXFxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcXG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XFxuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xcbiAgfVxcbn1cXG5cXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xcblxcbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcXG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcXG5cXG4gICAgdmFyIGNvdW50ID0gMDtcXG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xcbiAgICB3aGlsZSAoZW50cnkpIHtcXG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XFxuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcXG4gICAgICBjb3VudCArPSAxO1xcbiAgICB9XFxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcXG5cXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xcblxcbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XFxuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcXG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcXG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xcbiAgICB9XFxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcXG4gICAgd2hpbGUgKGVudHJ5KSB7XFxuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XFxuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XFxuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XFxuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xcblxcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XFxuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XFxuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxcbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcXG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XFxuICB9XFxuXFxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcXG59XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcXG59O1xcblxcbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XFxuXFxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGNiID0gY2h1bms7XFxuICAgIGNodW5rID0gbnVsbDtcXG4gICAgZW5jb2RpbmcgPSBudWxsO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgY2IgPSBlbmNvZGluZztcXG4gICAgZW5jb2RpbmcgPSBudWxsO1xcbiAgfVxcblxcbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcXG5cXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXFxuICBpZiAoc3RhdGUuY29ya2VkKSB7XFxuICAgIHN0YXRlLmNvcmtlZCA9IDE7XFxuICAgIHRoaXMudW5jb3JrKCk7XFxuICB9XFxuXFxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXFxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XFxufTtcXG5cXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XFxuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xcbn1cXG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XFxuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xcbiAgICBpZiAoZXJyKSB7XFxuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcXG4gICAgfVxcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XFxuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XFxuICB9KTtcXG59XFxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XFxuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcXG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XFxuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcXG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XFxuICBpZiAobmVlZCkge1xcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XFxuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcXG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XFxuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbmVlZDtcXG59XFxuXFxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcXG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XFxuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcXG4gIGlmIChjYikge1xcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xcbiAgfVxcbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XFxufVxcblxcbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcXG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XFxuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcXG4gIHdoaWxlIChlbnRyeSkge1xcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcXG4gICAgc3RhdGUucGVuZGluZ2NiLS07XFxuICAgIGNiKGVycik7XFxuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcXG4gIH1cXG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcXG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xcbiAgfSBlbHNlIHtcXG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcXG4gIH1cXG59XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcXG4gIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcXG4gIH0sXFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcXG4gIH1cXG59KTtcXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XFxuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XFxuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcXG4gIHRoaXMuZW5kKCk7XFxuICBjYihlcnIpO1xcbn07XFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi9fc3RyZWFtX2R1cGxleFxcXCI6NTgsXFxcIi4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95XFxcIjo2NCxcXFwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbVxcXCI6NjUsXFxcIl9wcm9jZXNzXFxcIjo1NixcXFwiY29yZS11dGlsLWlzXFxcIjo0MixcXFwiaW5oZXJpdHNcXFwiOjUwLFxcXCJwcm9jZXNzLW5leHRpY2stYXJnc1xcXCI6NTUsXFxcInNhZmUtYnVmZmVyXFxcIjo3MCxcXFwidXRpbC1kZXByZWNhdGVcXFwiOjczfV0sNjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XFxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XFxuXFxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XFxuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xcblxcbiAgICB0aGlzLmhlYWQgPSBudWxsO1xcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xcbiAgICB0aGlzLmxlbmd0aCA9IDA7XFxuICB9XFxuXFxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XFxuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XFxuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xcbiAgICArK3RoaXMubGVuZ3RoO1xcbiAgfTtcXG5cXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcXG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcXG4gICAgdGhpcy5oZWFkID0gZW50cnk7XFxuICAgICsrdGhpcy5sZW5ndGg7XFxuICB9O1xcblxcbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XFxuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XFxuICAgIC0tdGhpcy5sZW5ndGg7XFxuICAgIHJldHVybiByZXQ7XFxuICB9O1xcblxcbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcXG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcXG4gICAgdGhpcy5sZW5ndGggPSAwO1xcbiAgfTtcXG5cXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XFxuICAgIHZhciBwID0gdGhpcy5oZWFkO1xcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XFxuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XFxuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XFxuICAgIH1yZXR1cm4gcmV0O1xcbiAgfTtcXG5cXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XFxuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XFxuICAgIHZhciBwID0gdGhpcy5oZWFkO1xcbiAgICB2YXIgaSA9IDA7XFxuICAgIHdoaWxlIChwKSB7XFxuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XFxuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xcbiAgICAgIHAgPSBwLm5leHQ7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJldDtcXG4gIH07XFxuXFxuICByZXR1cm4gQnVmZmVyTGlzdDtcXG59KCk7XFxuXFxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcXG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XFxuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XFxuICB9O1xcbn1cXG59LHtcXFwic2FmZS1idWZmZXJcXFwiOjcwLFxcXCJ1dGlsXFxcIjozOH1dLDY0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXFxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XFxuICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcXG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XFxuXFxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcXG4gICAgaWYgKGNiKSB7XFxuICAgICAgY2IoZXJyKTtcXG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcXG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xcblxcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xcbiAgfVxcblxcbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xcbiAgfVxcblxcbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xcbiAgICBpZiAoIWNiICYmIGVycikge1xcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XFxuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XFxuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChjYikge1xcbiAgICAgIGNiKGVycik7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcmV0dXJuIHRoaXM7XFxufVxcblxcbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xcbiAgfVxcblxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgZGVzdHJveTogZGVzdHJveSxcXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XFxufTtcXG59LHtcXFwicHJvY2Vzcy1uZXh0aWNrLWFyZ3NcXFwiOjU1fV0sNjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcblxcbn0se1xcXCJldmVudHNcXFwiOjQ3fV0sNjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXFxuXFxufSx7XFxcIi4vcmVhZGFibGVcXFwiOjY3fV0sNjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcXG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XFxuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XFxuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcXG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XFxuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XFxuXFxufSx7XFxcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXFxcIjo1OCxcXFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1xcXCI6NTksXFxcIi4vbGliL19zdHJlYW1fcmVhZGFibGUuanNcXFwiOjYwLFxcXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1xcXCI6NjEsXFxcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcXFwiOjYyfV0sNjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxcblxcbn0se1xcXCIuL3JlYWRhYmxlXFxcIjo2N31dLDY5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcXG5cXG59LHtcXFwiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1xcXCI6NjJ9XSw3MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xcbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXFxuXFxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcXG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcXG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxcbiAgfVxcbn1cXG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxcbn0gZWxzZSB7XFxuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxcbn1cXG5cXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXFxuXFxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XFxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxcbiAgfVxcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcXG4gIH1cXG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcXG4gICAgfSBlbHNlIHtcXG4gICAgICBidWYuZmlsbChmaWxsKVxcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBidWYuZmlsbCgwKVxcbiAgfVxcbiAgcmV0dXJuIGJ1Zlxcbn1cXG5cXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcXG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXFxuICB9XFxuICByZXR1cm4gQnVmZmVyKHNpemUpXFxufVxcblxcblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcXG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXFxuICB9XFxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcXG59XFxuXFxufSx7XFxcImJ1ZmZlclxcXCI6NDF9XSw3MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XFxuXFxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuXFxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XFxuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XFxuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XFxuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcXG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xcblxcbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcXG5cXG5cXG5cXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cXG5cXG5mdW5jdGlvbiBTdHJlYW0oKSB7XFxuICBFRS5jYWxsKHRoaXMpO1xcbn1cXG5cXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XFxuICB2YXIgc291cmNlID0gdGhpcztcXG5cXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XFxuICAgICAgICBzb3VyY2UucGF1c2UoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XFxuXFxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcXG4gICAgICBzb3VyY2UucmVzdW1lKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XFxuXFxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXFxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcXG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xcbiAgfVxcblxcbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XFxuICBmdW5jdGlvbiBvbmVuZCgpIHtcXG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XFxuICAgIGRpZE9uRW5kID0gdHJ1ZTtcXG5cXG4gICAgZGVzdC5lbmQoKTtcXG4gIH1cXG5cXG5cXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XFxuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xcbiAgICBkaWRPbkVuZCA9IHRydWU7XFxuXFxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcXG4gIH1cXG5cXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcXG4gICAgY2xlYW51cCgpO1xcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXFxuICAgIH1cXG4gIH1cXG5cXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcXG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XFxuXFxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcXG5cXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XFxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcXG5cXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xcblxcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XFxuXFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XFxuICB9XFxuXFxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xcblxcbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcXG5cXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XFxuXFxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxcbiAgcmV0dXJuIGRlc3Q7XFxufTtcXG5cXG59LHtcXFwiZXZlbnRzXFxcIjo0NyxcXFwiaW5oZXJpdHNcXFwiOjUwLFxcXCJyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzXFxcIjo1NyxcXFwicmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzXFxcIjo2NixcXFwicmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzXFxcIjo2NyxcXFwicmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qc1xcXCI6NjgsXFxcInJlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qc1xcXCI6Njl9XSw3MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxuXFxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XFxuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XFxuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcXG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcbn07XFxuXFxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XFxuICB2YXIgcmV0cmllZDtcXG4gIHdoaWxlICh0cnVlKSB7XFxuICAgIHN3aXRjaCAoZW5jKSB7XFxuICAgICAgY2FzZSAndXRmOCc6XFxuICAgICAgY2FzZSAndXRmLTgnOlxcbiAgICAgICAgcmV0dXJuICd1dGY4JztcXG4gICAgICBjYXNlICd1Y3MyJzpcXG4gICAgICBjYXNlICd1Y3MtMic6XFxuICAgICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcXG4gICAgICBjYXNlICdsYXRpbjEnOlxcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XFxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XFxuICAgICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgICBjYXNlICdhc2NpaSc6XFxuICAgICAgY2FzZSAnaGV4JzpcXG4gICAgICAgIHJldHVybiBlbmM7XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcXG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XFxuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcXG4gIHJldHVybiBuZW5jIHx8IGVuYztcXG59XFxuXFxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxcbi8vIGNoYXJhY3RlcnMuXFxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcXG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XFxuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xcbiAgdmFyIG5iO1xcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XFxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcXG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xcbiAgICAgIG5iID0gNDtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAndXRmOCc6XFxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcXG4gICAgICBuYiA9IDQ7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcXG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcXG4gICAgICBuYiA9IDM7XFxuICAgICAgYnJlYWs7XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xcbiAgICAgIHJldHVybjtcXG4gIH1cXG4gIHRoaXMubGFzdE5lZWQgPSAwO1xcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XFxufVxcblxcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcXG4gIHZhciByO1xcbiAgdmFyIGk7XFxuICBpZiAodGhpcy5sYXN0TmVlZCkge1xcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XFxuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcXG4gIH0gZWxzZSB7XFxuICAgIGkgPSAwO1xcbiAgfVxcbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xcbiAgcmV0dXJuIHIgfHwgJyc7XFxufTtcXG5cXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xcblxcbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXFxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xcblxcbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcXG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcXG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcXG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xcbiAgfVxcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcXG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcXG59O1xcblxcbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcXG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XFxufVxcblxcbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXFxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcXG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XFxuICBpZiAoaiA8IGkpIHJldHVybiAwO1xcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xcbiAgaWYgKG5iID49IDApIHtcXG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcXG4gICAgcmV0dXJuIG5iO1xcbiAgfVxcbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcXG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xcbiAgaWYgKG5iID49IDApIHtcXG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcXG4gICAgcmV0dXJuIG5iO1xcbiAgfVxcbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcXG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xcbiAgaWYgKG5iID49IDApIHtcXG4gICAgaWYgKG5iID4gMCkge1xcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcXG4gICAgfVxcbiAgICByZXR1cm4gbmI7XFxuICB9XFxuICByZXR1cm4gMDtcXG59XFxuXFxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXFxuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3RcXG4vLyBvbmUsIHdlIFxcXCJyZXBsYWNlXFxcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFxcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2RpbmdcXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXFxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXFxuLy8gbG9vcC5cXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcXG4gICAgcmV0dXJuICdcXFxcdWZmZmQnO1xcbiAgfVxcbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XFxuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcXG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcXG4gICAgICByZXR1cm4gJ1xcXFx1ZmZmZCc7XFxuICAgIH1cXG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XFxuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XFxuICAgICAgICByZXR1cm4gJ1xcXFx1ZmZmZCc7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XFxuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcXG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XFxuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XFxuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XFxuICB9XFxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcXG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcXG59XFxuXFxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXFxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXFxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XFxuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XFxuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcXG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XFxuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcXG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xcbn1cXG5cXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxcbi8vIGNoYXJhY3Rlci5cXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcXFx1ZmZmZCc7XFxuICByZXR1cm4gcjtcXG59XFxuXFxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xcbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXFxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XFxuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XFxuICAgIGlmIChyKSB7XFxuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcXG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcXG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XFxuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcXG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHI7XFxuICB9XFxuICB0aGlzLmxhc3ROZWVkID0gMTtcXG4gIHRoaXMubGFzdFRvdGFsID0gMjtcXG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcXG59XFxuXFxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2VcXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcXG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcXG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XFxuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XFxuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XFxuICB9XFxuICByZXR1cm4gcjtcXG59XFxuXFxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcXG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XFxuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XFxuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XFxuICB0aGlzLmxhc3RUb3RhbCA9IDM7XFxuICBpZiAobiA9PT0gMSkge1xcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcXG4gIH1cXG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcXG59XFxuXFxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xcbiAgcmV0dXJuIHI7XFxufVxcblxcbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcXG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XFxufVxcblxcbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcXG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xcbn1cXG59LHtcXFwic2FmZS1idWZmZXJcXFwiOjcwfV0sNzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAoZ2xvYmFsKXtcXG5cXG4vKipcXG4gKiBNb2R1bGUgZXhwb3J0cy5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcXG5cXG4vKipcXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxcbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXFxuICpcXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cXG4gKlxcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxcbiAqXFxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXFxuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcXFwiZGVwcmVjYXRlZFxcXCIgdmVyc2lvbiBvZiBgZm5gXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcXG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xcbiAgICByZXR1cm4gZm47XFxuICB9XFxuXFxuICB2YXIgd2FybmVkID0gZmFsc2U7XFxuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xcbiAgICBpZiAoIXdhcm5lZCkge1xcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XFxuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcXG4gICAgICB9XFxuICAgICAgd2FybmVkID0gdHJ1ZTtcXG4gICAgfVxcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gIH1cXG5cXG4gIHJldHVybiBkZXByZWNhdGVkO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcXG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXFxuICB0cnkge1xcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcXG4gIH0gY2F0Y2ggKF8pIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XFxuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcXG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XFxufVxcblxcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se31dLDc0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5hcmd1bWVudHNbNF1bNTBdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKVxcbn0se1xcXCJkdXBcXFwiOjUwfV0sNzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XFxuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXFxuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XFxufVxcbn0se31dLDc2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcXG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcXG4gIGlmICghaXNTdHJpbmcoZikpIHtcXG4gICAgdmFyIG9iamVjdHMgPSBbXTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcXG4gICAgfVxcbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XFxuICB9XFxuXFxuICB2YXIgaSA9IDE7XFxuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcXG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcXG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcXG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XFxuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XFxuICAgIHN3aXRjaCAoeCkge1xcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xcbiAgICAgIGNhc2UgJyVqJzpcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xcbiAgICAgICAgfSBjYXRjaCAoXykge1xcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xcbiAgICAgICAgfVxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICByZXR1cm4geDtcXG4gICAgfVxcbiAgfSk7XFxuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xcbiAgICAgIHN0ciArPSAnICcgKyB4O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gc3RyO1xcbn07XFxuXFxuXFxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0Llxcbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXFxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XFxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxcbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIH07XFxuICB9XFxuXFxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XFxuICAgIHJldHVybiBmbjtcXG4gIH1cXG5cXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XFxuICAgIGlmICghd2FybmVkKSB7XFxuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XFxuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcXG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xcbiAgICAgIH1cXG4gICAgICB3YXJuZWQgPSB0cnVlO1xcbiAgICB9XFxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XFxufTtcXG5cXG5cXG52YXIgZGVidWdzID0ge307XFxudmFyIGRlYnVnRW52aXJvbjtcXG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XFxuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcXG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXFxcXFxiJyArIHNldCArICdcXFxcXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcXG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XFxuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcXG4gICAgICB9O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xcbn07XFxuXFxuXFxuLyoqXFxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxcbiAqL1xcbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xcbiAgLy8gZGVmYXVsdCBvcHRpb25zXFxuICB2YXIgY3R4ID0ge1xcbiAgICBzZWVuOiBbXSxcXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcXG4gIH07XFxuICAvLyBsZWdhY3kuLi5cXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XFxuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XFxuICAgIC8vIGxlZ2FjeS4uLlxcbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XFxuICB9IGVsc2UgaWYgKG9wdHMpIHtcXG4gICAgLy8gZ290IGFuIFxcXCJvcHRpb25zXFxcIiBvYmplY3RcXG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XFxuICB9XFxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXFxuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XFxuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcXG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcXG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XFxuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XFxufVxcbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XFxuXFxuXFxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXFxuaW5zcGVjdC5jb2xvcnMgPSB7XFxuICAnYm9sZCcgOiBbMSwgMjJdLFxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcXG4gICdncmV5JyA6IFs5MCwgMzldLFxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXFxuICAnY3lhbicgOiBbMzYsIDM5XSxcXG4gICdncmVlbicgOiBbMzIsIDM5XSxcXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cXG59O1xcblxcbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxcbmluc3BlY3Quc3R5bGVzID0ge1xcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXFxuICAnbnVtYmVyJzogJ3llbGxvdycsXFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcXG4gICdudWxsJzogJ2JvbGQnLFxcbiAgJ3N0cmluZyc6ICdncmVlbicsXFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcXG4gIC8vIFxcXCJuYW1lXFxcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xcbiAgJ3JlZ2V4cCc6ICdyZWQnXFxufTtcXG5cXG5cXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XFxuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xcblxcbiAgaWYgKHN0eWxlKSB7XFxuICAgIHJldHVybiAnXFxcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xcbiAgICAgICAgICAgJ1xcXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIHN0cjtcXG4gIH1cXG59XFxuXFxuXFxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcXG4gIHJldHVybiBzdHI7XFxufVxcblxcblxcbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XFxuICB2YXIgaGFzaCA9IHt9O1xcblxcbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xcbiAgfSk7XFxuXFxuICByZXR1cm4gaGFzaDtcXG59XFxuXFxuXFxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XFxuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXFxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcXG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxcbiAgICAgIHZhbHVlICYmXFxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxcbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcXG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcXG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmV0O1xcbiAgfVxcblxcbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XFxuICBpZiAocHJpbWl0aXZlKSB7XFxuICAgIHJldHVybiBwcmltaXRpdmU7XFxuICB9XFxuXFxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXFxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcXG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xcblxcbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XFxuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XFxuICB9XFxuXFxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXFxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxcbiAgaWYgKGlzRXJyb3IodmFsdWUpXFxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XFxuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XFxuICB9XFxuXFxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXFxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XFxuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xcbiAgICB9XFxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xcbiAgICB9XFxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XFxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xcbiAgICB9XFxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XFxuXFxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XFxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgYXJyYXkgPSB0cnVlO1xcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xcbiAgfVxcblxcbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXFxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcXG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcXG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XFxuICB9XFxuXFxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcXG4gIH1cXG5cXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcXG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xcbiAgfVxcblxcbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XFxuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XFxuICB9XFxuXFxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcXG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XFxuICB9XFxuXFxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XFxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XFxuXFxuICB2YXIgb3V0cHV0O1xcbiAgaWYgKGFycmF5KSB7XFxuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xcbiAgfSBlbHNlIHtcXG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XFxuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGN0eC5zZWVuLnBvcCgpO1xcblxcbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcXG59XFxuXFxuXFxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcXG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXFxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xcbiAgICB2YXIgc2ltcGxlID0gJ1xcXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXFxcInxcXFwiJC9nLCAnJylcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcXFwiXFxcXFxcXFwnXFxcIilcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFxcXFxcXFwiL2csICdcXFwiJykgKyAnXFxcXCcnO1xcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XFxuICB9XFxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXFxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFxcXCJvYmplY3RcXFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cXG4gIGlmIChpc051bGwodmFsdWUpKVxcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcXG59XFxuXFxuXFxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xcbiAgdmFyIG91dHB1dCA9IFtdO1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcXG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XFxuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgb3V0cHV0LnB1c2goJycpO1xcbiAgICB9XFxuICB9XFxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XFxuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxcXGQrJC8pKSB7XFxuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcXG4gICAgICAgICAga2V5LCB0cnVlKSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgcmV0dXJuIG91dHB1dDtcXG59XFxuXFxuXFxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcXG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcXG4gIGlmIChkZXNjLmdldCkge1xcbiAgICBpZiAoZGVzYy5zZXQpIHtcXG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBpZiAoZGVzYy5zZXQpIHtcXG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xcbiAgICB9XFxuICB9XFxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XFxuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XFxuICB9XFxuICBpZiAoIXN0cikge1xcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcXG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcXG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XFxuICAgICAgfVxcbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxcXG4nKSA+IC0xKSB7XFxuICAgICAgICBpZiAoYXJyYXkpIHtcXG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXFxcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XFxuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xcbiAgICAgICAgICB9KS5qb2luKCdcXFxcbicpLnN1YnN0cigyKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHN0ciA9ICdcXFxcbicgKyBzdHIuc3BsaXQoJ1xcXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xcbiAgICAgICAgICB9KS5qb2luKCdcXFxcbicpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XFxuICAgIH1cXG4gIH1cXG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxcXGQrJC8pKSB7XFxuICAgICAgcmV0dXJuIHN0cjtcXG4gICAgfVxcbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xcbiAgICBpZiAobmFtZS5tYXRjaCgvXlxcXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcXFwiJC8pKSB7XFxuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XFxuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcXFwiXFxcXFxcXFwnXFxcIilcXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXFxcXFxcXCIvZywgJ1xcXCInKVxcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXFxcInxcXFwiJCkvZywgXFxcIidcXFwiKTtcXG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XFxufVxcblxcblxcbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XFxuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XFxuICAgIG51bUxpbmVzRXN0Kys7XFxuICAgIGlmIChjdXIuaW5kZXhPZignXFxcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXFxcdTAwMWJcXFxcW1xcXFxkXFxcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcXG4gIH0sIDApO1xcblxcbiAgaWYgKGxlbmd0aCA+IDYwKSB7XFxuICAgIHJldHVybiBicmFjZXNbMF0gK1xcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcXFxuICcpICtcXG4gICAgICAgICAgICcgJyArXFxuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcXFxuICAnKSArXFxuICAgICAgICAgICAnICcgK1xcbiAgICAgICAgICAgYnJhY2VzWzFdO1xcbiAgfVxcblxcbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcXG59XFxuXFxuXFxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXFxuZnVuY3Rpb24gaXNBcnJheShhcikge1xcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xcbn1cXG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xcblxcbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XFxufVxcbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xcblxcbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IG51bGw7XFxufVxcbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xcblxcbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xcbn1cXG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XFxuXFxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XFxufVxcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcXG5cXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcXG59XFxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xcblxcbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xcbn1cXG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XFxuXFxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XFxufVxcbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcXG5cXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xcbn1cXG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XFxuXFxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xcbn1cXG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XFxuXFxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcXG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xcbn1cXG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcXG5cXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcXG4gIHJldHVybiBpc09iamVjdChlKSAmJlxcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xcbn1cXG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xcblxcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcXG59XFxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcXG5cXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcXG59XFxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xcblxcbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcXG5cXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XFxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBwYWQobikge1xcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XFxufVxcblxcblxcbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xcblxcbi8vIDI2IEZlYiAxNjoxOTozNFxcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcXG4gIHZhciBkID0gbmV3IERhdGUoKTtcXG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcXG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XFxufVxcblxcblxcbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XFxufTtcXG5cXG5cXG4vKipcXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXFxuICpcXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXFxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cXG4gKlxcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcXG4gKiAgICAgcHJvdG90eXBlLlxcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxcbiAqL1xcbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcblxcbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XFxuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcXG5cXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcXG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XFxuICB3aGlsZSAoaS0tKSB7XFxuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcXG4gIH1cXG4gIHJldHVybiBvcmlnaW47XFxufTtcXG5cXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi9zdXBwb3J0L2lzQnVmZmVyXFxcIjo3NSxcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJpbmhlcml0c1xcXCI6NzR9XX0se30sWzFdKTtcXG5cIiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xuXHRmdW5jdGlvbiBsb2coZXJyb3IpIHtcblx0XHQodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpXG5cdFx0JiYgKGNvbnNvbGUuZXJyb3IgfHwgY29uc29sZS5sb2cpKFwiW1NjcmlwdCBMb2FkZXJdXCIsIGVycm9yKTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBJRSA9PCA4XG5cdGZ1bmN0aW9uIGlzSUUoKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBhdHRhY2hFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJ1bmRlZmluZWRcIjtcblx0fVxuXG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiBleGVjU2NyaXB0ICE9PSBcInVuZGVmaW5lZFwiICYmIGlzSUUoKSkge1xuXHRcdFx0ZXhlY1NjcmlwdChzcmMpO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGV2YWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdGV2YWwuY2FsbChudWxsLCBzcmMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb2coXCJFdmFsRXJyb3I6IE5vIGV2YWwgZnVuY3Rpb24gYXZhaWxhYmxlXCIpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRsb2coZXJyb3IpO1xuXHR9XG59XG4iLCJyZXF1aXJlKFwiISEvVXNlcnMvcGtpbS9Eb2N1bWVudHMvVHVyaW5nIE1haW4vTW9kMi9nYW1lLXRpbWUvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy9wa2ltL0RvY3VtZW50cy9UdXJpbmcgTWFpbi9Nb2QyL2dhbWUtdGltZS9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvcGtpbS9Eb2N1bWVudHMvVHVyaW5nIE1haW4vTW9kMi9nYW1lLXRpbWUvbm9kZV9tb2R1bGVzL21vY2hhL21vY2hhLmpzXCIpKSJdLCJzb3VyY2VSb290IjoiIn0=